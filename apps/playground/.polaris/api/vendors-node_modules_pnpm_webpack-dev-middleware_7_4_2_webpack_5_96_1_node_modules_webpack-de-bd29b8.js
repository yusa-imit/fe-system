"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendors-node_modules_pnpm_webpack-dev-middleware_7_4_2_webpack_5_96_1_node_modules_webpack-de-bd29b8";
exports.ids = ["vendors-node_modules_pnpm_webpack-dev-middleware_7_4_2_webpack_5_96_1_node_modules_webpack-de-bd29b8"];
exports.modules = {

/***/ "../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatNames = exports.fastFormats = exports.fullFormats = void 0;\nfunction fmtDef(validate, compare) {\n    return { validate, compare };\n}\nexports.fullFormats = {\n    // date: http://tools.ietf.org/html/rfc3339#section-5.6\n    date: fmtDef(date, compareDate),\n    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n    time: fmtDef(time, compareTime),\n    \"date-time\": fmtDef(date_time, compareDateTime),\n    // duration: https://tools.ietf.org/html/rfc3339#appendix-A\n    duration: /^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n    uri,\n    \"uri-reference\": /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n    // uri-template: https://tools.ietf.org/html/rfc6570\n    \"uri-template\": /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n    // For the source: https://gist.github.com/dperini/729294\n    // For test cases: https://mathiasbynens.be/demo/url-regex\n    url: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n    hostname: /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n    ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n    regex,\n    // uuid: http://tools.ietf.org/html/rfc4122\n    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n    // JSON-pointer: https://tools.ietf.org/html/rfc6901\n    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n    \"json-pointer\": /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n    \"json-pointer-uri-fragment\": /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n    \"relative-json-pointer\": /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n    // byte: https://github.com/miguelmota/is-base64\n    byte,\n    // signed 32 bit integer\n    int32: { type: \"number\", validate: validateInt32 },\n    // signed 64 bit integer\n    int64: { type: \"number\", validate: validateInt64 },\n    // C-type float\n    float: { type: \"number\", validate: validateNumber },\n    // C-type double\n    double: { type: \"number\", validate: validateNumber },\n    // hint to the UI to hide input strings\n    password: true,\n    // unchecked string payload\n    binary: true,\n};\nexports.fastFormats = {\n    ...exports.fullFormats,\n    date: fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/, compareDate),\n    time: fmtDef(/^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i, compareTime),\n    \"date-time\": fmtDef(/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i, compareDateTime),\n    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n    uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n    \"uri-reference\": /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n    // email (sources from jsen validator):\n    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')\n    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n};\nexports.formatNames = Object.keys(exports.fullFormats);\nfunction isLeapYear(year) {\n    // https://tools.ietf.org/html/rfc3339#appendix-C\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nfunction date(str) {\n    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n    const matches = DATE.exec(str);\n    if (!matches)\n        return false;\n    const year = +matches[1];\n    const month = +matches[2];\n    const day = +matches[3];\n    return (month >= 1 &&\n        month <= 12 &&\n        day >= 1 &&\n        day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]));\n}\nfunction compareDate(d1, d2) {\n    if (!(d1 && d2))\n        return undefined;\n    if (d1 > d2)\n        return 1;\n    if (d1 < d2)\n        return -1;\n    return 0;\n}\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nfunction time(str, withTimeZone) {\n    const matches = TIME.exec(str);\n    if (!matches)\n        return false;\n    const hour = +matches[1];\n    const minute = +matches[2];\n    const second = +matches[3];\n    const timeZone = matches[5];\n    return (((hour <= 23 && minute <= 59 && second <= 59) ||\n        (hour === 23 && minute === 59 && second === 60)) &&\n        (!withTimeZone || timeZone !== \"\"));\n}\nfunction compareTime(t1, t2) {\n    if (!(t1 && t2))\n        return undefined;\n    const a1 = TIME.exec(t1);\n    const a2 = TIME.exec(t2);\n    if (!(a1 && a2))\n        return undefined;\n    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || \"\");\n    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || \"\");\n    if (t1 > t2)\n        return 1;\n    if (t1 < t2)\n        return -1;\n    return 0;\n}\nconst DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction date_time(str) {\n    // http://tools.ietf.org/html/rfc3339#section-5.6\n    const dateTime = str.split(DATE_TIME_SEPARATOR);\n    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);\n}\nfunction compareDateTime(dt1, dt2) {\n    if (!(dt1 && dt2))\n        return undefined;\n    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);\n    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);\n    const res = compareDate(d1, d2);\n    if (res === undefined)\n        return undefined;\n    return res || compareTime(t1, t2);\n}\nconst NOT_URI_FRAGMENT = /\\/|:/;\nconst URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nfunction uri(str) {\n    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n    return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n}\nconst BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;\nfunction byte(str) {\n    BYTE.lastIndex = 0;\n    return BYTE.test(str);\n}\nconst MIN_INT32 = -(2 ** 31);\nconst MAX_INT32 = 2 ** 31 - 1;\nfunction validateInt32(value) {\n    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;\n}\nfunction validateInt64(value) {\n    // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n    return Number.isInteger(value);\n}\nfunction validateNumber() {\n    return true;\n}\nconst Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n    if (Z_ANCHOR.test(str))\n        return false;\n    try {\n        new RegExp(str);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n//# sourceMappingURL=formats.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js ***!
  \****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst formats_1 = __webpack_require__(/*! ./formats */ \"../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js\");\nconst limit_1 = __webpack_require__(/*! ./limit */ \"../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js\");\nconst codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst fullName = new codegen_1.Name(\"fullFormats\");\nconst fastName = new codegen_1.Name(\"fastFormats\");\nconst formatsPlugin = (ajv, opts = { keywords: true }) => {\n    if (Array.isArray(opts)) {\n        addFormats(ajv, opts, formats_1.fullFormats, fullName);\n        return ajv;\n    }\n    const [formats, exportName] = opts.mode === \"fast\" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];\n    const list = opts.formats || formats_1.formatNames;\n    addFormats(ajv, list, formats, exportName);\n    if (opts.keywords)\n        limit_1.default(ajv);\n    return ajv;\n};\nformatsPlugin.get = (name, mode = \"full\") => {\n    const formats = mode === \"fast\" ? formats_1.fastFormats : formats_1.fullFormats;\n    const f = formats[name];\n    if (!f)\n        throw new Error(`Unknown format \"${name}\"`);\n    return f;\n};\nfunction addFormats(ajv, list, fs, exportName) {\n    var _a;\n    var _b;\n    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : (_b.formats = codegen_1._ `require(\"ajv-formats/dist/formats\").${exportName}`);\n    for (const f of list)\n        ajv.addFormat(f, fs[f]);\n}\nmodule.exports = exports = formatsPlugin;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = formatsPlugin;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatLimitDefinition = void 0;\nconst ajv_1 = __webpack_require__(/*! ajv */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js\");\nconst codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    formatMaximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    formatMinimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    formatExclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    formatExclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => codegen_1.str `should be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => codegen_1._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nexports.formatLimitDefinition = {\n    keyword: Object.keys(KWDs),\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, keyword, it } = cxt;\n        const { opts, self } = it;\n        if (!opts.validateFormats)\n            return;\n        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, \"format\");\n        if (fCxt.$data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fmt = gen.const(\"fmt\", codegen_1._ `${fmts}[${fCxt.schemaCode}]`);\n            cxt.fail$data(codegen_1.or(codegen_1._ `typeof ${fmt} != \"object\"`, codegen_1._ `${fmt} instanceof RegExp`, codegen_1._ `typeof ${fmt}.compare != \"function\"`, compareCode(fmt)));\n        }\n        function validateFormat() {\n            const format = fCxt.schema;\n            const fmtDef = self.formats[format];\n            if (!fmtDef || fmtDef === true)\n                return;\n            if (typeof fmtDef != \"object\" ||\n                fmtDef instanceof RegExp ||\n                typeof fmtDef.compare != \"function\") {\n                throw new Error(`\"${keyword}\": format \"${format}\" does not define \"compare\" function`);\n            }\n            const fmt = gen.scopeValue(\"formats\", {\n                key: format,\n                ref: fmtDef,\n                code: opts.code.formats ? codegen_1._ `${opts.code.formats}${codegen_1.getProperty(format)}` : undefined,\n            });\n            cxt.fail$data(compareCode(fmt));\n        }\n        function compareCode(fmt) {\n            return codegen_1._ `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;\n        }\n    },\n    dependencies: [\"format\"],\n};\nconst formatLimitPlugin = (ajv) => {\n    ajv.addKeyword(exports.formatLimitDefinition);\n    return ajv;\n};\nexports[\"default\"] = formatLimitPlugin;\n//# sourceMappingURL=limit.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_range.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_range.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction getRangeDef(keyword) {\n    return () => ({\n        keyword,\n        type: \"number\",\n        schemaType: \"array\",\n        macro: function ([min, max]) {\n            validateRangeSchema(min, max);\n            return keyword === \"range\"\n                ? { minimum: min, maximum: max }\n                : { exclusiveMinimum: min, exclusiveMaximum: max };\n        },\n        metaSchema: {\n            type: \"array\",\n            minItems: 2,\n            maxItems: 2,\n            items: { type: \"number\" },\n        },\n    });\n    function validateRangeSchema(min, max) {\n        if (min > max || (keyword === \"exclusiveRange\" && min === max)) {\n            throw new Error(\"There are no numbers in range\");\n        }\n    }\n}\nexports[\"default\"] = getRangeDef;\n//# sourceMappingURL=_range.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_range.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_required.js":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_required.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction getRequiredDef(keyword) {\n    return () => ({\n        keyword,\n        type: \"object\",\n        schemaType: \"array\",\n        macro(schema) {\n            if (schema.length === 0)\n                return true;\n            if (schema.length === 1)\n                return { required: schema };\n            const comb = keyword === \"anyRequired\" ? \"anyOf\" : \"oneOf\";\n            return { [comb]: schema.map((p) => ({ required: [p] })) };\n        },\n        metaSchema: {\n            type: \"array\",\n            items: { type: \"string\" },\n        },\n    });\n}\nexports[\"default\"] = getRequiredDef;\n//# sourceMappingURL=_required.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_required.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_util.js":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_util.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.usePattern = exports.metaSchemaRef = void 0;\nconst codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst META_SCHEMA_ID = \"http://json-schema.org/schema\";\nfunction metaSchemaRef({ defaultMeta } = {}) {\n    return defaultMeta === false ? {} : { $ref: defaultMeta || META_SCHEMA_ID };\n}\nexports.metaSchemaRef = metaSchemaRef;\nfunction usePattern({ gen, it: { opts } }, pattern, flags = opts.unicodeRegExp ? \"u\" : \"\") {\n    const rx = new RegExp(pattern, flags);\n    return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._) `new RegExp(${pattern}, ${flags})`,\n    });\n}\nexports.usePattern = usePattern;\n//# sourceMappingURL=_util.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_util.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/allRequired.js":
/*!************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/allRequired.js ***!
  \************************************************************************************************************************/
/***/ ((module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction getDef() {\n    return {\n        keyword: \"allRequired\",\n        type: \"object\",\n        schemaType: \"boolean\",\n        macro(schema, parentSchema) {\n            if (!schema)\n                return true;\n            const required = Object.keys(parentSchema.properties);\n            if (required.length === 0)\n                return true;\n            return { required };\n        },\n        dependencies: [\"properties\"],\n    };\n}\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=allRequired.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/allRequired.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/anyRequired.js":
/*!************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/anyRequired.js ***!
  \************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _required_1 = __importDefault(__webpack_require__(/*! ./_required */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_required.js\"));\nconst getDef = (0, _required_1.default)(\"anyRequired\");\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=anyRequired.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/anyRequired.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/deepProperties.js":
/*!***************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/deepProperties.js ***!
  \***************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _util_1 = __webpack_require__(/*! ./_util */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_util.js\");\nfunction getDef(opts) {\n    return {\n        keyword: \"deepProperties\",\n        type: \"object\",\n        schemaType: \"object\",\n        macro: function (schema) {\n            const allOf = [];\n            for (const pointer in schema)\n                allOf.push(getSchema(pointer, schema[pointer]));\n            return { allOf };\n        },\n        metaSchema: {\n            type: \"object\",\n            propertyNames: { type: \"string\", format: \"json-pointer\" },\n            additionalProperties: (0, _util_1.metaSchemaRef)(opts),\n        },\n    };\n}\nexports[\"default\"] = getDef;\nfunction getSchema(jsonPointer, schema) {\n    const segments = jsonPointer.split(\"/\");\n    const rootSchema = {};\n    let pointerSchema = rootSchema;\n    for (let i = 1; i < segments.length; i++) {\n        let segment = segments[i];\n        const isLast = i === segments.length - 1;\n        segment = unescapeJsonPointer(segment);\n        const properties = (pointerSchema.properties = {});\n        let items;\n        if (/[0-9]+/.test(segment)) {\n            let count = +segment;\n            items = pointerSchema.items = [];\n            pointerSchema.type = [\"object\", \"array\"];\n            while (count--)\n                items.push({});\n        }\n        else {\n            pointerSchema.type = \"object\";\n        }\n        pointerSchema = isLast ? schema : {};\n        properties[segment] = pointerSchema;\n        if (items)\n            items.push(pointerSchema);\n    }\n    return rootSchema;\n}\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nmodule.exports = getDef;\n//# sourceMappingURL=deepProperties.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/deepProperties.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/deepRequired.js":
/*!*************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/deepRequired.js ***!
  \*************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nfunction getDef() {\n    return {\n        keyword: \"deepRequired\",\n        type: \"object\",\n        schemaType: \"array\",\n        code(ctx) {\n            const { schema, data } = ctx;\n            const props = schema.map((jp) => (0, codegen_1._) `(${getData(jp)}) === undefined`);\n            ctx.fail((0, codegen_1.or)(...props));\n            function getData(jsonPointer) {\n                if (jsonPointer === \"\")\n                    throw new Error(\"empty JSON pointer not allowed\");\n                const segments = jsonPointer.split(\"/\");\n                let x = data;\n                const xs = segments.map((s, i) => i ? (x = (0, codegen_1._) `${x}${(0, codegen_1.getProperty)(unescapeJPSegment(s))}`) : x);\n                return (0, codegen_1.and)(...xs);\n            }\n        },\n        metaSchema: {\n            type: \"array\",\n            items: { type: \"string\", format: \"json-pointer\" },\n        },\n    };\n}\nexports[\"default\"] = getDef;\nfunction unescapeJPSegment(s) {\n    return s.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nmodule.exports = getDef;\n//# sourceMappingURL=deepRequired.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/deepRequired.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/dynamicDefaults.js":
/*!****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/dynamicDefaults.js ***!
  \****************************************************************************************************************************/
/***/ ((module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst sequences = {};\nconst DEFAULTS = {\n    timestamp: () => () => Date.now(),\n    datetime: () => () => new Date().toISOString(),\n    date: () => () => new Date().toISOString().slice(0, 10),\n    time: () => () => new Date().toISOString().slice(11),\n    random: () => () => Math.random(),\n    randomint: (args) => {\n        var _a;\n        const max = (_a = args === null || args === void 0 ? void 0 : args.max) !== null && _a !== void 0 ? _a : 2;\n        return () => Math.floor(Math.random() * max);\n    },\n    seq: (args) => {\n        var _a;\n        const name = (_a = args === null || args === void 0 ? void 0 : args.name) !== null && _a !== void 0 ? _a : \"\";\n        sequences[name] || (sequences[name] = 0);\n        return () => sequences[name]++;\n    },\n};\nconst getDef = Object.assign(_getDef, { DEFAULTS });\nfunction _getDef() {\n    return {\n        keyword: \"dynamicDefaults\",\n        type: \"object\",\n        schemaType: [\"string\", \"object\"],\n        modifying: true,\n        valid: true,\n        compile(schema, _parentSchema, it) {\n            if (!it.opts.useDefaults || it.compositeRule)\n                return () => true;\n            const fs = {};\n            for (const key in schema)\n                fs[key] = getDefault(schema[key]);\n            const empty = it.opts.useDefaults === \"empty\";\n            return (data) => {\n                for (const prop in schema) {\n                    if (data[prop] === undefined || (empty && (data[prop] === null || data[prop] === \"\"))) {\n                        data[prop] = fs[prop]();\n                    }\n                }\n                return true;\n            };\n        },\n        metaSchema: {\n            type: \"object\",\n            additionalProperties: {\n                anyOf: [\n                    { type: \"string\" },\n                    {\n                        type: \"object\",\n                        additionalProperties: false,\n                        required: [\"func\", \"args\"],\n                        properties: {\n                            func: { type: \"string\" },\n                            args: { type: \"object\" },\n                        },\n                    },\n                ],\n            },\n        },\n    };\n}\nfunction getDefault(d) {\n    return typeof d == \"object\" ? getObjDefault(d) : getStrDefault(d);\n}\nfunction getObjDefault({ func, args }) {\n    const def = DEFAULTS[func];\n    assertDefined(func, def);\n    return def(args);\n}\nfunction getStrDefault(d = \"\") {\n    const def = DEFAULTS[d];\n    assertDefined(d, def);\n    return def();\n}\nfunction assertDefined(name, def) {\n    if (!def)\n        throw new Error(`invalid \"dynamicDefaults\" keyword property value: ${name}`);\n}\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=dynamicDefaults.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/dynamicDefaults.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/exclusiveRange.js":
/*!***************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/exclusiveRange.js ***!
  \***************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _range_1 = __importDefault(__webpack_require__(/*! ./_range */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_range.js\"));\nconst getDef = (0, _range_1.default)(\"exclusiveRange\");\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=exclusiveRange.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/exclusiveRange.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/instanceof.js":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/instanceof.js ***!
  \***********************************************************************************************************************/
/***/ ((module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst CONSTRUCTORS = {\n    Object,\n    Array,\n    Function,\n    Number,\n    String,\n    Date,\n    RegExp,\n};\n/* istanbul ignore else */\nif (typeof Buffer != \"undefined\")\n    CONSTRUCTORS.Buffer = Buffer;\n/* istanbul ignore else */\nif (typeof Promise != \"undefined\")\n    CONSTRUCTORS.Promise = Promise;\nconst getDef = Object.assign(_getDef, { CONSTRUCTORS });\nfunction _getDef() {\n    return {\n        keyword: \"instanceof\",\n        schemaType: [\"string\", \"array\"],\n        compile(schema) {\n            if (typeof schema == \"string\") {\n                const C = getConstructor(schema);\n                return (data) => data instanceof C;\n            }\n            if (Array.isArray(schema)) {\n                const constructors = schema.map(getConstructor);\n                return (data) => {\n                    for (const C of constructors) {\n                        if (data instanceof C)\n                            return true;\n                    }\n                    return false;\n                };\n            }\n            /* istanbul ignore next */\n            throw new Error(\"ajv implementation error\");\n        },\n        metaSchema: {\n            anyOf: [{ type: \"string\" }, { type: \"array\", items: { type: \"string\" } }],\n        },\n    };\n}\nfunction getConstructor(c) {\n    const C = CONSTRUCTORS[c];\n    if (C)\n        return C;\n    throw new Error(`invalid \"instanceof\" keyword value ${c}`);\n}\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=instanceof.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/instanceof.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/oneRequired.js":
/*!************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/oneRequired.js ***!
  \************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _required_1 = __importDefault(__webpack_require__(/*! ./_required */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_required.js\"));\nconst getDef = (0, _required_1.default)(\"oneRequired\");\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=oneRequired.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/oneRequired.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/patternRequired.js":
/*!****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/patternRequired.js ***!
  \****************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst _util_1 = __webpack_require__(/*! ./_util */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_util.js\");\nconst error = {\n    message: ({ params: { missingPattern } }) => (0, codegen_1.str) `should have property matching pattern '${missingPattern}'`,\n    params: ({ params: { missingPattern } }) => (0, codegen_1._) `{missingPattern: ${missingPattern}}`,\n};\nfunction getDef() {\n    return {\n        keyword: \"patternRequired\",\n        type: \"object\",\n        schemaType: \"array\",\n        error,\n        code(cxt) {\n            const { gen, schema, data } = cxt;\n            if (schema.length === 0)\n                return;\n            const valid = gen.let(\"valid\", true);\n            for (const pat of schema)\n                validateProperties(pat);\n            function validateProperties(pattern) {\n                const matched = gen.let(\"matched\", false);\n                gen.forIn(\"key\", data, (key) => {\n                    gen.assign(matched, (0, codegen_1._) `${(0, _util_1.usePattern)(cxt, pattern)}.test(${key})`);\n                    gen.if(matched, () => gen.break());\n                });\n                cxt.setParams({ missingPattern: pattern });\n                gen.assign(valid, (0, codegen_1.and)(valid, matched));\n                cxt.pass(valid);\n            }\n        },\n        metaSchema: {\n            type: \"array\",\n            items: { type: \"string\", format: \"regex\" },\n            uniqueItems: true,\n        },\n    };\n}\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=patternRequired.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/patternRequired.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/prohibited.js":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/prohibited.js ***!
  \***********************************************************************************************************************/
/***/ ((module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction getDef() {\n    return {\n        keyword: \"prohibited\",\n        type: \"object\",\n        schemaType: \"array\",\n        macro: function (schema) {\n            if (schema.length === 0)\n                return true;\n            if (schema.length === 1)\n                return { not: { required: schema } };\n            return { not: { anyOf: schema.map((p) => ({ required: [p] })) } };\n        },\n        metaSchema: {\n            type: \"array\",\n            items: { type: \"string\" },\n        },\n    };\n}\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=prohibited.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/prohibited.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/range.js":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/range.js ***!
  \******************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _range_1 = __importDefault(__webpack_require__(/*! ./_range */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_range.js\"));\nconst getDef = (0, _range_1.default)(\"range\");\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=range.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/range.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/regexp.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/regexp.js ***!
  \*******************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst _util_1 = __webpack_require__(/*! ./_util */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_util.js\");\nconst regexpMetaSchema = {\n    type: \"object\",\n    properties: {\n        pattern: { type: \"string\" },\n        flags: { type: \"string\", nullable: true },\n    },\n    required: [\"pattern\"],\n    additionalProperties: false,\n};\nconst metaRegexp = /^\\/(.*)\\/([gimuy]*)$/;\nfunction getDef() {\n    return {\n        keyword: \"regexp\",\n        type: \"string\",\n        schemaType: [\"string\", \"object\"],\n        code(cxt) {\n            const { data, schema } = cxt;\n            const regx = getRegExp(schema);\n            cxt.pass((0, codegen_1._) `${regx}.test(${data})`);\n            function getRegExp(sch) {\n                if (typeof sch == \"object\")\n                    return (0, _util_1.usePattern)(cxt, sch.pattern, sch.flags);\n                const rx = metaRegexp.exec(sch);\n                if (rx)\n                    return (0, _util_1.usePattern)(cxt, rx[1], rx[2]);\n                throw new Error(\"cannot parse string into RegExp\");\n            }\n        },\n        metaSchema: {\n            anyOf: [{ type: \"string\" }, regexpMetaSchema],\n        },\n    };\n}\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=regexp.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/regexp.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/select.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/select.js ***!
  \*******************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst _util_1 = __webpack_require__(/*! ./_util */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/_util.js\");\nconst error = {\n    message: ({ params: { schemaProp } }) => schemaProp\n        ? (0, codegen_1.str) `should match case \"${schemaProp}\" schema`\n        : (0, codegen_1.str) `should match default case schema`,\n    params: ({ params: { schemaProp } }) => schemaProp ? (0, codegen_1._) `{failingCase: ${schemaProp}}` : (0, codegen_1._) `{failingDefault: true}`,\n};\nfunction getDef(opts) {\n    const metaSchema = (0, _util_1.metaSchemaRef)(opts);\n    return [\n        {\n            keyword: \"select\",\n            schemaType: [\"string\", \"number\", \"boolean\", \"null\"],\n            $data: true,\n            error,\n            dependencies: [\"selectCases\"],\n            code(cxt) {\n                const { gen, schemaCode, parentSchema } = cxt;\n                cxt.block$data(codegen_1.nil, () => {\n                    const valid = gen.let(\"valid\", true);\n                    const schValid = gen.name(\"_valid\");\n                    const value = gen.const(\"value\", (0, codegen_1._) `${schemaCode} === null ? \"null\" : ${schemaCode}`);\n                    gen.if(false); // optimizer should remove it from generated code\n                    for (const schemaProp in parentSchema.selectCases) {\n                        cxt.setParams({ schemaProp });\n                        gen.elseIf((0, codegen_1._) `\"\" + ${value} == ${schemaProp}`); // intentional ==, to match numbers and booleans\n                        const schCxt = cxt.subschema({ keyword: \"selectCases\", schemaProp }, schValid);\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                        gen.assign(valid, schValid);\n                    }\n                    gen.else();\n                    if (parentSchema.selectDefault !== undefined) {\n                        cxt.setParams({ schemaProp: undefined });\n                        const schCxt = cxt.subschema({ keyword: \"selectDefault\" }, schValid);\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                        gen.assign(valid, schValid);\n                    }\n                    gen.endIf();\n                    cxt.pass(valid);\n                });\n            },\n        },\n        {\n            keyword: \"selectCases\",\n            dependencies: [\"select\"],\n            metaSchema: {\n                type: \"object\",\n                additionalProperties: metaSchema,\n            },\n        },\n        {\n            keyword: \"selectDefault\",\n            dependencies: [\"select\", \"selectCases\"],\n            metaSchema,\n        },\n    ];\n}\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=select.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/select.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/transform.js":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/transform.js ***!
  \**********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst transform = {\n    trimStart: (s) => s.trimStart(),\n    trimEnd: (s) => s.trimEnd(),\n    trimLeft: (s) => s.trimStart(),\n    trimRight: (s) => s.trimEnd(),\n    trim: (s) => s.trim(),\n    toLowerCase: (s) => s.toLowerCase(),\n    toUpperCase: (s) => s.toUpperCase(),\n    toEnumCase: (s, cfg) => (cfg === null || cfg === void 0 ? void 0 : cfg.hash[configKey(s)]) || s,\n};\nconst getDef = Object.assign(_getDef, { transform });\nfunction _getDef() {\n    return {\n        keyword: \"transform\",\n        schemaType: \"array\",\n        before: \"enum\",\n        code(cxt) {\n            const { gen, data, schema, parentSchema, it } = cxt;\n            const { parentData, parentDataProperty } = it;\n            const tNames = schema;\n            if (!tNames.length)\n                return;\n            let cfg;\n            if (tNames.includes(\"toEnumCase\")) {\n                const config = getEnumCaseCfg(parentSchema);\n                cfg = gen.scopeValue(\"obj\", { ref: config, code: (0, codegen_1.stringify)(config) });\n            }\n            gen.if((0, codegen_1._) `typeof ${data} == \"string\" && ${parentData} !== undefined`, () => {\n                gen.assign(data, transformExpr(tNames.slice()));\n                gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, data);\n            });\n            function transformExpr(ts) {\n                if (!ts.length)\n                    return data;\n                const t = ts.pop();\n                if (!(t in transform))\n                    throw new Error(`transform: unknown transformation ${t}`);\n                const func = gen.scopeValue(\"func\", {\n                    ref: transform[t],\n                    code: (0, codegen_1._) `require(\"ajv-keywords/dist/definitions/transform\").transform${(0, codegen_1.getProperty)(t)}`,\n                });\n                const arg = transformExpr(ts);\n                return cfg && t === \"toEnumCase\" ? (0, codegen_1._) `${func}(${arg}, ${cfg})` : (0, codegen_1._) `${func}(${arg})`;\n            }\n        },\n        metaSchema: {\n            type: \"array\",\n            items: { type: \"string\", enum: Object.keys(transform) },\n        },\n    };\n}\nfunction getEnumCaseCfg(parentSchema) {\n    // build hash table to enum values\n    const cfg = { hash: {} };\n    // requires `enum` in the same schema as transform\n    if (!parentSchema.enum)\n        throw new Error('transform: \"toEnumCase\" requires \"enum\"');\n    for (const v of parentSchema.enum) {\n        if (typeof v !== \"string\")\n            continue;\n        const k = configKey(v);\n        // requires all `enum` values have unique keys\n        if (cfg.hash[k]) {\n            throw new Error('transform: \"toEnumCase\" requires all lowercased \"enum\" values to be unique');\n        }\n        cfg.hash[k] = v;\n    }\n    return cfg;\n}\nfunction configKey(s) {\n    return s.toLowerCase();\n}\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=transform.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/transform.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/typeof.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/typeof.js ***!
  \*******************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst TYPES = [\"undefined\", \"string\", \"number\", \"object\", \"function\", \"boolean\", \"symbol\"];\nfunction getDef() {\n    return {\n        keyword: \"typeof\",\n        schemaType: [\"string\", \"array\"],\n        code(cxt) {\n            const { data, schema, schemaValue } = cxt;\n            cxt.fail(typeof schema == \"string\"\n                ? (0, codegen_1._) `typeof ${data} != ${schema}`\n                : (0, codegen_1._) `${schemaValue}.indexOf(typeof ${data}) < 0`);\n        },\n        metaSchema: {\n            anyOf: [\n                { type: \"string\", enum: TYPES },\n                { type: \"array\", items: { type: \"string\", enum: TYPES } },\n            ],\n        },\n    };\n}\nexports[\"default\"] = getDef;\nmodule.exports = getDef;\n//# sourceMappingURL=typeof.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/typeof.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/uniqueItemProperties.js":
/*!*********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/uniqueItemProperties.js ***!
  \*********************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst equal = __webpack_require__(/*! fast-deep-equal */ \"../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js\");\nconst SCALAR_TYPES = [\"number\", \"integer\", \"string\", \"boolean\", \"null\"];\nfunction getDef() {\n    return {\n        keyword: \"uniqueItemProperties\",\n        type: \"array\",\n        schemaType: \"array\",\n        compile(keys, parentSchema) {\n            const scalar = getScalarKeys(keys, parentSchema);\n            return (data) => {\n                if (data.length <= 1)\n                    return true;\n                for (let k = 0; k < keys.length; k++) {\n                    const key = keys[k];\n                    if (scalar[k]) {\n                        const hash = {};\n                        for (const x of data) {\n                            if (!x || typeof x != \"object\")\n                                continue;\n                            let p = x[key];\n                            if (p && typeof p == \"object\")\n                                continue;\n                            if (typeof p == \"string\")\n                                p = '\"' + p;\n                            if (hash[p])\n                                return false;\n                            hash[p] = true;\n                        }\n                    }\n                    else {\n                        for (let i = data.length; i--;) {\n                            const x = data[i];\n                            if (!x || typeof x != \"object\")\n                                continue;\n                            for (let j = i; j--;) {\n                                const y = data[j];\n                                if (y && typeof y == \"object\" && equal(x[key], y[key]))\n                                    return false;\n                            }\n                        }\n                    }\n                }\n                return true;\n            };\n        },\n        metaSchema: {\n            type: \"array\",\n            items: { type: \"string\" },\n        },\n    };\n}\nexports[\"default\"] = getDef;\nfunction getScalarKeys(keys, schema) {\n    return keys.map((key) => {\n        var _a, _b, _c;\n        const t = (_c = (_b = (_a = schema.items) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b[key]) === null || _c === void 0 ? void 0 : _c.type;\n        return Array.isArray(t)\n            ? !t.includes(\"object\") && !t.includes(\"array\")\n            : SCALAR_TYPES.includes(t);\n    });\n}\nmodule.exports = getDef;\n//# sourceMappingURL=uniqueItemProperties.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/uniqueItemProperties.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/index.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/index.js ***!
  \******************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst keywords_1 = __importDefault(__webpack_require__(/*! ./keywords */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/index.js\"));\nconst ajvKeywords = (ajv, keyword) => {\n    if (Array.isArray(keyword)) {\n        for (const k of keyword)\n            get(k)(ajv);\n        return ajv;\n    }\n    if (keyword) {\n        get(keyword)(ajv);\n        return ajv;\n    }\n    for (keyword in keywords_1.default)\n        get(keyword)(ajv);\n    return ajv;\n};\najvKeywords.get = get;\nfunction get(keyword) {\n    const defFunc = keywords_1.default[keyword];\n    if (!defFunc)\n        throw new Error(\"Unknown keyword \" + keyword);\n    return defFunc;\n}\nexports[\"default\"] = ajvKeywords;\nmodule.exports = ajvKeywords;\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nmodule.exports[\"default\"] = ajvKeywords;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/allRequired.js":
/*!*********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/allRequired.js ***!
  \*********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst allRequired_1 = __importDefault(__webpack_require__(/*! ../definitions/allRequired */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/allRequired.js\"));\nconst allRequired = (ajv) => ajv.addKeyword((0, allRequired_1.default)());\nexports[\"default\"] = allRequired;\nmodule.exports = allRequired;\n//# sourceMappingURL=allRequired.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/allRequired.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/anyRequired.js":
/*!*********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/anyRequired.js ***!
  \*********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst anyRequired_1 = __importDefault(__webpack_require__(/*! ../definitions/anyRequired */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/anyRequired.js\"));\nconst anyRequired = (ajv) => ajv.addKeyword((0, anyRequired_1.default)());\nexports[\"default\"] = anyRequired;\nmodule.exports = anyRequired;\n//# sourceMappingURL=anyRequired.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/anyRequired.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/deepProperties.js":
/*!************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/deepProperties.js ***!
  \************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst deepProperties_1 = __importDefault(__webpack_require__(/*! ../definitions/deepProperties */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/deepProperties.js\"));\nconst deepProperties = (ajv, opts) => ajv.addKeyword((0, deepProperties_1.default)(opts));\nexports[\"default\"] = deepProperties;\nmodule.exports = deepProperties;\n//# sourceMappingURL=deepProperties.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/deepProperties.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/deepRequired.js":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/deepRequired.js ***!
  \**********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst deepRequired_1 = __importDefault(__webpack_require__(/*! ../definitions/deepRequired */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/deepRequired.js\"));\nconst deepRequired = (ajv) => ajv.addKeyword((0, deepRequired_1.default)());\nexports[\"default\"] = deepRequired;\nmodule.exports = deepRequired;\n//# sourceMappingURL=deepRequired.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/deepRequired.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/dynamicDefaults.js":
/*!*************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/dynamicDefaults.js ***!
  \*************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst dynamicDefaults_1 = __importDefault(__webpack_require__(/*! ../definitions/dynamicDefaults */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/dynamicDefaults.js\"));\nconst dynamicDefaults = (ajv) => ajv.addKeyword((0, dynamicDefaults_1.default)());\nexports[\"default\"] = dynamicDefaults;\nmodule.exports = dynamicDefaults;\n//# sourceMappingURL=dynamicDefaults.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/dynamicDefaults.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/exclusiveRange.js":
/*!************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/exclusiveRange.js ***!
  \************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst exclusiveRange_1 = __importDefault(__webpack_require__(/*! ../definitions/exclusiveRange */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/exclusiveRange.js\"));\nconst exclusiveRange = (ajv) => ajv.addKeyword((0, exclusiveRange_1.default)());\nexports[\"default\"] = exclusiveRange;\nmodule.exports = exclusiveRange;\n//# sourceMappingURL=exclusiveRange.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/exclusiveRange.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/index.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/index.js ***!
  \***************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeof_1 = __importDefault(__webpack_require__(/*! ./typeof */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/typeof.js\"));\nconst instanceof_1 = __importDefault(__webpack_require__(/*! ./instanceof */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/instanceof.js\"));\nconst range_1 = __importDefault(__webpack_require__(/*! ./range */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/range.js\"));\nconst exclusiveRange_1 = __importDefault(__webpack_require__(/*! ./exclusiveRange */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/exclusiveRange.js\"));\nconst regexp_1 = __importDefault(__webpack_require__(/*! ./regexp */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/regexp.js\"));\nconst transform_1 = __importDefault(__webpack_require__(/*! ./transform */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/transform.js\"));\nconst uniqueItemProperties_1 = __importDefault(__webpack_require__(/*! ./uniqueItemProperties */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/uniqueItemProperties.js\"));\nconst allRequired_1 = __importDefault(__webpack_require__(/*! ./allRequired */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/allRequired.js\"));\nconst anyRequired_1 = __importDefault(__webpack_require__(/*! ./anyRequired */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/anyRequired.js\"));\nconst oneRequired_1 = __importDefault(__webpack_require__(/*! ./oneRequired */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/oneRequired.js\"));\nconst patternRequired_1 = __importDefault(__webpack_require__(/*! ./patternRequired */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/patternRequired.js\"));\nconst prohibited_1 = __importDefault(__webpack_require__(/*! ./prohibited */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/prohibited.js\"));\nconst deepProperties_1 = __importDefault(__webpack_require__(/*! ./deepProperties */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/deepProperties.js\"));\nconst deepRequired_1 = __importDefault(__webpack_require__(/*! ./deepRequired */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/deepRequired.js\"));\nconst dynamicDefaults_1 = __importDefault(__webpack_require__(/*! ./dynamicDefaults */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/dynamicDefaults.js\"));\nconst select_1 = __importDefault(__webpack_require__(/*! ./select */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/select.js\"));\n// TODO type\nconst ajvKeywords = {\n    typeof: typeof_1.default,\n    instanceof: instanceof_1.default,\n    range: range_1.default,\n    exclusiveRange: exclusiveRange_1.default,\n    regexp: regexp_1.default,\n    transform: transform_1.default,\n    uniqueItemProperties: uniqueItemProperties_1.default,\n    allRequired: allRequired_1.default,\n    anyRequired: anyRequired_1.default,\n    oneRequired: oneRequired_1.default,\n    patternRequired: patternRequired_1.default,\n    prohibited: prohibited_1.default,\n    deepProperties: deepProperties_1.default,\n    deepRequired: deepRequired_1.default,\n    dynamicDefaults: dynamicDefaults_1.default,\n    select: select_1.default,\n};\nexports[\"default\"] = ajvKeywords;\nmodule.exports = ajvKeywords;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/instanceof.js":
/*!********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/instanceof.js ***!
  \********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst instanceof_1 = __importDefault(__webpack_require__(/*! ../definitions/instanceof */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/instanceof.js\"));\nconst instanceofPlugin = (ajv) => ajv.addKeyword((0, instanceof_1.default)());\nexports[\"default\"] = instanceofPlugin;\nmodule.exports = instanceofPlugin;\n//# sourceMappingURL=instanceof.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/instanceof.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/oneRequired.js":
/*!*********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/oneRequired.js ***!
  \*********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst oneRequired_1 = __importDefault(__webpack_require__(/*! ../definitions/oneRequired */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/oneRequired.js\"));\nconst oneRequired = (ajv) => ajv.addKeyword((0, oneRequired_1.default)());\nexports[\"default\"] = oneRequired;\nmodule.exports = oneRequired;\n//# sourceMappingURL=oneRequired.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/oneRequired.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/patternRequired.js":
/*!*************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/patternRequired.js ***!
  \*************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst patternRequired_1 = __importDefault(__webpack_require__(/*! ../definitions/patternRequired */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/patternRequired.js\"));\nconst patternRequired = (ajv) => ajv.addKeyword((0, patternRequired_1.default)());\nexports[\"default\"] = patternRequired;\nmodule.exports = patternRequired;\n//# sourceMappingURL=patternRequired.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/patternRequired.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/prohibited.js":
/*!********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/prohibited.js ***!
  \********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst prohibited_1 = __importDefault(__webpack_require__(/*! ../definitions/prohibited */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/prohibited.js\"));\nconst prohibited = (ajv) => ajv.addKeyword((0, prohibited_1.default)());\nexports[\"default\"] = prohibited;\nmodule.exports = prohibited;\n//# sourceMappingURL=prohibited.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/prohibited.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/range.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/range.js ***!
  \***************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst range_1 = __importDefault(__webpack_require__(/*! ../definitions/range */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/range.js\"));\nconst range = (ajv) => ajv.addKeyword((0, range_1.default)());\nexports[\"default\"] = range;\nmodule.exports = range;\n//# sourceMappingURL=range.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/range.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/regexp.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/regexp.js ***!
  \****************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst regexp_1 = __importDefault(__webpack_require__(/*! ../definitions/regexp */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/regexp.js\"));\nconst regexp = (ajv) => ajv.addKeyword((0, regexp_1.default)());\nexports[\"default\"] = regexp;\nmodule.exports = regexp;\n//# sourceMappingURL=regexp.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/regexp.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/select.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/select.js ***!
  \****************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst select_1 = __importDefault(__webpack_require__(/*! ../definitions/select */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/select.js\"));\nconst select = (ajv, opts) => {\n    (0, select_1.default)(opts).forEach((d) => ajv.addKeyword(d));\n    return ajv;\n};\nexports[\"default\"] = select;\nmodule.exports = select;\n//# sourceMappingURL=select.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/select.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/transform.js":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/transform.js ***!
  \*******************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst transform_1 = __importDefault(__webpack_require__(/*! ../definitions/transform */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/transform.js\"));\nconst transform = (ajv) => ajv.addKeyword((0, transform_1.default)());\nexports[\"default\"] = transform;\nmodule.exports = transform;\n//# sourceMappingURL=transform.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/transform.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/typeof.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/typeof.js ***!
  \****************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeof_1 = __importDefault(__webpack_require__(/*! ../definitions/typeof */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/typeof.js\"));\nconst typeofPlugin = (ajv) => ajv.addKeyword((0, typeof_1.default)());\nexports[\"default\"] = typeofPlugin;\nmodule.exports = typeofPlugin;\n//# sourceMappingURL=typeof.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/typeof.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/uniqueItemProperties.js":
/*!******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/uniqueItemProperties.js ***!
  \******************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst uniqueItemProperties_1 = __importDefault(__webpack_require__(/*! ../definitions/uniqueItemProperties */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/definitions/uniqueItemProperties.js\"));\nconst uniqueItemProperties = (ajv) => ajv.addKeyword((0, uniqueItemProperties_1.default)());\nexports[\"default\"] = uniqueItemProperties;\nmodule.exports = uniqueItemProperties;\n//# sourceMappingURL=uniqueItemProperties.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/keywords/uniqueItemProperties.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js":
/*!************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;\nconst core_1 = __webpack_require__(/*! ./core */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js\");\nconst draft7_1 = __webpack_require__(/*! ./vocabularies/draft7 */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js\");\nconst discriminator_1 = __webpack_require__(/*! ./vocabularies/discriminator */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js\");\nconst draft7MetaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json\");\nconst META_SUPPORT_DATA = [\"/properties\"];\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\nclass Ajv extends core_1.default {\n    _addVocabularies() {\n        super._addVocabularies();\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n            this.addKeyword(discriminator_1.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta)\n            return;\n        const metaSchema = this.opts.$data\n            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n            : draft7MetaSchema;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return (this.opts.defaultMeta =\n            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));\n    }\n}\nexports.Ajv = Ajv;\nmodule.exports = exports = Ajv;\nmodule.exports.Ajv = Ajv;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = Ajv;\nvar validate_1 = __webpack_require__(/*! ./compile/validate */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js\");\nObject.defineProperty(exports, \"KeywordCxt\", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));\nvar codegen_1 = __webpack_require__(/*! ./compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return codegen_1._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return codegen_1.str; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return codegen_1.nil; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return codegen_1.Name; } }));\nObject.defineProperty(exports, \"CodeGen\", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));\nvar validation_error_1 = __webpack_require__(/*! ./runtime/validation_error */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js\");\nObject.defineProperty(exports, \"ValidationError\", ({ enumerable: true, get: function () { return validation_error_1.default; } }));\nvar ref_error_1 = __webpack_require__(/*! ./compile/ref_error */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js\");\nObject.defineProperty(exports, \"MissingRefError\", ({ enumerable: true, get: function () { return ref_error_1.default; } }));\n//# sourceMappingURL=ajv.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass _CodeOrName {\n}\nexports._CodeOrName = _CodeOrName;\nexports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass Name extends _CodeOrName {\n    constructor(s) {\n        super();\n        if (!exports.IDENTIFIER.test(s))\n            throw new Error(\"CodeGen: name must be a valid identifier\");\n        this.str = s;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        return false;\n    }\n    get names() {\n        return { [this.str]: 1 };\n    }\n}\nexports.Name = Name;\nclass _Code extends _CodeOrName {\n    constructor(code) {\n        super();\n        this._items = typeof code === \"string\" ? [code] : code;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        if (this._items.length > 1)\n            return false;\n        const item = this._items[0];\n        return item === \"\" || item === '\"\"';\n    }\n    get str() {\n        var _a;\n        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, \"\")));\n    }\n    get names() {\n        var _a;\n        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {\n            if (c instanceof Name)\n                names[c.str] = (names[c.str] || 0) + 1;\n            return names;\n        }, {})));\n    }\n}\nexports._Code = _Code;\nexports.nil = new _Code(\"\");\nfunction _(strs, ...args) {\n    const code = [strs[0]];\n    let i = 0;\n    while (i < args.length) {\n        addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n    }\n    return new _Code(code);\n}\nexports._ = _;\nconst plus = new _Code(\"+\");\nfunction str(strs, ...args) {\n    const expr = [safeStringify(strs[0])];\n    let i = 0;\n    while (i < args.length) {\n        expr.push(plus);\n        addCodeArg(expr, args[i]);\n        expr.push(plus, safeStringify(strs[++i]));\n    }\n    optimize(expr);\n    return new _Code(expr);\n}\nexports.str = str;\nfunction addCodeArg(code, arg) {\n    if (arg instanceof _Code)\n        code.push(...arg._items);\n    else if (arg instanceof Name)\n        code.push(arg);\n    else\n        code.push(interpolate(arg));\n}\nexports.addCodeArg = addCodeArg;\nfunction optimize(expr) {\n    let i = 1;\n    while (i < expr.length - 1) {\n        if (expr[i] === plus) {\n            const res = mergeExprItems(expr[i - 1], expr[i + 1]);\n            if (res !== undefined) {\n                expr.splice(i - 1, 3, res);\n                continue;\n            }\n            expr[i++] = \"+\";\n        }\n        i++;\n    }\n}\nfunction mergeExprItems(a, b) {\n    if (b === '\"\"')\n        return a;\n    if (a === '\"\"')\n        return b;\n    if (typeof a == \"string\") {\n        if (b instanceof Name || a[a.length - 1] !== '\"')\n            return;\n        if (typeof b != \"string\")\n            return `${a.slice(0, -1)}${b}\"`;\n        if (b[0] === '\"')\n            return a.slice(0, -1) + b.slice(1);\n        return;\n    }\n    if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name))\n        return `\"${a}${b.slice(1)}`;\n    return;\n}\nfunction strConcat(c1, c2) {\n    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;\n}\nexports.strConcat = strConcat;\n// TODO do not allow arrays here\nfunction interpolate(x) {\n    return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n        ? x\n        : safeStringify(Array.isArray(x) ? x.join(\",\") : x);\n}\nfunction stringify(x) {\n    return new _Code(safeStringify(x));\n}\nexports.stringify = stringify;\nfunction safeStringify(x) {\n    return JSON.stringify(x)\n        .replace(/\\u2028/g, \"\\\\u2028\")\n        .replace(/\\u2029/g, \"\\\\u2029\");\n}\nexports.safeStringify = safeStringify;\nfunction getProperty(key) {\n    return typeof key == \"string\" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;\n}\nexports.getProperty = getProperty;\n//Does best effort to format the name properly\nfunction getEsmExportName(key) {\n    if (typeof key == \"string\" && exports.IDENTIFIER.test(key)) {\n        return new _Code(`${key}`);\n    }\n    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n}\nexports.getEsmExportName = getEsmExportName;\nfunction regexpCode(rx) {\n    return new _Code(rx.toString());\n}\nexports.regexpCode = regexpCode;\n//# sourceMappingURL=code.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\nconst code_1 = __webpack_require__(/*! ./code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js\");\nconst scope_1 = __webpack_require__(/*! ./scope */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js\");\nvar code_2 = __webpack_require__(/*! ./code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return code_2._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return code_2.str; } }));\nObject.defineProperty(exports, \"strConcat\", ({ enumerable: true, get: function () { return code_2.strConcat; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return code_2.nil; } }));\nObject.defineProperty(exports, \"getProperty\", ({ enumerable: true, get: function () { return code_2.getProperty; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return code_2.stringify; } }));\nObject.defineProperty(exports, \"regexpCode\", ({ enumerable: true, get: function () { return code_2.regexpCode; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return code_2.Name; } }));\nvar scope_2 = __webpack_require__(/*! ./scope */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js\");\nObject.defineProperty(exports, \"Scope\", ({ enumerable: true, get: function () { return scope_2.Scope; } }));\nObject.defineProperty(exports, \"ValueScope\", ({ enumerable: true, get: function () { return scope_2.ValueScope; } }));\nObject.defineProperty(exports, \"ValueScopeName\", ({ enumerable: true, get: function () { return scope_2.ValueScopeName; } }));\nObject.defineProperty(exports, \"varKinds\", ({ enumerable: true, get: function () { return scope_2.varKinds; } }));\nexports.operators = {\n    GT: new code_1._Code(\">\"),\n    GTE: new code_1._Code(\">=\"),\n    LT: new code_1._Code(\"<\"),\n    LTE: new code_1._Code(\"<=\"),\n    EQ: new code_1._Code(\"===\"),\n    NEQ: new code_1._Code(\"!==\"),\n    NOT: new code_1._Code(\"!\"),\n    OR: new code_1._Code(\"||\"),\n    AND: new code_1._Code(\"&&\"),\n    ADD: new code_1._Code(\"+\"),\n};\nclass Node {\n    optimizeNodes() {\n        return this;\n    }\n    optimizeNames(_names, _constants) {\n        return this;\n    }\n}\nclass Def extends Node {\n    constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n    }\n    render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (!names[this.name.str])\n            return;\n        if (this.rhs)\n            this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n    }\n}\nclass Assign extends Node {\n    constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n    }\n    render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n            return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n    }\n}\nclass AssignOp extends Assign {\n    constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n    }\n    render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n    }\n}\nclass Label extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        return `${this.label}:` + _n;\n    }\n}\nclass Break extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n    }\n}\nclass Throw extends Node {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render({ _n }) {\n        return `throw ${this.error};` + _n;\n    }\n    get names() {\n        return this.error.names;\n    }\n}\nclass AnyCode extends Node {\n    constructor(code) {\n        super();\n        this.code = code;\n    }\n    render({ _n }) {\n        return `${this.code};` + _n;\n    }\n    optimizeNodes() {\n        return `${this.code}` ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n    }\n    get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n    }\n}\nclass ParentNode extends Node {\n    constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n    }\n    render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n    }\n    optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            const n = nodes[i].optimizeNodes();\n            if (Array.isArray(n))\n                nodes.splice(i, 1, ...n);\n            else if (n)\n                nodes[i] = n;\n            else\n                nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            // iterating backwards improves 1-pass optimization\n            const n = nodes[i];\n            if (n.optimizeNames(names, constants))\n                continue;\n            subtractNames(names, n.names);\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n    }\n}\nclass BlockNode extends ParentNode {\n    render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n    }\n}\nclass Root extends ParentNode {\n}\nclass Else extends BlockNode {\n}\nElse.kind = \"else\";\nclass If extends BlockNode {\n    constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n    }\n    render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n            code += \"else \" + this.else.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n            return this.nodes; // else is ignored here\n        let e = this.else;\n        if (e) {\n            const ns = e.optimizeNodes();\n            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n            if (cond === false)\n                return e instanceof If ? e : e.nodes;\n            if (this.nodes.length)\n                return this;\n            return new If(not(cond), e instanceof If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n            return undefined;\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n            return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n            addNames(names, this.else.names);\n        return names;\n    }\n}\nIf.kind = \"if\";\nclass For extends BlockNode {\n}\nFor.kind = \"for\";\nclass ForLoop extends For {\n    constructor(iteration) {\n        super();\n        this.iteration = iteration;\n    }\n    render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iteration.names);\n    }\n}\nclass ForRange extends For {\n    constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n    }\n    render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n    }\n    get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n    }\n}\nclass ForIter extends For {\n    constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n    }\n    render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iterable.names);\n    }\n}\nclass Func extends BlockNode {\n    constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n    }\n    render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n    }\n}\nFunc.kind = \"func\";\nclass Return extends ParentNode {\n    render(opts) {\n        return \"return \" + super.render(opts);\n    }\n}\nReturn.kind = \"return\";\nclass Try extends BlockNode {\n    render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch)\n            code += this.catch.render(opts);\n        if (this.finally)\n            code += this.finally.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        if (this.catch)\n            addNames(names, this.catch.names);\n        if (this.finally)\n            addNames(names, this.finally.names);\n        return names;\n    }\n}\nclass Catch extends BlockNode {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n    }\n}\nCatch.kind = \"catch\";\nclass Finally extends BlockNode {\n    render(opts) {\n        return \"finally\" + super.render(opts);\n    }\n}\nFinally.kind = \"finally\";\nclass CodeGen {\n    constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? \"\\n\" : \"\" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n    }\n    toString() {\n        return this._root.render(this.opts);\n    }\n    // returns unique name in the internal scope\n    name(prefix) {\n        return this._scope.name(prefix);\n    }\n    // reserves unique name in the external scope\n    scopeName(prefix) {\n        return this._extScope.name(prefix);\n    }\n    // reserves unique name in the external scope and assigns value to it\n    scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n        vs.add(name);\n        return name;\n    }\n    getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n    }\n    // return code that assigns values in the external scope to the names that are used internally\n    // (same names that were returned by gen.scopeName or gen.scopeValue)\n    scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n    }\n    scopeCode() {\n        return this._extScope.scopeCode(this._values);\n    }\n    _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== undefined && constant)\n            this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n    }\n    // `const` declaration (`var` in es5 mode)\n    const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n    }\n    // `let` declaration with optional assignment (`var` in es5 mode)\n    let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n    }\n    // `var` declaration with optional assignment\n    var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n    }\n    // assignment code\n    assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n    }\n    // `+=` code\n    add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n    }\n    // appends passed SafeExpr to code or executes Block\n    code(c) {\n        if (typeof c == \"function\")\n            c();\n        else if (c !== code_1.nil)\n            this._leafNode(new AnyCode(c));\n        return this;\n    }\n    // returns code for object literal for the passed argument list of key-value pairs\n    object(...keyValues) {\n        const code = [\"{\"];\n        for (const [key, value] of keyValues) {\n            if (code.length > 1)\n                code.push(\",\");\n            code.push(key);\n            if (key !== value || this.opts.es5) {\n                code.push(\":\");\n                (0, code_1.addCodeArg)(code, value);\n            }\n        }\n        code.push(\"}\");\n        return new code_1._Code(code);\n    }\n    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n    if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n            this.code(thenBody).else().code(elseBody).endIf();\n        }\n        else if (thenBody) {\n            this.code(thenBody).endIf();\n        }\n        else if (elseBody) {\n            throw new Error('CodeGen: \"else\" body without \"then\" body');\n        }\n        return this;\n    }\n    // `else if` clause - invalid without `if` or after `else` clauses\n    elseIf(condition) {\n        return this._elseNode(new If(condition));\n    }\n    // `else` clause - only valid after `if` or `else if` clauses\n    else() {\n        return this._elseNode(new Else());\n    }\n    // end `if` statement (needed if gen.if was used only with condition)\n    endIf() {\n        return this._endBlockNode(If, Else);\n    }\n    _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n            this.code(forBody).endFor();\n        return this;\n    }\n    // a generic `for` clause (or statement if `forBody` is passed)\n    for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n    }\n    // `for` statement for a range of values\n    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n    }\n    // `for-of` statement (in es5 mode replace with a normal for loop)\n    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n            const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n            return this.forRange(\"_i\", 0, (0, code_1._) `${arr}.length`, (i) => {\n                this.var(name, (0, code_1._) `${arr}[${i}]`);\n                forBody(name);\n            });\n        }\n        return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n    }\n    // `for-in` statement.\n    // With option `ownProperties` replaced with a `for-of` loop for object keys\n    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n    }\n    // end `for` loop\n    endFor() {\n        return this._endBlockNode(For);\n    }\n    // `label` statement\n    label(label) {\n        return this._leafNode(new Label(label));\n    }\n    // `break` statement\n    break(label) {\n        return this._leafNode(new Break(label));\n    }\n    // `return` statement\n    return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n            throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode(Return);\n    }\n    // `try` statement\n    try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n            throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n            const error = this.name(\"e\");\n            this._currNode = node.catch = new Catch(error);\n            catchCode(error);\n        }\n        if (finallyCode) {\n            this._currNode = node.finally = new Finally();\n            this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n    }\n    // `throw` statement\n    throw(error) {\n        return this._leafNode(new Throw(error));\n    }\n    // start self-balancing block\n    block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n            this.code(body).endBlock(nodeCount);\n        return this;\n    }\n    // end the current self-balancing block\n    endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === undefined)\n            throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n    }\n    // `function` heading (or definition if funcBody is passed)\n    func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n            this.code(funcBody).endFunc();\n        return this;\n    }\n    // end function definition\n    endFunc() {\n        return this._endBlockNode(Func);\n    }\n    optimize(n = 1) {\n        while (n-- > 0) {\n            this._root.optimizeNodes();\n            this._root.optimizeNames(this._root.names, this._constants);\n        }\n    }\n    _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n    }\n    _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n    }\n    _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || (N2 && n instanceof N2)) {\n            this._nodes.pop();\n            return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n    }\n    _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n            throw new Error('CodeGen: \"else\" without \"if\"');\n        }\n        this._currNode = n.else = node;\n        return this;\n    }\n    get _root() {\n        return this._nodes[0];\n    }\n    get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n    }\n    set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n    }\n}\nexports.CodeGen = CodeGen;\nfunction addNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n    return names;\n}\nfunction addExprNames(names, from) {\n    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\nfunction optimizeExpr(expr, names, constants) {\n    if (expr instanceof code_1.Name)\n        return replaceName(expr);\n    if (!canOptimize(expr))\n        return expr;\n    return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n            c = replaceName(c);\n        if (c instanceof code_1._Code)\n            items.push(...c._items);\n        else\n            items.push(c);\n        return items;\n    }, []));\n    function replaceName(n) {\n        const c = constants[n.str];\n        if (c === undefined || names[n.str] !== 1)\n            return n;\n        delete names[n.str];\n        return c;\n    }\n    function canOptimize(e) {\n        return (e instanceof code_1._Code &&\n            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));\n    }\n}\nfunction subtractNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction not(x) {\n    return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._) `!${par(x)}`;\n}\nexports.not = not;\nconst andCode = mappend(exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction and(...args) {\n    return args.reduce(andCode);\n}\nexports.and = and;\nconst orCode = mappend(exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction or(...args) {\n    return args.reduce(orCode);\n}\nexports.or = or;\nfunction mappend(op) {\n    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);\n}\nfunction par(x) {\n    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = __webpack_require__(/*! ./code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js\");\nclass ValueError extends Error {\n    constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n    UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n    UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));\nexports.varKinds = {\n    const: new code_1.Name(\"const\"),\n    let: new code_1.Name(\"let\"),\n    var: new code_1.Name(\"var\"),\n};\nclass Scope {\n    constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {\n            throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return (this._names[prefix] = { prefix, index: 0 });\n    }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n    constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;\n    }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._) `\\n`;\nclass ValueScope extends Scope {\n    constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined)\n            throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name)\n                return _name;\n        }\n        else {\n            vs = this._values[prefix] = new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n            return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n            if (name.scopePath === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return (0, code_1._) `${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n            if (name.value === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n            const vs = values[prefix];\n            if (!vs)\n                continue;\n            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());\n            vs.forEach((name) => {\n                if (nameSet.has(name))\n                    return;\n                nameSet.set(name, UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;\n                }\n                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {\n                    code = (0, code_1._) `${code}${c}${this.opts._n}`;\n                }\n                else {\n                    throw new ValueError(name);\n                }\n                nameSet.set(name, UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nexports.ValueScope = ValueScope;\n//# sourceMappingURL=scope.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst names_1 = __webpack_require__(/*! ./names */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js\");\nexports.keywordError = {\n    message: ({ keyword }) => (0, codegen_1.str) `must pass \"${keyword}\" keyword validation`,\n};\nexports.keyword$DataError = {\n    message: ({ keyword, schemaType }) => schemaType\n        ? (0, codegen_1.str) `\"${keyword}\" keyword must be ${schemaType} ($data)`\n        : (0, codegen_1.str) `\"${keyword}\" keyword is invalid ($data)`,\n};\nfunction reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {\n        addError(gen, errObj);\n    }\n    else {\n        returnErrors(it, (0, codegen_1._) `[${errObj}]`);\n    }\n}\nexports.reportError = reportError;\nfunction reportExtraError(cxt, error = exports.keywordError, errorPaths) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    addError(gen, errObj);\n    if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n    }\n}\nexports.reportExtraError = reportExtraError;\nfunction resetErrorsCount(gen, errsCount) {\n    gen.assign(names_1.default.errors, errsCount);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\nexports.resetErrorsCount = resetErrorsCount;\nfunction extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {\n    /* istanbul ignore if */\n    if (errsCount === undefined)\n        throw new Error(\"ajv implementation error\");\n    const err = gen.name(\"err\");\n    gen.forRange(\"i\", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);\n        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);\n            gen.assign((0, codegen_1._) `${err}.data`, data);\n        }\n    });\n}\nexports.extendErrors = extendErrors;\nfunction addError(gen, errObj) {\n    const err = gen.const(\"err\", errObj);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);\n    gen.code((0, codegen_1._) `${names_1.default.errors}++`);\n}\nfunction returnErrors(it, errs) {\n    const { gen, validateName, schemaEnv } = it;\n    if (schemaEnv.$async) {\n        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);\n        gen.return(false);\n    }\n}\nconst E = {\n    keyword: new codegen_1.Name(\"keyword\"),\n    schemaPath: new codegen_1.Name(\"schemaPath\"), // also used in JTD errors\n    params: new codegen_1.Name(\"params\"),\n    propertyName: new codegen_1.Name(\"propertyName\"),\n    message: new codegen_1.Name(\"message\"),\n    schema: new codegen_1.Name(\"schema\"),\n    parentSchema: new codegen_1.Name(\"parentSchema\"),\n};\nfunction errorObjectCode(cxt, error, errorPaths) {\n    const { createErrors } = cxt.it;\n    if (createErrors === false)\n        return (0, codegen_1._) `{}`;\n    return errorObject(cxt, error, errorPaths);\n}\nfunction errorObject(cxt, error, errorPaths = {}) {\n    const { gen, it } = cxt;\n    const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths),\n    ];\n    extraErrorProps(cxt, error, keyValues);\n    return gen.object(...keyValues);\n}\nfunction errorInstancePath({ errorPath }, { instancePath }) {\n    const instPath = instancePath\n        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`\n        : errorPath;\n    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n}\nfunction errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;\n    if (schemaPath) {\n        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n    }\n    return [E.schemaPath, schPath];\n}\nfunction extraErrorProps(cxt, { params, message }, keyValues) {\n    const { keyword, data, schemaValue, it } = cxt;\n    const { opts, propertyName, topSchemaRef, schemaPath } = it;\n    keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || (0, codegen_1._) `{}`]);\n    if (opts.messages) {\n        keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n    }\n    if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n    }\n    if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n}\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst validation_error_1 = __webpack_require__(/*! ../runtime/validation_error */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js\");\nconst names_1 = __webpack_require__(/*! ./names */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js\");\nconst resolve_1 = __webpack_require__(/*! ./resolve */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst validate_1 = __webpack_require__(/*! ./validate */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst names = {\n    // validation function arguments\n    data: new codegen_1.Name(\"data\"), // data passed to validation function\n    // args passed from referencing schema\n    valCxt: new codegen_1.Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n    instancePath: new codegen_1.Name(\"instancePath\"),\n    parentData: new codegen_1.Name(\"parentData\"),\n    parentDataProperty: new codegen_1.Name(\"parentDataProperty\"),\n    rootData: new codegen_1.Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n    dynamicAnchors: new codegen_1.Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n    // function scoped variables\n    vErrors: new codegen_1.Name(\"vErrors\"), // null or array of validation errors\n    errors: new codegen_1.Name(\"errors\"), // counter of validation errors\n    this: new codegen_1.Name(\"this\"),\n    // \"globals\"\n    self: new codegen_1.Name(\"self\"),\n    scope: new codegen_1.Name(\"scope\"),\n    // JTD serialize/parse name for JSON string and position\n    json: new codegen_1.Name(\"json\"),\n    jsonPos: new codegen_1.Name(\"jsonPos\"),\n    jsonLen: new codegen_1.Name(\"jsonLen\"),\n    jsonPart: new codegen_1.Name(\"jsonPart\"),\n};\nexports[\"default\"] = names;\n//# sourceMappingURL=names.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst resolve_1 = __webpack_require__(/*! ./resolve */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js\");\nclass MissingRefError extends Error {\n    constructor(resolver, baseId, ref, msg) {\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));\n    }\n}\nexports[\"default\"] = MissingRefError;\n//# sourceMappingURL=ref_error.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst equal = __webpack_require__(/*! fast-deep-equal */ \"../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js\");\nconst traverse = __webpack_require__(/*! json-schema-traverse */ \"../../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let innerBaseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            innerBaseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = innerBaseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n//# sourceMappingURL=resolve.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getRules = exports.isJSONType = void 0;\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"];\nconst jsonTypes = new Set(_jsonTypes);\nfunction isJSONType(x) {\n    return typeof x == \"string\" && jsonTypes.has(x);\n}\nexports.isJSONType = isJSONType;\nfunction getRules() {\n    const groups = {\n        number: { type: \"number\", rules: [] },\n        string: { type: \"string\", rules: [] },\n        array: { type: \"array\", rules: [] },\n        object: { type: \"object\", rules: [] },\n    };\n    return {\n        types: { ...groups, integer: true, boolean: true, null: true },\n        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],\n        post: { rules: [] },\n        all: {},\n        keywords: {},\n    };\n}\nexports.getRules = getRules;\n//# sourceMappingURL=rules.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = __webpack_require__(/*! ./codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst code_1 = __webpack_require__(/*! ./codegen/code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === \"boolean\")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: \"${key}\"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n            return schema;\n        if (typeof schema == \"string\")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == \"number\")\n        return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var(\"items\", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type || (exports.Type = Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `\"[\" + ${dataProp} + \"]\"`\n                : (0, codegen_1._) `\"['\" + ${dataProp} + \"']\"`\n            : isNumber\n                ? (0, codegen_1._) `\"/\" + ${dataProp}`\n                : (0, codegen_1._) `\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;\nfunction schemaHasRulesForType({ schema, self }, type) {\n    const group = self.RULES.types[type];\n    return group && group !== true && shouldUseGroup(schema, group);\n}\nexports.schemaHasRulesForType = schemaHasRulesForType;\nfunction shouldUseGroup(schema, group) {\n    return group.rules.some((rule) => shouldUseRule(schema, rule));\n}\nexports.shouldUseGroup = shouldUseGroup;\nfunction shouldUseRule(schema, rule) {\n    var _a;\n    return (schema[rule.keyword] !== undefined ||\n        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));\n}\nexports.shouldUseRule = shouldUseRule;\n//# sourceMappingURL=applicability.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = __webpack_require__(/*! ../errors */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js\");\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../names */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = __webpack_require__(/*! ../rules */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js\");\nconst applicability_1 = __webpack_require__(/*! ./applicability */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js\");\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType || (exports.DataType = DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n//# sourceMappingURL=dataType.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assignDefaults = void 0;\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nfunction assignDefaults(it, ty) {\n    const { properties, items } = it.schema;\n    if (ty === \"object\" && properties) {\n        for (const key in properties) {\n            assignDefault(it, key, properties[key].default);\n        }\n    }\n    else if (ty === \"array\" && Array.isArray(items)) {\n        items.forEach((sch, i) => assignDefault(it, i, sch.default));\n    }\n}\nexports.assignDefaults = assignDefaults;\nfunction assignDefault(it, prop, defaultValue) {\n    const { gen, compositeRule, data, opts } = it;\n    if (defaultValue === undefined)\n        return;\n    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;\n    if (compositeRule) {\n        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n    }\n    let condition = (0, codegen_1._) `${childData} === undefined`;\n    if (opts.useDefaults === \"empty\") {\n        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === \"\"`;\n    }\n    // `${childData} === undefined` +\n    // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);\n}\n//# sourceMappingURL=defaults.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = __webpack_require__(/*! ./boolSchema */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js\");\nconst dataType_1 = __webpack_require__(/*! ./dataType */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js\");\nconst applicability_1 = __webpack_require__(/*! ./applicability */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js\");\nconst dataType_2 = __webpack_require__(/*! ./dataType */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js\");\nconst defaults_1 = __webpack_require__(/*! ./defaults */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js\");\nconst keyword_1 = __webpack_require__(/*! ./keyword */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js\");\nconst subschema_1 = __webpack_require__(/*! ./subschema */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js\");\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../names */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js\");\nconst resolve_1 = __webpack_require__(/*! ../resolve */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction narrowSchemaTypes(it, withTypes) {\n    const ts = [];\n    for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n            ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\")\n            ts.push(\"integer\");\n    }\n    it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../names */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js\");\nconst code_1 = __webpack_require__(/*! ../../vocabularies/code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\nconst codegen_1 = __webpack_require__(/*! ../codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nfunction getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {\n    if (keyword !== undefined && schema !== undefined) {\n        throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n    }\n    if (keyword !== undefined) {\n        const sch = it.schema[keyword];\n        return schemaProp === undefined\n            ? {\n                schema: sch,\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n            }\n            : {\n                schema: sch[schemaProp],\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,\n            };\n    }\n    if (schema !== undefined) {\n        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n            throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n        }\n        return {\n            schema,\n            schemaPath,\n            topSchemaRef,\n            errSchemaPath,\n        };\n    }\n    throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nexports.getSubschema = getSubschema;\nfunction extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {\n    if (data !== undefined && dataProp !== undefined) {\n        throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n    }\n    const { gen } = it;\n    if (dataProp !== undefined) {\n        const { errorPath, dataPathArr, opts } = it;\n        const nextData = gen.let(\"data\", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;\n        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n    }\n    if (data !== undefined) {\n        const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n        dataContextProps(nextData);\n        if (propertyName !== undefined)\n            subschema.propertyName = propertyName;\n        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n    }\n    if (dataTypes)\n        subschema.dataTypes = dataTypes;\n    function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [...it.dataNames, _nextData];\n    }\n}\nexports.extendSubschemaData = extendSubschemaData;\nfunction extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {\n    if (compositeRule !== undefined)\n        subschema.compositeRule = compositeRule;\n    if (createErrors !== undefined)\n        subschema.createErrors = createErrors;\n    if (allErrors !== undefined)\n        subschema.allErrors = allErrors;\n    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n    subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nexports.extendSubschemaMode = extendSubschemaMode;\n//# sourceMappingURL=subschema.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = __webpack_require__(/*! ./compile/validate */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js\");\nObject.defineProperty(exports, \"KeywordCxt\", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));\nvar codegen_1 = __webpack_require__(/*! ./compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nObject.defineProperty(exports, \"_\", ({ enumerable: true, get: function () { return codegen_1._; } }));\nObject.defineProperty(exports, \"str\", ({ enumerable: true, get: function () { return codegen_1.str; } }));\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));\nObject.defineProperty(exports, \"nil\", ({ enumerable: true, get: function () { return codegen_1.nil; } }));\nObject.defineProperty(exports, \"Name\", ({ enumerable: true, get: function () { return codegen_1.Name; } }));\nObject.defineProperty(exports, \"CodeGen\", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));\nconst validation_error_1 = __webpack_require__(/*! ./runtime/validation_error */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js\");\nconst ref_error_1 = __webpack_require__(/*! ./compile/ref_error */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js\");\nconst rules_1 = __webpack_require__(/*! ./compile/rules */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js\");\nconst compile_1 = __webpack_require__(/*! ./compile */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js\");\nconst codegen_2 = __webpack_require__(/*! ./compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst resolve_1 = __webpack_require__(/*! ./compile/resolve */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js\");\nconst dataType_1 = __webpack_require__(/*! ./compile/validate/dataType */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js\");\nconst util_1 = __webpack_require__(/*! ./compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst $dataRefSchema = __webpack_require__(/*! ./refs/data.json */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json\");\nconst uri_1 = __webpack_require__(/*! ./runtime/uri */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nexports[\"default\"] = Ajv;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// https://github.com/ajv-validator/ajv/issues/889\nconst equal = __webpack_require__(/*! fast-deep-equal */ \"../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js\");\nequal.code = 'require(\"ajv/dist/runtime/equal\").default';\nexports[\"default\"] = equal;\n//# sourceMappingURL=equal.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n    const len = str.length;\n    let length = 0;\n    let pos = 0;\n    let value;\n    while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n            // high surrogate, and there is a next character\n            value = str.charCodeAt(pos);\n            if ((value & 0xfc00) === 0xdc00)\n                pos++; // low surrogate\n        }\n    }\n    return length;\n}\nexports[\"default\"] = ucs2length;\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n//# sourceMappingURL=ucs2length.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst uri = __webpack_require__(/*! fast-uri */ \"../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js\");\nuri.code = 'require(\"ajv/dist/runtime/uri\").default';\nexports[\"default\"] = uri;\n//# sourceMappingURL=uri.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass ValidationError extends Error {\n    constructor(errors) {\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n    }\n}\nexports[\"default\"] = ValidationError;\n//# sourceMappingURL=validation_error.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports[\"default\"] = def;\n//# sourceMappingURL=additionalItems.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js":
/*!*****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../../compile/names */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: \"must NOT have additional properties\",\n    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,\n};\nconst def = {\n    keyword: \"additionalProperties\",\n    type: [\"object\"],\n    schemaType: [\"boolean\", \"object\"],\n    allowUndefined: true,\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error(\"ajv implementation error\");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n            gen.forIn(\"key\", data, (key) => {\n                if (!props.length && !patProps.length)\n                    additionalPropertyCode(key);\n                else\n                    gen.if(isAdditional(key), () => additionalPropertyCode(key));\n            });\n        }\n        function isAdditional(key) {\n            let definedProp;\n            if (props.length > 8) {\n                // TODO maybe an option instead of hard-coded 8?\n                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n            }\n            else if (props.length) {\n                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));\n            }\n            else {\n                definedProp = codegen_1.nil;\n            }\n            if (patProps.length) {\n                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n            }\n            return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n            gen.code((0, codegen_1._) `delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n            if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n                deleteAdditional(key);\n                return;\n            }\n            if (schema === false) {\n                cxt.setParams({ additionalProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                if (opts.removeAdditional === \"failing\") {\n                    applyAdditionalSchema(key, valid, false);\n                    gen.if((0, codegen_1.not)(valid), () => {\n                        cxt.reset();\n                        deleteAdditional(key);\n                    });\n                }\n                else {\n                    applyAdditionalSchema(key, valid);\n                    if (!allErrors)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                }\n            }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n            const subschema = {\n                keyword: \"additionalProperties\",\n                dataProp: key,\n                dataPropType: util_1.Type.Str,\n            };\n            if (errors === false) {\n                Object.assign(subschema, {\n                    compositeRule: true,\n                    createErrors: false,\n                    allErrors: false,\n                });\n            }\n            cxt.subschema(subschema, valid);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=additionalProperties.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=allOf.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js\");\nconst def = {\n    keyword: \"anyOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    code: code_1.validateUnion,\n    error: { message: \"must match a schema in anyOf\" },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=anyOf.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=contains.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js\");\nexports.error = {\n    message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n};\nconst def = {\n    keyword: \"dependencies\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: exports.error,\n    code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n    },\n};\nfunction splitDependencies({ schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for (const key in schema) {\n        if (key === \"__proto__\")\n            continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen, data, it } = cxt;\n    if (Object.keys(propertyDeps).length === 0)\n        return;\n    const missing = gen.let(\"missing\");\n    for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n            continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(\", \"),\n        });\n        if (it.allErrors) {\n            gen.if(hasProperty, () => {\n                for (const depProp of deps) {\n                    (0, code_1.checkReportMissingProp)(cxt, depProp);\n                }\n            });\n        }\n        else {\n            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n            continue;\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, () => gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports[\"default\"] = def;\n//# sourceMappingURL=dependencies.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports[\"default\"] = def;\n//# sourceMappingURL=if.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst additionalItems_1 = __webpack_require__(/*! ./additionalItems */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\");\nconst prefixItems_1 = __webpack_require__(/*! ./prefixItems */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js\");\nconst items_1 = __webpack_require__(/*! ./items */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js\");\nconst items2020_1 = __webpack_require__(/*! ./items2020 */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js\");\nconst contains_1 = __webpack_require__(/*! ./contains */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js\");\nconst dependencies_1 = __webpack_require__(/*! ./dependencies */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js\");\nconst propertyNames_1 = __webpack_require__(/*! ./propertyNames */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js\");\nconst additionalProperties_1 = __webpack_require__(/*! ./additionalProperties */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\");\nconst properties_1 = __webpack_require__(/*! ./properties */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js\");\nconst patternProperties_1 = __webpack_require__(/*! ./patternProperties */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js\");\nconst not_1 = __webpack_require__(/*! ./not */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js\");\nconst anyOf_1 = __webpack_require__(/*! ./anyOf */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js\");\nconst oneOf_1 = __webpack_require__(/*! ./oneOf */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js\");\nconst allOf_1 = __webpack_require__(/*! ./allOf */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js\");\nconst if_1 = __webpack_require__(/*! ./if */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js\");\nconst thenElse_1 = __webpack_require__(/*! ./thenElse */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js\");\nfunction getApplicator(draft2020 = false) {\n    const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default,\n    ];\n    // array\n    if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n    else\n        applicator.push(additionalItems_1.default, items_1.default);\n    applicator.push(contains_1.default);\n    return applicator;\n}\nexports[\"default\"] = getApplicator;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateTuple = void 0;\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports[\"default\"] = def;\n//# sourceMappingURL=items.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js\");\nconst additionalItems_1 = __webpack_require__(/*! ./additionalItems */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        if (prefixItems)\n            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n            cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=items2020.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: \"must NOT be valid\" },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=not.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=oneOf.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst util_2 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=patternProperties.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst items_1 = __webpack_require__(/*! ./items */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js\");\nconst def = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\"array\"],\n    before: \"uniqueItems\",\n    code: (cxt) => (0, items_1.validateTuple)(cxt, \"items\"),\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=prefixItems.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst validate_1 = __webpack_require__(/*! ../../compile/validate */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst additionalProperties_1 = __webpack_require__(/*! ./additionalProperties */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js\");\nconst def = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n            it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n            return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties) {\n            if (hasDefault(prop)) {\n                applyPropertySchema(prop);\n            }\n            else {\n                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n                applyPropertySchema(prop);\n                if (!it.allErrors)\n                    gen.else().var(valid, true);\n                gen.endIf();\n            }\n            cxt.it.definedProperties.add(prop);\n            cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n        }\n        function applyPropertySchema(prop) {\n            cxt.subschema({\n                keyword: \"properties\",\n                schemaProp: prop,\n                dataProp: prop,\n            }, valid);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=properties.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: \"property name must be valid\",\n    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,\n};\nconst def = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\"object\", \"boolean\"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key) => {\n            cxt.setParams({ propertyName: key });\n            cxt.subschema({\n                keyword: \"propertyNames\",\n                data: key,\n                dataTypes: [\"string\"],\n                propertyName: key,\n                compositeRule: true,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), () => {\n                cxt.error(true);\n                if (!it.allErrors)\n                    gen.break();\n            });\n        });\n        cxt.ok(valid);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=propertyNames.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: [\"then\", \"else\"],\n    schemaType: [\"object\", \"boolean\"],\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === undefined)\n            (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=thenElse.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = __webpack_require__(/*! ../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst names_1 = __webpack_require__(/*! ../compile/names */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js\");\nconst util_2 = __webpack_require__(/*! ../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nfunction checkReportMissingProp(cxt, prop) {\n    const { gen, data, it } = cxt;\n    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);\n        cxt.error();\n    });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp({ gen, data, it: { opts } }, properties, missing) {\n    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n    cxt.setParams({ missingProperty: missing }, true);\n    cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n    return gen.scopeValue(\"func\", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,\n    });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {\n    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n    const valCxt = [\n        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],\n        [names_1.default.parentData, it.parentData],\n        [names_1.default.parentDataProperty, it.parentDataProperty],\n        [names_1.default.rootData, names_1.default.rootData],\n    ];\n    if (it.opts.dynamicRef)\n        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;\n    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._) `new RegExp`;\nfunction usePattern({ gen, it: { opts } }, pattern) {\n    const u = opts.unicodeRegExp ? \"u\" : \"\";\n    const { regExp } = opts.code;\n    const rx = regExp(pattern, u);\n    return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._) `${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,\n    });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    if (it.allErrors) {\n        const validArr = gen.let(\"valid\", true);\n        validateItems(() => gen.assign(validArr, false));\n        return validArr;\n    }\n    gen.var(valid, true);\n    validateItems(() => gen.break());\n    return valid;\n    function validateItems(notValid) {\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        gen.forRange(\"i\", 0, len, (i) => {\n            cxt.subschema({\n                keyword,\n                dataProp: i,\n                dataPropType: util_1.Type.Num,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), notValid);\n        });\n    }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n    const { gen, schema, keyword, it } = cxt;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema))\n        throw new Error(\"ajv implementation error\");\n    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));\n    if (alwaysValid && !it.opts.unevaluated)\n        return;\n    const valid = gen.let(\"valid\", false);\n    const schValid = gen.name(\"_valid\");\n    gen.block(() => schema.forEach((_sch, i) => {\n        const schCxt = cxt.subschema({\n            keyword,\n            schemaProp: i,\n            compositeRule: true,\n        }, schValid);\n        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);\n        const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n        // or if all properties and items were evaluated (it.props === true && it.items === true)\n        if (!merged)\n            gen.if((0, codegen_1.not)(valid));\n    }));\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;\n//# sourceMappingURL=code.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst def = {\n    keyword: \"id\",\n    code() {\n        throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=id.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst id_1 = __webpack_require__(/*! ./id */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js\");\nconst ref_1 = __webpack_require__(/*! ./ref */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js\");\nconst core = [\n    \"$schema\",\n    \"$id\",\n    \"$defs\",\n    \"$vocabulary\",\n    { keyword: \"$comment\" },\n    \"definitions\",\n    id_1.default,\n    ref_1.default,\n];\nexports[\"default\"] = core;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = __webpack_require__(/*! ../../compile/ref_error */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js\");\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst names_1 = __webpack_require__(/*! ../../compile/names */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js\");\nconst compile_1 = __webpack_require__(/*! ../../compile */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports[\"default\"] = def;\n//# sourceMappingURL=ref.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst types_1 = __webpack_require__(/*! ../discriminator/types */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js\");\nconst compile_1 = __webpack_require__(/*! ../../compile */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js\");\nconst ref_error_1 = __webpack_require__(/*! ../../compile/ref_error */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    const ref = sch.$ref;\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                    if (sch === undefined)\n                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DiscrError = void 0;\nvar DiscrError;\n(function (DiscrError) {\n    DiscrError[\"Tag\"] = \"tag\";\n    DiscrError[\"Mapping\"] = \"mapping\";\n})(DiscrError || (exports.DiscrError = DiscrError = {}));\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst core_1 = __webpack_require__(/*! ./core */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js\");\nconst validation_1 = __webpack_require__(/*! ./validation */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js\");\nconst applicator_1 = __webpack_require__(/*! ./applicator */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js\");\nconst format_1 = __webpack_require__(/*! ./format */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js\");\nconst draft7Vocabularies = [\n    core_1.default,\n    validation_1.default,\n    (0, applicator_1.default)(),\n    format_1.default,\n    metadata_1.metadataVocabulary,\n    metadata_1.contentVocabulary,\n];\nexports[\"default\"] = draft7Vocabularies;\n//# sourceMappingURL=draft7.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || \"string\"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=format.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst format_1 = __webpack_require__(/*! ./format */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js\");\nconst format = [format_1.default];\nexports[\"default\"] = format;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.contentVocabulary = exports.metadataVocabulary = void 0;\nexports.metadataVocabulary = [\n    \"title\",\n    \"description\",\n    \"default\",\n    \"deprecated\",\n    \"readOnly\",\n    \"writeOnly\",\n    \"examples\",\n];\nexports.contentVocabulary = [\n    \"contentMediaType\",\n    \"contentEncoding\",\n    \"contentSchema\",\n];\n//# sourceMappingURL=metadata.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst equal_1 = __webpack_require__(/*! ../../runtime/equal */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js\");\nconst error = {\n    message: \"must be equal to constant\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"const\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || (schema && typeof schema == \"object\")) {\n            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        }\n        else {\n            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=const.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst equal_1 = __webpack_require__(/*! ../../runtime/equal */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=enum.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst limitNumber_1 = __webpack_require__(/*! ./limitNumber */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js\");\nconst multipleOf_1 = __webpack_require__(/*! ./multipleOf */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js\");\nconst limitLength_1 = __webpack_require__(/*! ./limitLength */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js\");\nconst pattern_1 = __webpack_require__(/*! ./pattern */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js\");\nconst limitProperties_1 = __webpack_require__(/*! ./limitProperties */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js\");\nconst required_1 = __webpack_require__(/*! ./required */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js\");\nconst limitItems_1 = __webpack_require__(/*! ./limitItems */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js\");\nconst uniqueItems_1 = __webpack_require__(/*! ./uniqueItems */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js\");\nconst const_1 = __webpack_require__(/*! ./const */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js\");\nconst enum_1 = __webpack_require__(/*! ./enum */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js\");\nconst validation = [\n    // number\n    limitNumber_1.default,\n    multipleOf_1.default,\n    // string\n    limitLength_1.default,\n    pattern_1.default,\n    // object\n    limitProperties_1.default,\n    required_1.default,\n    // array\n    limitItems_1.default,\n    uniqueItems_1.default,\n    // any\n    { keyword: \"type\", schemaType: [\"string\", \"array\"] },\n    { keyword: \"nullable\", schemaType: \"boolean\" },\n    const_1.default,\n    enum_1.default,\n];\nexports[\"default\"] = validation;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxItems\", \"minItems\"],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitItems.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst ucs2length_1 = __webpack_require__(/*! ../../runtime/ucs2length */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxLength\", \"minLength\"],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === \"maxLength\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitLength.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    maximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    minimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    exclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    exclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: Object.keys(KWDs),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitNumber.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxProperties\", \"minProperties\"],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=limitProperties.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec\n            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n            : (0, codegen_1._) `${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=multipleOf.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        // TODO regexp should be wrapped in try/catchs\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=pattern.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst code_1 = __webpack_require__(/*! ../code */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=required.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js":
/*!********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst dataType_1 = __webpack_require__(/*! ../../compile/validate/dataType */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js\");\nconst codegen_1 = __webpack_require__(/*! ../../compile/codegen */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js\");\nconst util_1 = __webpack_require__(/*! ../../compile/util */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js\");\nconst equal_1 = __webpack_require__(/*! ../../runtime/equal */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js\");\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, codegen_1._) `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == \"string\"`, (0, codegen_1._) `${item} += \"_\"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports[\"default\"] = def;\n//# sourceMappingURL=uniqueItems.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js ***!
  \******************************************************************************************************/
/***/ ((module) => {

eval("\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Dir.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Dir.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Dir = void 0;\nconst util_1 = __webpack_require__(/*! ./node/util */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/util.js\");\nconst Dirent_1 = __webpack_require__(/*! ./Dirent */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Dirent.js\");\n/**\n * A directory stream, like `fs.Dir`.\n */\nclass Dir {\n    constructor(link, options) {\n        this.link = link;\n        this.options = options;\n        this.iteratorInfo = [];\n        this.path = link.getParentPath();\n        this.iteratorInfo.push(link.children[Symbol.iterator]());\n    }\n    wrapAsync(method, args, callback) {\n        (0, util_1.validateCallback)(callback);\n        setImmediate(() => {\n            let result;\n            try {\n                result = method.apply(this, args);\n            }\n            catch (err) {\n                callback(err);\n                return;\n            }\n            callback(null, result);\n        });\n    }\n    isFunction(x) {\n        return typeof x === 'function';\n    }\n    promisify(obj, fn) {\n        return (...args) => new Promise((resolve, reject) => {\n            if (this.isFunction(obj[fn])) {\n                obj[fn].bind(obj)(...args, (error, result) => {\n                    if (error)\n                        reject(error);\n                    resolve(result);\n                });\n            }\n            else {\n                reject('Not a function');\n            }\n        });\n    }\n    closeBase() { }\n    readBase(iteratorInfo) {\n        let done;\n        let value;\n        let name;\n        let link;\n        do {\n            do {\n                ({ done, value } = iteratorInfo[iteratorInfo.length - 1].next());\n                if (!done) {\n                    [name, link] = value;\n                }\n                else {\n                    break;\n                }\n            } while (name === '.' || name === '..');\n            if (done) {\n                iteratorInfo.pop();\n                if (iteratorInfo.length === 0) {\n                    break;\n                }\n                else {\n                    done = false;\n                }\n            }\n            else {\n                if (this.options.recursive && link.children.size) {\n                    iteratorInfo.push(link.children[Symbol.iterator]());\n                }\n                return Dirent_1.default.build(link, this.options.encoding);\n            }\n        } while (!done);\n        return null;\n    }\n    closeBaseAsync(callback) {\n        this.wrapAsync(this.closeBase, [], callback);\n    }\n    close(callback) {\n        if (typeof callback === 'function') {\n            this.closeBaseAsync(callback);\n        }\n        else {\n            return this.promisify(this, 'closeBaseAsync')();\n        }\n    }\n    closeSync() {\n        this.closeBase();\n    }\n    readBaseAsync(callback) {\n        this.wrapAsync(this.readBase, [this.iteratorInfo], callback);\n    }\n    read(callback) {\n        if (typeof callback === 'function') {\n            this.readBaseAsync(callback);\n        }\n        else {\n            return this.promisify(this, 'readBaseAsync')();\n        }\n    }\n    readSync() {\n        return this.readBase(this.iteratorInfo);\n    }\n    [Symbol.asyncIterator]() {\n        const iteratorInfo = [];\n        const _this = this;\n        iteratorInfo.push(_this.link.children[Symbol.iterator]());\n        // auxiliary object so promisify() can be used\n        const o = {\n            readBaseAsync(callback) {\n                _this.wrapAsync(_this.readBase, [iteratorInfo], callback);\n            },\n        };\n        return {\n            async next() {\n                const dirEnt = await _this.promisify(o, 'readBaseAsync')();\n                if (dirEnt !== null) {\n                    return { done: false, value: dirEnt };\n                }\n                else {\n                    return { done: true, value: undefined };\n                }\n            },\n            [Symbol.asyncIterator]() {\n                throw new Error('Not implemented');\n            },\n        };\n    }\n}\nexports.Dir = Dir;\n//# sourceMappingURL=Dir.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Dir.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Dirent.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Dirent.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Dirent = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/constants.js\");\nconst encoding_1 = __webpack_require__(/*! ./encoding */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/encoding.js\");\nconst { S_IFMT, S_IFDIR, S_IFREG, S_IFBLK, S_IFCHR, S_IFLNK, S_IFIFO, S_IFSOCK } = constants_1.constants;\n/**\n * A directory entry, like `fs.Dirent`.\n */\nclass Dirent {\n    constructor() {\n        this.name = '';\n        this.path = '';\n        this.parentPath = '';\n        this.mode = 0;\n    }\n    static build(link, encoding) {\n        const dirent = new Dirent();\n        const { mode } = link.getNode();\n        dirent.name = (0, encoding_1.strToEncoding)(link.getName(), encoding);\n        dirent.mode = mode;\n        dirent.path = link.getParentPath();\n        dirent.parentPath = dirent.path;\n        return dirent;\n    }\n    _checkModeProperty(property) {\n        return (this.mode & S_IFMT) === property;\n    }\n    isDirectory() {\n        return this._checkModeProperty(S_IFDIR);\n    }\n    isFile() {\n        return this._checkModeProperty(S_IFREG);\n    }\n    isBlockDevice() {\n        return this._checkModeProperty(S_IFBLK);\n    }\n    isCharacterDevice() {\n        return this._checkModeProperty(S_IFCHR);\n    }\n    isSymbolicLink() {\n        return this._checkModeProperty(S_IFLNK);\n    }\n    isFIFO() {\n        return this._checkModeProperty(S_IFIFO);\n    }\n    isSocket() {\n        return this._checkModeProperty(S_IFSOCK);\n    }\n}\nexports.Dirent = Dirent;\nexports[\"default\"] = Dirent;\n//# sourceMappingURL=Dirent.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Dirent.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Stats.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Stats.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Stats = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/constants.js\");\nconst { S_IFMT, S_IFDIR, S_IFREG, S_IFBLK, S_IFCHR, S_IFLNK, S_IFIFO, S_IFSOCK } = constants_1.constants;\n/**\n * Statistics about a file/directory, like `fs.Stats`.\n */\nclass Stats {\n    static build(node, bigint = false) {\n        const stats = new Stats();\n        const { uid, gid, atime, mtime, ctime } = node;\n        const getStatNumber = !bigint ? number => number : number => BigInt(number);\n        // Copy all values on Stats from Node, so that if Node values\n        // change, values on Stats would still be the old ones,\n        // just like in Node fs.\n        stats.uid = getStatNumber(uid);\n        stats.gid = getStatNumber(gid);\n        stats.rdev = getStatNumber(0);\n        stats.blksize = getStatNumber(4096);\n        stats.ino = getStatNumber(node.ino);\n        stats.size = getStatNumber(node.getSize());\n        stats.blocks = getStatNumber(1);\n        stats.atime = atime;\n        stats.mtime = mtime;\n        stats.ctime = ctime;\n        stats.birthtime = ctime;\n        stats.atimeMs = getStatNumber(atime.getTime());\n        stats.mtimeMs = getStatNumber(mtime.getTime());\n        const ctimeMs = getStatNumber(ctime.getTime());\n        stats.ctimeMs = ctimeMs;\n        stats.birthtimeMs = ctimeMs;\n        if (bigint) {\n            stats.atimeNs = BigInt(atime.getTime()) * BigInt(1000000);\n            stats.mtimeNs = BigInt(mtime.getTime()) * BigInt(1000000);\n            const ctimeNs = BigInt(ctime.getTime()) * BigInt(1000000);\n            stats.ctimeNs = ctimeNs;\n            stats.birthtimeNs = ctimeNs;\n        }\n        stats.dev = getStatNumber(0);\n        stats.mode = getStatNumber(node.mode);\n        stats.nlink = getStatNumber(node.nlink);\n        return stats;\n    }\n    _checkModeProperty(property) {\n        return (Number(this.mode) & S_IFMT) === property;\n    }\n    isDirectory() {\n        return this._checkModeProperty(S_IFDIR);\n    }\n    isFile() {\n        return this._checkModeProperty(S_IFREG);\n    }\n    isBlockDevice() {\n        return this._checkModeProperty(S_IFBLK);\n    }\n    isCharacterDevice() {\n        return this._checkModeProperty(S_IFCHR);\n    }\n    isSymbolicLink() {\n        return this._checkModeProperty(S_IFLNK);\n    }\n    isFIFO() {\n        return this._checkModeProperty(S_IFIFO);\n    }\n    isSocket() {\n        return this._checkModeProperty(S_IFSOCK);\n    }\n}\nexports.Stats = Stats;\nexports[\"default\"] = Stats;\n//# sourceMappingURL=Stats.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Stats.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/constants.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/constants.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.constants = void 0;\nexports.constants = {\n    O_RDONLY: 0,\n    O_WRONLY: 1,\n    O_RDWR: 2,\n    S_IFMT: 61440,\n    S_IFREG: 32768,\n    S_IFDIR: 16384,\n    S_IFCHR: 8192,\n    S_IFBLK: 24576,\n    S_IFIFO: 4096,\n    S_IFLNK: 40960,\n    S_IFSOCK: 49152,\n    O_CREAT: 64,\n    O_EXCL: 128,\n    O_NOCTTY: 256,\n    O_TRUNC: 512,\n    O_APPEND: 1024,\n    O_DIRECTORY: 65536,\n    O_NOATIME: 262144,\n    O_NOFOLLOW: 131072,\n    O_SYNC: 1052672,\n    O_SYMLINK: 2097152,\n    O_DIRECT: 16384,\n    O_NONBLOCK: 2048,\n    S_IRWXU: 448,\n    S_IRUSR: 256,\n    S_IWUSR: 128,\n    S_IXUSR: 64,\n    S_IRWXG: 56,\n    S_IRGRP: 32,\n    S_IWGRP: 16,\n    S_IXGRP: 8,\n    S_IRWXO: 7,\n    S_IROTH: 4,\n    S_IWOTH: 2,\n    S_IXOTH: 1,\n    F_OK: 0,\n    R_OK: 4,\n    W_OK: 2,\n    X_OK: 1,\n    UV_FS_SYMLINK_DIR: 1,\n    UV_FS_SYMLINK_JUNCTION: 2,\n    UV_FS_COPYFILE_EXCL: 1,\n    UV_FS_COPYFILE_FICLONE: 2,\n    UV_FS_COPYFILE_FICLONE_FORCE: 4,\n    COPYFILE_EXCL: 1,\n    COPYFILE_FICLONE: 2,\n    COPYFILE_FICLONE_FORCE: 4,\n};\n//# sourceMappingURL=constants.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/constants.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/encoding.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/encoding.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ENCODING_UTF8 = void 0;\nexports.assertEncoding = assertEncoding;\nexports.strToEncoding = strToEncoding;\nconst buffer_1 = __webpack_require__(/*! ./internal/buffer */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/buffer.js\");\nconst errors = __webpack_require__(/*! ./internal/errors */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/errors.js\");\nexports.ENCODING_UTF8 = 'utf8';\nfunction assertEncoding(encoding) {\n    if (encoding && !buffer_1.Buffer.isEncoding(encoding))\n        throw new errors.TypeError('ERR_INVALID_OPT_VALUE_ENCODING', encoding);\n}\nfunction strToEncoding(str, encoding) {\n    if (!encoding || encoding === exports.ENCODING_UTF8)\n        return str; // UTF-8\n    if (encoding === 'buffer')\n        return new buffer_1.Buffer(str); // `buffer` encoding\n    return new buffer_1.Buffer(str).toString(encoding); // Custom encoding\n}\n//# sourceMappingURL=encoding.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/encoding.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/index.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/index.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.memfs = exports.fs = exports.vol = exports.Volume = void 0;\nexports.createFsFromVolume = createFsFromVolume;\nconst Stats_1 = __webpack_require__(/*! ./Stats */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Stats.js\");\nconst Dirent_1 = __webpack_require__(/*! ./Dirent */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Dirent.js\");\nconst volume_1 = __webpack_require__(/*! ./volume */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/volume.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/constants.js\");\nconst fsSynchronousApiList_1 = __webpack_require__(/*! ./node/lists/fsSynchronousApiList */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/lists/fsSynchronousApiList.js\");\nconst fsCallbackApiList_1 = __webpack_require__(/*! ./node/lists/fsCallbackApiList */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/lists/fsCallbackApiList.js\");\nconst { F_OK, R_OK, W_OK, X_OK } = constants_1.constants;\nexports.Volume = volume_1.Volume;\n// Default volume.\nexports.vol = new volume_1.Volume();\nfunction createFsFromVolume(vol) {\n    const fs = { F_OK, R_OK, W_OK, X_OK, constants: constants_1.constants, Stats: Stats_1.default, Dirent: Dirent_1.default };\n    // Bind FS methods.\n    for (const method of fsSynchronousApiList_1.fsSynchronousApiList)\n        if (typeof vol[method] === 'function')\n            fs[method] = vol[method].bind(vol);\n    for (const method of fsCallbackApiList_1.fsCallbackApiList)\n        if (typeof vol[method] === 'function')\n            fs[method] = vol[method].bind(vol);\n    fs.StatWatcher = vol.StatWatcher;\n    fs.FSWatcher = vol.FSWatcher;\n    fs.WriteStream = vol.WriteStream;\n    fs.ReadStream = vol.ReadStream;\n    fs.promises = vol.promises;\n    fs._toUnixTimestamp = volume_1.toUnixTimestamp;\n    fs.__vol = vol;\n    return fs;\n}\nexports.fs = createFsFromVolume(exports.vol);\n/**\n * Creates a new file system instance.\n *\n * @param json File system structure expressed as a JSON object.\n *        Use `null` for empty directories and empty string for empty files.\n * @param cwd Current working directory. The JSON structure will be created\n *        relative to this path.\n * @returns A `memfs` file system instance, which is a drop-in replacement for\n *          the `fs` module.\n */\nconst memfs = (json = {}, cwd = '/') => {\n    const vol = exports.Volume.fromNestedJSON(json, cwd);\n    const fs = createFsFromVolume(vol);\n    return { fs, vol };\n};\nexports.memfs = memfs;\nmodule.exports = Object.assign(Object.assign({}, module.exports), exports.fs);\nmodule.exports.semantic = true;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/buffer.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/buffer.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bufferFrom = exports.bufferAllocUnsafe = exports.Buffer = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nObject.defineProperty(exports, \"Buffer\", ({ enumerable: true, get: function () { return buffer_1.Buffer; } }));\nfunction bufferV0P12Ponyfill(arg0, ...args) {\n    return new buffer_1.Buffer(arg0, ...args);\n}\nconst bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;\nexports.bufferAllocUnsafe = bufferAllocUnsafe;\nconst bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;\nexports.bufferFrom = bufferFrom;\n//# sourceMappingURL=buffer.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/buffer.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/errors.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/errors.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change, the code should not.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AssertionError = exports.RangeError = exports.TypeError = exports.Error = void 0;\nexports.message = message;\nexports.E = E;\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst kCode = typeof Symbol === 'undefined' ? '_kCode' : Symbol('code');\nconst messages = {}; // new Map();\nfunction makeNodeError(Base) {\n    return class NodeError extends Base {\n        constructor(key, ...args) {\n            super(message(key, args));\n            this.code = key;\n            this[kCode] = key;\n            this.name = `${super.name} [${this[kCode]}]`;\n        }\n    };\n}\nconst g = typeof globalThis !== 'undefined' ? globalThis : global;\nclass AssertionError extends g.Error {\n    constructor(options) {\n        if (typeof options !== 'object' || options === null) {\n            throw new exports.TypeError('ERR_INVALID_ARG_TYPE', 'options', 'object');\n        }\n        if (options.message) {\n            super(options.message);\n        }\n        else {\n            super(`${util.inspect(options.actual).slice(0, 128)} ` +\n                `${options.operator} ${util.inspect(options.expected).slice(0, 128)}`);\n        }\n        this.generatedMessage = !options.message;\n        this.name = 'AssertionError [ERR_ASSERTION]';\n        this.code = 'ERR_ASSERTION';\n        this.actual = options.actual;\n        this.expected = options.expected;\n        this.operator = options.operator;\n        exports.Error.captureStackTrace(this, options.stackStartFunction);\n    }\n}\nexports.AssertionError = AssertionError;\nfunction message(key, args) {\n    assert.strictEqual(typeof key, 'string');\n    // const msg = messages.get(key);\n    const msg = messages[key];\n    assert(msg, `An invalid error message key was used: ${key}.`);\n    let fmt;\n    if (typeof msg === 'function') {\n        fmt = msg;\n    }\n    else {\n        fmt = util.format;\n        if (args === undefined || args.length === 0)\n            return msg;\n        args.unshift(msg);\n    }\n    return String(fmt.apply(null, args));\n}\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\nfunction E(sym, val) {\n    messages[sym] = typeof val === 'function' ? val : String(val);\n}\nexports.Error = makeNodeError(g.Error);\nexports.TypeError = makeNodeError(g.TypeError);\nexports.RangeError = makeNodeError(g.RangeError);\n// To declare an error message, use the E(sym, val) function above. The sym\n// must be an upper case string. The val can be either a function or a string.\n// The return value of the function must be a string.\n// Examples:\n// E('EXAMPLE_KEY1', 'This is the error value');\n// E('EXAMPLE_KEY2', (a, b) => return `${a} ${b}`);\n//\n// Once an error code has been assigned, the code itself MUST NOT change and\n// any given error code must never be reused to identify a different error.\n//\n// Any error code added here should also be added to the documentation\n//\n// Note: Please try to keep these in alphabetical order\nE('ERR_ARG_NOT_ITERABLE', '%s must be iterable');\nE('ERR_ASSERTION', '%s');\nE('ERR_BUFFER_OUT_OF_BOUNDS', bufferOutOfBounds);\nE('ERR_CHILD_CLOSED_BEFORE_REPLY', 'Child closed before reply received');\nE('ERR_CONSOLE_WRITABLE_STREAM', 'Console expects a writable stream instance for %s');\nE('ERR_CPU_USAGE', 'Unable to obtain cpu usage %s');\nE('ERR_DNS_SET_SERVERS_FAILED', (err, servers) => `c-ares failed to set servers: \"${err}\" [${servers}]`);\nE('ERR_FALSY_VALUE_REJECTION', 'Promise was rejected with falsy value');\nE('ERR_ENCODING_NOT_SUPPORTED', enc => `The \"${enc}\" encoding is not supported`);\nE('ERR_ENCODING_INVALID_ENCODED_DATA', enc => `The encoded data was not valid for encoding ${enc}`);\nE('ERR_HTTP_HEADERS_SENT', 'Cannot render headers after they are sent to the client');\nE('ERR_HTTP_INVALID_STATUS_CODE', 'Invalid status code: %s');\nE('ERR_HTTP_TRAILER_INVALID', 'Trailers are invalid with this transfer encoding');\nE('ERR_INDEX_OUT_OF_RANGE', 'Index out of range');\nE('ERR_INVALID_ARG_TYPE', invalidArgType);\nE('ERR_INVALID_ARRAY_LENGTH', (name, len, actual) => {\n    assert.strictEqual(typeof actual, 'number');\n    return `The array \"${name}\" (length ${actual}) must be of length ${len}.`;\n});\nE('ERR_INVALID_BUFFER_SIZE', 'Buffer size must be a multiple of %s');\nE('ERR_INVALID_CALLBACK', 'Callback must be a function');\nE('ERR_INVALID_CHAR', 'Invalid character in %s');\nE('ERR_INVALID_CURSOR_POS', 'Cannot set cursor row without setting its column');\nE('ERR_INVALID_FD', '\"fd\" must be a positive integer: %s');\nE('ERR_INVALID_FILE_URL_HOST', 'File URL host must be \"localhost\" or empty on %s');\nE('ERR_INVALID_FILE_URL_PATH', 'File URL path %s');\nE('ERR_INVALID_HANDLE_TYPE', 'This handle type cannot be sent');\nE('ERR_INVALID_IP_ADDRESS', 'Invalid IP address: %s');\nE('ERR_INVALID_OPT_VALUE', (name, value) => {\n    return `The value \"${String(value)}\" is invalid for option \"${name}\"`;\n});\nE('ERR_INVALID_OPT_VALUE_ENCODING', value => `The value \"${String(value)}\" is invalid for option \"encoding\"`);\nE('ERR_INVALID_REPL_EVAL_CONFIG', 'Cannot specify both \"breakEvalOnSigint\" and \"eval\" for REPL');\nE('ERR_INVALID_SYNC_FORK_INPUT', 'Asynchronous forks do not support Buffer, Uint8Array or string input: %s');\nE('ERR_INVALID_THIS', 'Value of \"this\" must be of type %s');\nE('ERR_INVALID_TUPLE', '%s must be an iterable %s tuple');\nE('ERR_INVALID_URL', 'Invalid URL: %s');\nE('ERR_INVALID_URL_SCHEME', expected => `The URL must be ${oneOf(expected, 'scheme')}`);\nE('ERR_IPC_CHANNEL_CLOSED', 'Channel closed');\nE('ERR_IPC_DISCONNECTED', 'IPC channel is already disconnected');\nE('ERR_IPC_ONE_PIPE', 'Child process can have only one IPC pipe');\nE('ERR_IPC_SYNC_FORK', 'IPC cannot be used with synchronous forks');\nE('ERR_MISSING_ARGS', missingArgs);\nE('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\nE('ERR_NAPI_CONS_FUNCTION', 'Constructor must be a function');\nE('ERR_NAPI_CONS_PROTOTYPE_OBJECT', 'Constructor.prototype must be an object');\nE('ERR_NO_CRYPTO', 'Node.js is not compiled with OpenSSL crypto support');\nE('ERR_NO_LONGER_SUPPORTED', '%s is no longer supported');\nE('ERR_PARSE_HISTORY_DATA', 'Could not parse history data in %s');\nE('ERR_SOCKET_ALREADY_BOUND', 'Socket is already bound');\nE('ERR_SOCKET_BAD_PORT', 'Port should be > 0 and < 65536');\nE('ERR_SOCKET_BAD_TYPE', 'Bad socket type specified. Valid types are: udp4, udp6');\nE('ERR_SOCKET_CANNOT_SEND', 'Unable to send data');\nE('ERR_SOCKET_CLOSED', 'Socket is closed');\nE('ERR_SOCKET_DGRAM_NOT_RUNNING', 'Not running');\nE('ERR_STDERR_CLOSE', 'process.stderr cannot be closed');\nE('ERR_STDOUT_CLOSE', 'process.stdout cannot be closed');\nE('ERR_STREAM_WRAP', 'Stream has StringDecoder set or is in objectMode');\nE('ERR_TLS_CERT_ALTNAME_INVALID', \"Hostname/IP does not match certificate's altnames: %s\");\nE('ERR_TLS_DH_PARAM_SIZE', size => `DH parameter size ${size} is less than 2048`);\nE('ERR_TLS_HANDSHAKE_TIMEOUT', 'TLS handshake timeout');\nE('ERR_TLS_RENEGOTIATION_FAILED', 'Failed to renegotiate');\nE('ERR_TLS_REQUIRED_SERVER_NAME', '\"servername\" is required parameter for Server.addContext');\nE('ERR_TLS_SESSION_ATTACK', 'TSL session renegotiation attack detected');\nE('ERR_TRANSFORM_ALREADY_TRANSFORMING', 'Calling transform done when still transforming');\nE('ERR_TRANSFORM_WITH_LENGTH_0', 'Calling transform done when writableState.length != 0');\nE('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s');\nE('ERR_UNKNOWN_SIGNAL', 'Unknown signal: %s');\nE('ERR_UNKNOWN_STDIN_TYPE', 'Unknown stdin file type');\nE('ERR_UNKNOWN_STREAM_TYPE', 'Unknown stream file type');\nE('ERR_V8BREAKITERATOR', 'Full ICU data not installed. ' + 'See https://github.com/nodejs/node/wiki/Intl');\nfunction invalidArgType(name, expected, actual) {\n    assert(name, 'name is required');\n    // determiner: 'must be' or 'must not be'\n    let determiner;\n    if (expected.includes('not ')) {\n        determiner = 'must not be';\n        expected = expected.split('not ')[1];\n    }\n    else {\n        determiner = 'must be';\n    }\n    let msg;\n    if (Array.isArray(name)) {\n        const names = name.map(val => `\"${val}\"`).join(', ');\n        msg = `The ${names} arguments ${determiner} ${oneOf(expected, 'type')}`;\n    }\n    else if (name.includes(' argument')) {\n        // for the case like 'first argument'\n        msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n    }\n    else {\n        const type = name.includes('.') ? 'property' : 'argument';\n        msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n    }\n    // if actual value received, output it\n    if (arguments.length >= 3) {\n        msg += `. Received type ${actual !== null ? typeof actual : 'null'}`;\n    }\n    return msg;\n}\nfunction missingArgs(...args) {\n    assert(args.length > 0, 'At least one arg needs to be specified');\n    let msg = 'The ';\n    const len = args.length;\n    args = args.map(a => `\"${a}\"`);\n    switch (len) {\n        case 1:\n            msg += `${args[0]} argument`;\n            break;\n        case 2:\n            msg += `${args[0]} and ${args[1]} arguments`;\n            break;\n        default:\n            msg += args.slice(0, len - 1).join(', ');\n            msg += `, and ${args[len - 1]} arguments`;\n            break;\n    }\n    return `${msg} must be specified`;\n}\nfunction oneOf(expected, thing) {\n    assert(expected, 'expected is required');\n    assert(typeof thing === 'string', 'thing is required');\n    if (Array.isArray(expected)) {\n        const len = expected.length;\n        assert(len > 0, 'At least one expected value needs to be specified');\n        // tslint:disable-next-line\n        expected = expected.map(i => String(i));\n        if (len > 2) {\n            return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` + expected[len - 1];\n        }\n        else if (len === 2) {\n            return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n        }\n        else {\n            return `of ${thing} ${expected[0]}`;\n        }\n    }\n    else {\n        return `of ${thing} ${String(expected)}`;\n    }\n}\nfunction bufferOutOfBounds(name, isWriting) {\n    if (isWriting) {\n        return 'Attempt to write outside buffer bounds';\n    }\n    else {\n        return `\"${name}\" is outside of buffer bounds`;\n    }\n}\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/errors.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node-to-fsa/util.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node-to-fsa/util.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.newNotAllowedError = exports.newTypeMismatchError = exports.newNotFoundError = exports.assertCanWrite = exports.assertName = exports.basename = exports.ctx = void 0;\n/**\n * Creates a new {@link NodeFsaContext}.\n */\nconst ctx = (partial = {}) => {\n    return Object.assign({ separator: '/', syncHandleAllowed: false, mode: 'read' }, partial);\n};\nexports.ctx = ctx;\nconst basename = (path, separator) => {\n    if (path[path.length - 1] === separator)\n        path = path.slice(0, -1);\n    const lastSlashIndex = path.lastIndexOf(separator);\n    return lastSlashIndex === -1 ? path : path.slice(lastSlashIndex + 1);\n};\nexports.basename = basename;\nconst nameRegex = /^(\\.{1,2})$|^(.*([\\/\\\\]).*)$/;\nconst assertName = (name, method, klass) => {\n    const isInvalid = !name || nameRegex.test(name);\n    if (isInvalid)\n        throw new TypeError(`Failed to execute '${method}' on '${klass}': Name is not allowed.`);\n};\nexports.assertName = assertName;\nconst assertCanWrite = (mode) => {\n    if (mode !== 'readwrite')\n        throw new DOMException('The request is not allowed by the user agent or the platform in the current context.', 'NotAllowedError');\n};\nexports.assertCanWrite = assertCanWrite;\nconst newNotFoundError = () => new DOMException('A requested file or directory could not be found at the time an operation was processed.', 'NotFoundError');\nexports.newNotFoundError = newNotFoundError;\nconst newTypeMismatchError = () => new DOMException('The path supplied exists, but was not an entry of requested type.', 'TypeMismatchError');\nexports.newTypeMismatchError = newTypeMismatchError;\nconst newNotAllowedError = () => new DOMException('Permission not granted.', 'NotAllowedError');\nexports.newNotAllowedError = newNotAllowedError;\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node-to-fsa/util.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.File = exports.Link = exports.Node = exports.SEP = void 0;\nconst process_1 = __webpack_require__(/*! ./process */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/process.js\");\nconst buffer_1 = __webpack_require__(/*! ./internal/buffer */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/buffer.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/constants.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst Stats_1 = __webpack_require__(/*! ./Stats */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Stats.js\");\nconst { S_IFMT, S_IFDIR, S_IFREG, S_IFLNK, O_APPEND } = constants_1.constants;\nconst getuid = () => { var _a, _b; return (_b = (_a = process_1.default.getuid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0; };\nconst getgid = () => { var _a, _b; return (_b = (_a = process_1.default.getgid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0; };\nexports.SEP = '/';\n/**\n * Node in a file system (like i-node, v-node).\n */\nclass Node extends events_1.EventEmitter {\n    constructor(ino, perm = 0o666) {\n        super();\n        // User ID and group ID.\n        this._uid = getuid();\n        this._gid = getgid();\n        this._atime = new Date();\n        this._mtime = new Date();\n        this._ctime = new Date();\n        this._perm = 0o666; // Permissions `chmod`, `fchmod`\n        this.mode = S_IFREG; // S_IFDIR, S_IFREG, etc.. (file by default?)\n        // Number of hard links pointing at this Node.\n        this._nlink = 1;\n        this._perm = perm;\n        this.mode |= perm;\n        this.ino = ino;\n    }\n    set ctime(ctime) {\n        this._ctime = ctime;\n    }\n    get ctime() {\n        return this._ctime;\n    }\n    set uid(uid) {\n        this._uid = uid;\n        this.ctime = new Date();\n    }\n    get uid() {\n        return this._uid;\n    }\n    set gid(gid) {\n        this._gid = gid;\n        this.ctime = new Date();\n    }\n    get gid() {\n        return this._gid;\n    }\n    set atime(atime) {\n        this._atime = atime;\n        this.ctime = new Date();\n    }\n    get atime() {\n        return this._atime;\n    }\n    set mtime(mtime) {\n        this._mtime = mtime;\n        this.ctime = new Date();\n    }\n    get mtime() {\n        return this._mtime;\n    }\n    set perm(perm) {\n        this._perm = perm;\n        this.ctime = new Date();\n    }\n    get perm() {\n        return this._perm;\n    }\n    set nlink(nlink) {\n        this._nlink = nlink;\n        this.ctime = new Date();\n    }\n    get nlink() {\n        return this._nlink;\n    }\n    getString(encoding = 'utf8') {\n        this.atime = new Date();\n        return this.getBuffer().toString(encoding);\n    }\n    setString(str) {\n        // this.setBuffer(bufferFrom(str, 'utf8'));\n        this.buf = (0, buffer_1.bufferFrom)(str, 'utf8');\n        this.touch();\n    }\n    getBuffer() {\n        this.atime = new Date();\n        if (!this.buf)\n            this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));\n        return (0, buffer_1.bufferFrom)(this.buf); // Return a copy.\n    }\n    setBuffer(buf) {\n        this.buf = (0, buffer_1.bufferFrom)(buf); // Creates a copy of data.\n        this.touch();\n    }\n    getSize() {\n        return this.buf ? this.buf.length : 0;\n    }\n    setModeProperty(property) {\n        this.mode = (this.mode & ~S_IFMT) | property;\n    }\n    setIsFile() {\n        this.setModeProperty(S_IFREG);\n    }\n    setIsDirectory() {\n        this.setModeProperty(S_IFDIR);\n    }\n    setIsSymlink() {\n        this.setModeProperty(S_IFLNK);\n    }\n    isFile() {\n        return (this.mode & S_IFMT) === S_IFREG;\n    }\n    isDirectory() {\n        return (this.mode & S_IFMT) === S_IFDIR;\n    }\n    isSymlink() {\n        // return !!this.symlink;\n        return (this.mode & S_IFMT) === S_IFLNK;\n    }\n    makeSymlink(steps) {\n        this.symlink = steps;\n        this.setIsSymlink();\n    }\n    write(buf, off = 0, len = buf.length, pos = 0) {\n        if (!this.buf)\n            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);\n        if (pos + len > this.buf.length) {\n            const newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);\n            this.buf.copy(newBuf, 0, 0, this.buf.length);\n            this.buf = newBuf;\n        }\n        buf.copy(this.buf, pos, off, off + len);\n        this.touch();\n        return len;\n    }\n    // Returns the number of bytes read.\n    read(buf, off = 0, len = buf.byteLength, pos = 0) {\n        this.atime = new Date();\n        if (!this.buf)\n            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);\n        let actualLen = len;\n        if (actualLen > buf.byteLength) {\n            actualLen = buf.byteLength;\n        }\n        if (actualLen + pos > this.buf.length) {\n            actualLen = this.buf.length - pos;\n        }\n        const buf2 = buf instanceof buffer_1.Buffer ? buf : buffer_1.Buffer.from(buf.buffer);\n        this.buf.copy(buf2, off, pos, pos + actualLen);\n        return actualLen;\n    }\n    truncate(len = 0) {\n        if (!len)\n            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);\n        else {\n            if (!this.buf)\n                this.buf = (0, buffer_1.bufferAllocUnsafe)(0);\n            if (len <= this.buf.length) {\n                this.buf = this.buf.slice(0, len);\n            }\n            else {\n                const buf = (0, buffer_1.bufferAllocUnsafe)(len);\n                this.buf.copy(buf);\n                buf.fill(0, this.buf.length);\n                this.buf = buf;\n            }\n        }\n        this.touch();\n    }\n    chmod(perm) {\n        this.perm = perm;\n        this.mode = (this.mode & ~0o777) | perm;\n        this.touch();\n    }\n    chown(uid, gid) {\n        this.uid = uid;\n        this.gid = gid;\n        this.touch();\n    }\n    touch() {\n        this.mtime = new Date();\n        this.emit('change', this);\n    }\n    canRead(uid = getuid(), gid = getgid()) {\n        if (this.perm & 4 /* S.IROTH */) {\n            return true;\n        }\n        if (gid === this.gid) {\n            if (this.perm & 32 /* S.IRGRP */) {\n                return true;\n            }\n        }\n        if (uid === this.uid) {\n            if (this.perm & 256 /* S.IRUSR */) {\n                return true;\n            }\n        }\n        return false;\n    }\n    canWrite(uid = getuid(), gid = getgid()) {\n        if (this.perm & 2 /* S.IWOTH */) {\n            return true;\n        }\n        if (gid === this.gid) {\n            if (this.perm & 16 /* S.IWGRP */) {\n                return true;\n            }\n        }\n        if (uid === this.uid) {\n            if (this.perm & 128 /* S.IWUSR */) {\n                return true;\n            }\n        }\n        return false;\n    }\n    canExecute(uid = getuid(), gid = getgid()) {\n        if (this.perm & 1 /* S.IXOTH */) {\n            return true;\n        }\n        if (gid === this.gid) {\n            if (this.perm & 8 /* S.IXGRP */) {\n                return true;\n            }\n        }\n        if (uid === this.uid) {\n            if (this.perm & 64 /* S.IXUSR */) {\n                return true;\n            }\n        }\n        return false;\n    }\n    del() {\n        this.emit('delete', this);\n    }\n    toJSON() {\n        return {\n            ino: this.ino,\n            uid: this.uid,\n            gid: this.gid,\n            atime: this.atime.getTime(),\n            mtime: this.mtime.getTime(),\n            ctime: this.ctime.getTime(),\n            perm: this.perm,\n            mode: this.mode,\n            nlink: this.nlink,\n            symlink: this.symlink,\n            data: this.getString(),\n        };\n    }\n}\nexports.Node = Node;\n/**\n * Represents a hard link that points to an i-node `node`.\n */\nclass Link extends events_1.EventEmitter {\n    get steps() {\n        return this._steps;\n    }\n    // Recursively sync children steps, e.g. in case of dir rename\n    set steps(val) {\n        this._steps = val;\n        for (const [child, link] of this.children.entries()) {\n            if (child === '.' || child === '..') {\n                continue;\n            }\n            link === null || link === void 0 ? void 0 : link.syncSteps();\n        }\n    }\n    constructor(vol, parent, name) {\n        super();\n        this.children = new Map();\n        // Path to this node as Array: ['usr', 'bin', 'node'].\n        this._steps = [];\n        // \"i-node\" number of the node.\n        this.ino = 0;\n        // Number of children.\n        this.length = 0;\n        this.vol = vol;\n        this.parent = parent;\n        this.name = name;\n        this.syncSteps();\n    }\n    setNode(node) {\n        this.node = node;\n        this.ino = node.ino;\n    }\n    getNode() {\n        return this.node;\n    }\n    createChild(name, node = this.vol.createNode()) {\n        const link = new Link(this.vol, this, name);\n        link.setNode(node);\n        if (node.isDirectory()) {\n            link.children.set('.', link);\n            link.getNode().nlink++;\n        }\n        this.setChild(name, link);\n        return link;\n    }\n    setChild(name, link = new Link(this.vol, this, name)) {\n        this.children.set(name, link);\n        link.parent = this;\n        this.length++;\n        const node = link.getNode();\n        if (node.isDirectory()) {\n            link.children.set('..', this);\n            this.getNode().nlink++;\n        }\n        this.getNode().mtime = new Date();\n        this.emit('child:add', link, this);\n        return link;\n    }\n    deleteChild(link) {\n        const node = link.getNode();\n        if (node.isDirectory()) {\n            link.children.delete('..');\n            this.getNode().nlink--;\n        }\n        this.children.delete(link.getName());\n        this.length--;\n        this.getNode().mtime = new Date();\n        this.emit('child:delete', link, this);\n    }\n    getChild(name) {\n        this.getNode().mtime = new Date();\n        return this.children.get(name);\n    }\n    getPath() {\n        return this.steps.join(exports.SEP);\n    }\n    getParentPath() {\n        return this.steps.slice(0, -1).join(exports.SEP);\n    }\n    getName() {\n        return this.steps[this.steps.length - 1];\n    }\n    // del() {\n    //     const parent = this.parent;\n    //     if(parent) {\n    //         parent.deleteChild(link);\n    //     }\n    //     this.parent = null;\n    //     this.vol = null;\n    // }\n    toJSON() {\n        return {\n            steps: this.steps,\n            ino: this.ino,\n            children: Array.from(this.children.keys()),\n        };\n    }\n    syncSteps() {\n        this.steps = this.parent ? this.parent.steps.concat([this.name]) : [this.name];\n    }\n}\nexports.Link = Link;\n/**\n * Represents an open file (file descriptor) that points to a `Link` (Hard-link) and a `Node`.\n */\nclass File {\n    /**\n     * Open a Link-Node pair. `node` is provided separately as that might be a different node\n     * rather the one `link` points to, because it might be a symlink.\n     * @param link\n     * @param node\n     * @param flags\n     * @param fd\n     */\n    constructor(link, node, flags, fd) {\n        this.link = link;\n        this.node = node;\n        this.flags = flags;\n        this.fd = fd;\n        this.position = 0;\n        if (this.flags & O_APPEND)\n            this.position = this.getSize();\n    }\n    getString(encoding = 'utf8') {\n        return this.node.getString();\n    }\n    setString(str) {\n        this.node.setString(str);\n    }\n    getBuffer() {\n        return this.node.getBuffer();\n    }\n    setBuffer(buf) {\n        this.node.setBuffer(buf);\n    }\n    getSize() {\n        return this.node.getSize();\n    }\n    truncate(len) {\n        this.node.truncate(len);\n    }\n    seekTo(position) {\n        this.position = position;\n    }\n    stats() {\n        return Stats_1.default.build(this.node);\n    }\n    write(buf, offset = 0, length = buf.length, position) {\n        if (typeof position !== 'number')\n            position = this.position;\n        const bytes = this.node.write(buf, offset, length, position);\n        this.position = position + bytes;\n        return bytes;\n    }\n    read(buf, offset = 0, length = buf.byteLength, position) {\n        if (typeof position !== 'number')\n            position = this.position;\n        const bytes = this.node.read(buf, offset, length, position);\n        this.position = position + bytes;\n        return bytes;\n    }\n    chmod(perm) {\n        this.node.chmod(perm);\n    }\n    chown(uid, gid) {\n        this.node.chown(uid, gid);\n    }\n}\nexports.File = File;\n//# sourceMappingURL=node.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/FileHandle.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/FileHandle.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FileHandle = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/util.js\");\nclass FileHandle {\n    constructor(fs, fd) {\n        this.fs = fs;\n        this.fd = fd;\n    }\n    appendFile(data, options) {\n        return (0, util_1.promisify)(this.fs, 'appendFile')(this.fd, data, options);\n    }\n    chmod(mode) {\n        return (0, util_1.promisify)(this.fs, 'fchmod')(this.fd, mode);\n    }\n    chown(uid, gid) {\n        return (0, util_1.promisify)(this.fs, 'fchown')(this.fd, uid, gid);\n    }\n    close() {\n        return (0, util_1.promisify)(this.fs, 'close')(this.fd);\n    }\n    datasync() {\n        return (0, util_1.promisify)(this.fs, 'fdatasync')(this.fd);\n    }\n    readableWebStream(options) {\n        return new ReadableStream({\n            pull: async (controller) => {\n                const data = await this.readFile();\n                controller.enqueue(data);\n                controller.close();\n            },\n        });\n    }\n    read(buffer, offset, length, position) {\n        return (0, util_1.promisify)(this.fs, 'read', bytesRead => ({ bytesRead, buffer }))(this.fd, buffer, offset, length, position);\n    }\n    readv(buffers, position) {\n        return (0, util_1.promisify)(this.fs, 'readv', bytesRead => ({ bytesRead, buffers }))(this.fd, buffers, position);\n    }\n    readFile(options) {\n        return (0, util_1.promisify)(this.fs, 'readFile')(this.fd, options);\n    }\n    stat(options) {\n        return (0, util_1.promisify)(this.fs, 'fstat')(this.fd, options);\n    }\n    sync() {\n        return (0, util_1.promisify)(this.fs, 'fsync')(this.fd);\n    }\n    truncate(len) {\n        return (0, util_1.promisify)(this.fs, 'ftruncate')(this.fd, len);\n    }\n    utimes(atime, mtime) {\n        return (0, util_1.promisify)(this.fs, 'futimes')(this.fd, atime, mtime);\n    }\n    write(buffer, offset, length, position) {\n        return (0, util_1.promisify)(this.fs, 'write', bytesWritten => ({ bytesWritten, buffer }))(this.fd, buffer, offset, length, position);\n    }\n    writev(buffers, position) {\n        return (0, util_1.promisify)(this.fs, 'writev', bytesWritten => ({ bytesWritten, buffers }))(this.fd, buffers, position);\n    }\n    writeFile(data, options) {\n        return (0, util_1.promisify)(this.fs, 'writeFile')(this.fd, data, options);\n    }\n}\nexports.FileHandle = FileHandle;\n//# sourceMappingURL=FileHandle.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/FileHandle.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/FsPromises.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/FsPromises.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FsPromises = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/util.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/constants.js\");\nclass FsPromises {\n    constructor(fs, FileHandle) {\n        this.fs = fs;\n        this.FileHandle = FileHandle;\n        this.constants = constants_1.constants;\n        this.cp = (0, util_1.promisify)(this.fs, 'cp');\n        this.opendir = (0, util_1.promisify)(this.fs, 'opendir');\n        this.statfs = (0, util_1.promisify)(this.fs, 'statfs');\n        this.lutimes = (0, util_1.promisify)(this.fs, 'lutimes');\n        this.access = (0, util_1.promisify)(this.fs, 'access');\n        this.chmod = (0, util_1.promisify)(this.fs, 'chmod');\n        this.chown = (0, util_1.promisify)(this.fs, 'chown');\n        this.copyFile = (0, util_1.promisify)(this.fs, 'copyFile');\n        this.lchmod = (0, util_1.promisify)(this.fs, 'lchmod');\n        this.lchown = (0, util_1.promisify)(this.fs, 'lchown');\n        this.link = (0, util_1.promisify)(this.fs, 'link');\n        this.lstat = (0, util_1.promisify)(this.fs, 'lstat');\n        this.mkdir = (0, util_1.promisify)(this.fs, 'mkdir');\n        this.mkdtemp = (0, util_1.promisify)(this.fs, 'mkdtemp');\n        this.readdir = (0, util_1.promisify)(this.fs, 'readdir');\n        this.readlink = (0, util_1.promisify)(this.fs, 'readlink');\n        this.realpath = (0, util_1.promisify)(this.fs, 'realpath');\n        this.rename = (0, util_1.promisify)(this.fs, 'rename');\n        this.rmdir = (0, util_1.promisify)(this.fs, 'rmdir');\n        this.rm = (0, util_1.promisify)(this.fs, 'rm');\n        this.stat = (0, util_1.promisify)(this.fs, 'stat');\n        this.symlink = (0, util_1.promisify)(this.fs, 'symlink');\n        this.truncate = (0, util_1.promisify)(this.fs, 'truncate');\n        this.unlink = (0, util_1.promisify)(this.fs, 'unlink');\n        this.utimes = (0, util_1.promisify)(this.fs, 'utimes');\n        this.readFile = (id, options) => {\n            return (0, util_1.promisify)(this.fs, 'readFile')(id instanceof this.FileHandle ? id.fd : id, options);\n        };\n        this.appendFile = (path, data, options) => {\n            return (0, util_1.promisify)(this.fs, 'appendFile')(path instanceof this.FileHandle ? path.fd : path, data, options);\n        };\n        this.open = (path, flags = 'r', mode) => {\n            return (0, util_1.promisify)(this.fs, 'open', fd => new this.FileHandle(this.fs, fd))(path, flags, mode);\n        };\n        this.writeFile = (id, data, options) => {\n            const dataPromise = (0, util_1.isReadableStream)(data) ? (0, util_1.streamToBuffer)(data) : Promise.resolve(data);\n            return dataPromise.then(data => (0, util_1.promisify)(this.fs, 'writeFile')(id instanceof this.FileHandle ? id.fd : id, data, options));\n        };\n        this.watch = () => {\n            throw new Error('Not implemented');\n        };\n    }\n}\nexports.FsPromises = FsPromises;\n//# sourceMappingURL=FsPromises.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/FsPromises.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/constants.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/constants.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FLAGS = exports.ERRSTR = void 0;\nconst constants_1 = __webpack_require__(/*! ../constants */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/constants.js\");\nexports.ERRSTR = {\n    PATH_STR: 'path must be a string or Buffer',\n    // FD:             'file descriptor must be a unsigned 32-bit integer',\n    FD: 'fd must be a file descriptor',\n    MODE_INT: 'mode must be an int',\n    CB: 'callback must be a function',\n    UID: 'uid must be an unsigned int',\n    GID: 'gid must be an unsigned int',\n    LEN: 'len must be an integer',\n    ATIME: 'atime must be an integer',\n    MTIME: 'mtime must be an integer',\n    PREFIX: 'filename prefix is required',\n    BUFFER: 'buffer must be an instance of Buffer or StaticBuffer',\n    OFFSET: 'offset must be an integer',\n    LENGTH: 'length must be an integer',\n    POSITION: 'position must be an integer',\n};\nconst { O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_TRUNC, O_APPEND, O_SYNC } = constants_1.constants;\n// List of file `flags` as defined by Node.\nvar FLAGS;\n(function (FLAGS) {\n    // Open file for reading. An exception occurs if the file does not exist.\n    FLAGS[FLAGS[\"r\"] = O_RDONLY] = \"r\";\n    // Open file for reading and writing. An exception occurs if the file does not exist.\n    FLAGS[FLAGS[\"r+\"] = O_RDWR] = \"r+\";\n    // Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.\n    FLAGS[FLAGS[\"rs\"] = O_RDONLY | O_SYNC] = \"rs\";\n    FLAGS[FLAGS[\"sr\"] = FLAGS.rs] = \"sr\";\n    // Open file for reading and writing, telling the OS to open it synchronously. See notes for 'rs' about using this with caution.\n    FLAGS[FLAGS[\"rs+\"] = O_RDWR | O_SYNC] = \"rs+\";\n    FLAGS[FLAGS[\"sr+\"] = FLAGS['rs+']] = \"sr+\";\n    // Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\n    FLAGS[FLAGS[\"w\"] = O_WRONLY | O_CREAT | O_TRUNC] = \"w\";\n    // Like 'w' but fails if path exists.\n    FLAGS[FLAGS[\"wx\"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = \"wx\";\n    FLAGS[FLAGS[\"xw\"] = FLAGS.wx] = \"xw\";\n    // Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\n    FLAGS[FLAGS[\"w+\"] = O_RDWR | O_CREAT | O_TRUNC] = \"w+\";\n    // Like 'w+' but fails if path exists.\n    FLAGS[FLAGS[\"wx+\"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = \"wx+\";\n    FLAGS[FLAGS[\"xw+\"] = FLAGS['wx+']] = \"xw+\";\n    // Open file for appending. The file is created if it does not exist.\n    FLAGS[FLAGS[\"a\"] = O_WRONLY | O_APPEND | O_CREAT] = \"a\";\n    // Like 'a' but fails if path exists.\n    FLAGS[FLAGS[\"ax\"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = \"ax\";\n    FLAGS[FLAGS[\"xa\"] = FLAGS.ax] = \"xa\";\n    // Open file for reading and appending. The file is created if it does not exist.\n    FLAGS[FLAGS[\"a+\"] = O_RDWR | O_APPEND | O_CREAT] = \"a+\";\n    // Like 'a+' but fails if path exists.\n    FLAGS[FLAGS[\"ax+\"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = \"ax+\";\n    FLAGS[FLAGS[\"xa+\"] = FLAGS['ax+']] = \"xa+\";\n})(FLAGS || (exports.FLAGS = FLAGS = {}));\n//# sourceMappingURL=constants.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/constants.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/lists/fsCallbackApiList.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/lists/fsCallbackApiList.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fsCallbackApiList = void 0;\nexports.fsCallbackApiList = [\n    'access',\n    'appendFile',\n    'chmod',\n    'chown',\n    'close',\n    'copyFile',\n    'createReadStream',\n    'createWriteStream',\n    'exists',\n    'fchmod',\n    'fchown',\n    'fdatasync',\n    'fstat',\n    'fsync',\n    'ftruncate',\n    'futimes',\n    'lchmod',\n    'lchown',\n    'link',\n    'lstat',\n    'mkdir',\n    'mkdtemp',\n    'open',\n    'read',\n    'readv',\n    'readdir',\n    'readFile',\n    'readlink',\n    'realpath',\n    'rename',\n    'rm',\n    'rmdir',\n    'stat',\n    'symlink',\n    'truncate',\n    'unlink',\n    'unwatchFile',\n    'utimes',\n    'lutimes',\n    'watch',\n    'watchFile',\n    'write',\n    'writev',\n    'writeFile',\n];\n//# sourceMappingURL=fsCallbackApiList.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/lists/fsCallbackApiList.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/lists/fsSynchronousApiList.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/lists/fsSynchronousApiList.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fsSynchronousApiList = void 0;\nexports.fsSynchronousApiList = [\n    'accessSync',\n    'appendFileSync',\n    'chmodSync',\n    'chownSync',\n    'closeSync',\n    'copyFileSync',\n    'existsSync',\n    'fchmodSync',\n    'fchownSync',\n    'fdatasyncSync',\n    'fstatSync',\n    'fsyncSync',\n    'ftruncateSync',\n    'futimesSync',\n    'lchmodSync',\n    'lchownSync',\n    'linkSync',\n    'lstatSync',\n    'mkdirSync',\n    'mkdtempSync',\n    'openSync',\n    'readdirSync',\n    'readFileSync',\n    'readlinkSync',\n    'readSync',\n    'readvSync',\n    'realpathSync',\n    'renameSync',\n    'rmdirSync',\n    'rmSync',\n    'statSync',\n    'symlinkSync',\n    'truncateSync',\n    'unlinkSync',\n    'utimesSync',\n    'lutimesSync',\n    'writeFileSync',\n    'writeSync',\n    'writevSync',\n    // 'cpSync',\n    // 'statfsSync',\n];\n//# sourceMappingURL=fsSynchronousApiList.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/lists/fsSynchronousApiList.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/options.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/options.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getWriteFileOptions = exports.writeFileDefaults = exports.getRealpathOptsAndCb = exports.getRealpathOptions = exports.getStatOptsAndCb = exports.getStatOptions = exports.getAppendFileOptsAndCb = exports.getAppendFileOpts = exports.getOpendirOptsAndCb = exports.getOpendirOptions = exports.getReaddirOptsAndCb = exports.getReaddirOptions = exports.getReadFileOptions = exports.getRmOptsAndCb = exports.getRmdirOptions = exports.getDefaultOptsAndCb = exports.getDefaultOpts = exports.optsDefaults = exports.getMkdirOptions = void 0;\nexports.getOptions = getOptions;\nexports.optsGenerator = optsGenerator;\nexports.optsAndCbGenerator = optsAndCbGenerator;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/constants.js\");\nconst encoding_1 = __webpack_require__(/*! ../encoding */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/encoding.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/util.js\");\nconst mkdirDefaults = {\n    mode: 511 /* MODE.DIR */,\n    recursive: false,\n};\nconst getMkdirOptions = (options) => {\n    if (typeof options === 'number')\n        return Object.assign({}, mkdirDefaults, { mode: options });\n    return Object.assign({}, mkdirDefaults, options);\n};\nexports.getMkdirOptions = getMkdirOptions;\nconst ERRSTR_OPTS = tipeof => `Expected options to be either an object or a string, but got ${tipeof} instead`;\nfunction getOptions(defaults, options) {\n    let opts;\n    if (!options)\n        return defaults;\n    else {\n        const tipeof = typeof options;\n        switch (tipeof) {\n            case 'string':\n                opts = Object.assign({}, defaults, { encoding: options });\n                break;\n            case 'object':\n                opts = Object.assign({}, defaults, options);\n                break;\n            default:\n                throw TypeError(ERRSTR_OPTS(tipeof));\n        }\n    }\n    if (opts.encoding !== 'buffer')\n        (0, encoding_1.assertEncoding)(opts.encoding);\n    return opts;\n}\nfunction optsGenerator(defaults) {\n    return options => getOptions(defaults, options);\n}\nfunction optsAndCbGenerator(getOpts) {\n    return (options, callback) => typeof options === 'function' ? [getOpts(), options] : [getOpts(options), (0, util_1.validateCallback)(callback)];\n}\nexports.optsDefaults = {\n    encoding: 'utf8',\n};\nexports.getDefaultOpts = optsGenerator(exports.optsDefaults);\nexports.getDefaultOptsAndCb = optsAndCbGenerator(exports.getDefaultOpts);\nconst rmdirDefaults = {\n    recursive: false,\n};\nconst getRmdirOptions = (options) => {\n    return Object.assign({}, rmdirDefaults, options);\n};\nexports.getRmdirOptions = getRmdirOptions;\nconst getRmOpts = optsGenerator(exports.optsDefaults);\nexports.getRmOptsAndCb = optsAndCbGenerator(getRmOpts);\nconst readFileOptsDefaults = {\n    flag: 'r',\n};\nexports.getReadFileOptions = optsGenerator(readFileOptsDefaults);\nconst readdirDefaults = {\n    encoding: 'utf8',\n    recursive: false,\n    withFileTypes: false,\n};\nexports.getReaddirOptions = optsGenerator(readdirDefaults);\nexports.getReaddirOptsAndCb = optsAndCbGenerator(exports.getReaddirOptions);\nconst opendirDefaults = {\n    encoding: 'utf8',\n    bufferSize: 32,\n    recursive: false,\n};\nexports.getOpendirOptions = optsGenerator(opendirDefaults);\nexports.getOpendirOptsAndCb = optsAndCbGenerator(exports.getOpendirOptions);\nconst appendFileDefaults = {\n    encoding: 'utf8',\n    mode: 438 /* MODE.DEFAULT */,\n    flag: constants_1.FLAGS[constants_1.FLAGS.a],\n};\nexports.getAppendFileOpts = optsGenerator(appendFileDefaults);\nexports.getAppendFileOptsAndCb = optsAndCbGenerator(exports.getAppendFileOpts);\nconst statDefaults = {\n    bigint: false,\n};\nconst getStatOptions = (options = {}) => Object.assign({}, statDefaults, options);\nexports.getStatOptions = getStatOptions;\nconst getStatOptsAndCb = (options, callback) => typeof options === 'function' ? [(0, exports.getStatOptions)(), options] : [(0, exports.getStatOptions)(options), (0, util_1.validateCallback)(callback)];\nexports.getStatOptsAndCb = getStatOptsAndCb;\nconst realpathDefaults = exports.optsDefaults;\nexports.getRealpathOptions = optsGenerator(realpathDefaults);\nexports.getRealpathOptsAndCb = optsAndCbGenerator(exports.getRealpathOptions);\nexports.writeFileDefaults = {\n    encoding: 'utf8',\n    mode: 438 /* MODE.DEFAULT */,\n    flag: constants_1.FLAGS[constants_1.FLAGS.w],\n};\nexports.getWriteFileOptions = optsGenerator(exports.writeFileDefaults);\n//# sourceMappingURL=options.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/options.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/util.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/util.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unixify = exports.getWriteSyncArgs = exports.getWriteArgs = exports.bufToUint8 = exports.isWin = void 0;\nexports.promisify = promisify;\nexports.validateCallback = validateCallback;\nexports.modeToNumber = modeToNumber;\nexports.nullCheck = nullCheck;\nexports.pathToFilename = pathToFilename;\nexports.createError = createError;\nexports.genRndStr6 = genRndStr6;\nexports.flagsToNumber = flagsToNumber;\nexports.isFd = isFd;\nexports.validateFd = validateFd;\nexports.streamToBuffer = streamToBuffer;\nexports.dataToBuffer = dataToBuffer;\nexports.bufferToEncoding = bufferToEncoding;\nexports.isReadableStream = isReadableStream;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/constants.js\");\nconst errors = __webpack_require__(/*! ../internal/errors */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/errors.js\");\nconst buffer_1 = __webpack_require__(/*! ../internal/buffer */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/buffer.js\");\nconst encoding_1 = __webpack_require__(/*! ../encoding */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/encoding.js\");\nconst buffer_2 = __webpack_require__(/*! ../internal/buffer */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/buffer.js\");\nconst queueMicrotask_1 = __webpack_require__(/*! ../queueMicrotask */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/queueMicrotask.js\");\nexports.isWin = process.platform === 'win32';\nfunction promisify(fs, fn, getResult = input => input) {\n    return (...args) => new Promise((resolve, reject) => {\n        fs[fn].bind(fs)(...args, (error, result) => {\n            if (error)\n                return reject(error);\n            return resolve(getResult(result));\n        });\n    });\n}\nfunction validateCallback(callback) {\n    if (typeof callback !== 'function')\n        throw TypeError(constants_1.ERRSTR.CB);\n    return callback;\n}\nfunction _modeToNumber(mode, def) {\n    if (typeof mode === 'number')\n        return mode;\n    if (typeof mode === 'string')\n        return parseInt(mode, 8);\n    if (def)\n        return modeToNumber(def);\n    return undefined;\n}\nfunction modeToNumber(mode, def) {\n    const result = _modeToNumber(mode, def);\n    if (typeof result !== 'number' || isNaN(result))\n        throw new TypeError(constants_1.ERRSTR.MODE_INT);\n    return result;\n}\nfunction nullCheck(path, callback) {\n    if (('' + path).indexOf('\\u0000') !== -1) {\n        const er = new Error('Path must be a string without null bytes');\n        er.code = 'ENOENT';\n        if (typeof callback !== 'function')\n            throw er;\n        (0, queueMicrotask_1.default)(() => {\n            callback(er);\n        });\n        return false;\n    }\n    return true;\n}\nfunction getPathFromURLPosix(url) {\n    if (url.hostname !== '') {\n        throw new errors.TypeError('ERR_INVALID_FILE_URL_HOST', process.platform);\n    }\n    const pathname = url.pathname;\n    for (let n = 0; n < pathname.length; n++) {\n        if (pathname[n] === '%') {\n            const third = pathname.codePointAt(n + 2) | 0x20;\n            if (pathname[n + 1] === '2' && third === 102) {\n                throw new errors.TypeError('ERR_INVALID_FILE_URL_PATH', 'must not include encoded / characters');\n            }\n        }\n    }\n    return decodeURIComponent(pathname);\n}\nfunction pathToFilename(path) {\n    if (typeof path !== 'string' && !buffer_1.Buffer.isBuffer(path)) {\n        try {\n            if (!(path instanceof (__webpack_require__(/*! url */ \"url\").URL)))\n                throw new TypeError(constants_1.ERRSTR.PATH_STR);\n        }\n        catch (err) {\n            throw new TypeError(constants_1.ERRSTR.PATH_STR);\n        }\n        path = getPathFromURLPosix(path);\n    }\n    const pathString = String(path);\n    nullCheck(pathString);\n    // return slash(pathString);\n    return pathString;\n}\nconst ENOENT = 'ENOENT';\nconst EBADF = 'EBADF';\nconst EINVAL = 'EINVAL';\nconst EPERM = 'EPERM';\nconst EPROTO = 'EPROTO';\nconst EEXIST = 'EEXIST';\nconst ENOTDIR = 'ENOTDIR';\nconst EMFILE = 'EMFILE';\nconst EACCES = 'EACCES';\nconst EISDIR = 'EISDIR';\nconst ENOTEMPTY = 'ENOTEMPTY';\nconst ENOSYS = 'ENOSYS';\nconst ERR_FS_EISDIR = 'ERR_FS_EISDIR';\nconst ERR_OUT_OF_RANGE = 'ERR_OUT_OF_RANGE';\nfunction formatError(errorCode, func = '', path = '', path2 = '') {\n    let pathFormatted = '';\n    if (path)\n        pathFormatted = ` '${path}'`;\n    if (path2)\n        pathFormatted += ` -> '${path2}'`;\n    switch (errorCode) {\n        case ENOENT:\n            return `ENOENT: no such file or directory, ${func}${pathFormatted}`;\n        case EBADF:\n            return `EBADF: bad file descriptor, ${func}${pathFormatted}`;\n        case EINVAL:\n            return `EINVAL: invalid argument, ${func}${pathFormatted}`;\n        case EPERM:\n            return `EPERM: operation not permitted, ${func}${pathFormatted}`;\n        case EPROTO:\n            return `EPROTO: protocol error, ${func}${pathFormatted}`;\n        case EEXIST:\n            return `EEXIST: file already exists, ${func}${pathFormatted}`;\n        case ENOTDIR:\n            return `ENOTDIR: not a directory, ${func}${pathFormatted}`;\n        case EISDIR:\n            return `EISDIR: illegal operation on a directory, ${func}${pathFormatted}`;\n        case EACCES:\n            return `EACCES: permission denied, ${func}${pathFormatted}`;\n        case ENOTEMPTY:\n            return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;\n        case EMFILE:\n            return `EMFILE: too many open files, ${func}${pathFormatted}`;\n        case ENOSYS:\n            return `ENOSYS: function not implemented, ${func}${pathFormatted}`;\n        case ERR_FS_EISDIR:\n            return `[ERR_FS_EISDIR]: Path is a directory: ${func} returned EISDIR (is a directory) ${path}`;\n        case ERR_OUT_OF_RANGE:\n            return `[ERR_OUT_OF_RANGE]: value out of range, ${func}${pathFormatted}`;\n        default:\n            return `${errorCode}: error occurred, ${func}${pathFormatted}`;\n    }\n}\nfunction createError(errorCode, func = '', path = '', path2 = '', Constructor = Error) {\n    const error = new Constructor(formatError(errorCode, func, path, path2));\n    error.code = errorCode;\n    if (path) {\n        error.path = path;\n    }\n    return error;\n}\nfunction genRndStr6() {\n    const str = (Math.random() + 1).toString(36).substring(2, 8);\n    if (str.length === 6)\n        return str;\n    else\n        return genRndStr6();\n}\nfunction flagsToNumber(flags) {\n    if (typeof flags === 'number')\n        return flags;\n    if (typeof flags === 'string') {\n        const flagsNum = constants_1.FLAGS[flags];\n        if (typeof flagsNum !== 'undefined')\n            return flagsNum;\n    }\n    // throw new TypeError(formatError(ERRSTR_FLAG(flags)));\n    throw new errors.TypeError('ERR_INVALID_OPT_VALUE', 'flags', flags);\n}\nfunction isFd(path) {\n    return path >>> 0 === path;\n}\nfunction validateFd(fd) {\n    if (!isFd(fd))\n        throw TypeError(constants_1.ERRSTR.FD);\n}\nfunction streamToBuffer(stream) {\n    const chunks = [];\n    return new Promise((resolve, reject) => {\n        stream.on('data', chunk => chunks.push(chunk));\n        stream.on('end', () => resolve(buffer_1.Buffer.concat(chunks)));\n        stream.on('error', reject);\n    });\n}\nfunction dataToBuffer(data, encoding = encoding_1.ENCODING_UTF8) {\n    if (buffer_1.Buffer.isBuffer(data))\n        return data;\n    else if (data instanceof Uint8Array)\n        return (0, buffer_2.bufferFrom)(data);\n    else\n        return (0, buffer_2.bufferFrom)(String(data), encoding);\n}\nconst bufToUint8 = (buf) => new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\nexports.bufToUint8 = bufToUint8;\nconst getWriteArgs = (fd, a, b, c, d, e) => {\n    validateFd(fd);\n    let offset = 0;\n    let length;\n    let position = null;\n    let encoding;\n    let callback;\n    const tipa = typeof a;\n    const tipb = typeof b;\n    const tipc = typeof c;\n    const tipd = typeof d;\n    if (tipa !== 'string') {\n        if (tipb === 'function') {\n            callback = b;\n        }\n        else if (tipc === 'function') {\n            offset = b | 0;\n            callback = c;\n        }\n        else if (tipd === 'function') {\n            offset = b | 0;\n            length = c;\n            callback = d;\n        }\n        else {\n            offset = b | 0;\n            length = c;\n            position = d;\n            callback = e;\n        }\n    }\n    else {\n        if (tipb === 'function') {\n            callback = b;\n        }\n        else if (tipc === 'function') {\n            position = b;\n            callback = c;\n        }\n        else if (tipd === 'function') {\n            position = b;\n            encoding = c;\n            callback = d;\n        }\n    }\n    const buf = dataToBuffer(a, encoding);\n    if (tipa !== 'string') {\n        if (typeof length === 'undefined')\n            length = buf.length;\n    }\n    else {\n        offset = 0;\n        length = buf.length;\n    }\n    const cb = validateCallback(callback);\n    return [fd, tipa === 'string', buf, offset, length, position, cb];\n};\nexports.getWriteArgs = getWriteArgs;\nconst getWriteSyncArgs = (fd, a, b, c, d) => {\n    validateFd(fd);\n    let encoding;\n    let offset;\n    let length;\n    let position;\n    const isBuffer = typeof a !== 'string';\n    if (isBuffer) {\n        offset = (b || 0) | 0;\n        length = c;\n        position = d;\n    }\n    else {\n        position = b;\n        encoding = c;\n    }\n    const buf = dataToBuffer(a, encoding);\n    if (isBuffer) {\n        if (typeof length === 'undefined') {\n            length = buf.length;\n        }\n    }\n    else {\n        offset = 0;\n        length = buf.length;\n    }\n    return [fd, buf, offset || 0, length, position];\n};\nexports.getWriteSyncArgs = getWriteSyncArgs;\nfunction bufferToEncoding(buffer, encoding) {\n    if (!encoding || encoding === 'buffer')\n        return buffer;\n    else\n        return buffer.toString(encoding);\n}\nfunction isReadableStream(stream) {\n    return (stream !== null &&\n        typeof stream === 'object' &&\n        typeof stream.pipe === 'function' &&\n        typeof stream.on === 'function' &&\n        stream.readable === true);\n}\nconst isSeparator = (str, i) => {\n    let char = str[i];\n    return i > 0 && (char === '/' || (exports.isWin && char === '\\\\'));\n};\nconst removeTrailingSeparator = (str) => {\n    let i = str.length - 1;\n    if (i < 2)\n        return str;\n    while (isSeparator(str, i))\n        i--;\n    return str.substr(0, i + 1);\n};\nconst normalizePath = (str, stripTrailing) => {\n    if (typeof str !== 'string')\n        throw new TypeError('expected a string');\n    str = str.replace(/[\\\\\\/]+/g, '/');\n    if (stripTrailing !== false)\n        str = removeTrailingSeparator(str);\n    return str;\n};\nconst unixify = (filepath, stripTrailing = true) => {\n    if (exports.isWin) {\n        filepath = normalizePath(filepath, stripTrailing);\n        return filepath.replace(/^([a-zA-Z]+:|\\.\\/)/, '');\n    }\n    return filepath;\n};\nexports.unixify = unixify;\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/util.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/print/index.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/print/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toTreeSync = void 0;\nconst tree_dump_1 = __webpack_require__(/*! tree-dump */ \"../../node_modules/.pnpm/tree-dump@1.0.2_tslib@2.8.1/node_modules/tree-dump/lib/index.js\");\nconst util_1 = __webpack_require__(/*! ../node-to-fsa/util */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node-to-fsa/util.js\");\nconst toTreeSync = (fs, opts = {}) => {\n    var _a;\n    const separator = opts.separator || '/';\n    let dir = opts.dir || separator;\n    if (dir[dir.length - 1] !== separator)\n        dir += separator;\n    const tab = opts.tab || '';\n    const depth = (_a = opts.depth) !== null && _a !== void 0 ? _a : 10;\n    let subtree = ' (...)';\n    if (depth > 0) {\n        const list = fs.readdirSync(dir, { withFileTypes: true });\n        subtree = (0, tree_dump_1.printTree)(tab, list.map(entry => tab => {\n            if (entry.isDirectory()) {\n                return (0, exports.toTreeSync)(fs, { dir: dir + entry.name, depth: depth - 1, tab });\n            }\n            else if (entry.isSymbolicLink()) {\n                return '' + entry.name + '  ' + fs.readlinkSync(dir + entry.name);\n            }\n            else {\n                return '' + entry.name;\n            }\n        }));\n    }\n    const base = (0, util_1.basename)(dir, separator) + separator;\n    return base + subtree;\n};\nexports.toTreeSync = toTreeSync;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/print/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/process.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/process.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Here we mock the global `process` variable in case we are not in Node's environment.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createProcess = createProcess;\n/**\n * Looks to return a `process` object, if one is available.\n *\n * The global `process` is returned if defined;\n * otherwise `require('process')` is attempted.\n *\n * If that fails, `undefined` is returned.\n *\n * @return {IProcess | undefined}\n */\nconst maybeReturnProcess = () => {\n    if (typeof process !== 'undefined') {\n        return process;\n    }\n    try {\n        return __webpack_require__(/*! process */ \"process\");\n    }\n    catch (_a) {\n        return undefined;\n    }\n};\nfunction createProcess() {\n    const p = maybeReturnProcess() || {};\n    if (!p.cwd)\n        p.cwd = () => '/';\n    if (!p.emitWarning)\n        p.emitWarning = (message, type) => {\n            // tslint:disable-next-line:no-console\n            console.warn(`${type}${type ? ': ' : ''}${message}`);\n        };\n    if (!p.env)\n        p.env = {};\n    return p;\n}\nexports[\"default\"] = createProcess();\n//# sourceMappingURL=process.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/process.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/queueMicrotask.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/queueMicrotask.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = typeof queueMicrotask === 'function' ? queueMicrotask : (cb => Promise.resolve()\n    .then(() => cb())\n    .catch(() => { }));\n//# sourceMappingURL=queueMicrotask.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/queueMicrotask.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/setImmediate.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/setImmediate.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nlet _setImmediate;\nif (typeof setImmediate === 'function')\n    _setImmediate = setImmediate.bind(typeof globalThis !== 'undefined' ? globalThis : global);\nelse\n    _setImmediate = setTimeout.bind(typeof globalThis !== 'undefined' ? globalThis : global);\nexports[\"default\"] = _setImmediate;\n//# sourceMappingURL=setImmediate.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/setImmediate.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/setTimeoutUnref.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/setTimeoutUnref.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * `setTimeoutUnref` is just like `setTimeout`,\n * only in Node's environment it will \"unref\" its macro task.\n */\nfunction setTimeoutUnref(callback, time, args) {\n    const ref = setTimeout.apply(typeof globalThis !== 'undefined' ? globalThis : global, arguments);\n    if (ref && typeof ref === 'object' && typeof ref.unref === 'function')\n        ref.unref();\n    return ref;\n}\nexports[\"default\"] = setTimeoutUnref;\n//# sourceMappingURL=setTimeoutUnref.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/setTimeoutUnref.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/volume.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/volume.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FSWatcher = exports.StatWatcher = exports.Volume = void 0;\nexports.filenameToSteps = filenameToSteps;\nexports.pathToSteps = pathToSteps;\nexports.dataToStr = dataToStr;\nexports.toUnixTimestamp = toUnixTimestamp;\nconst pathModule = __webpack_require__(/*! path */ \"path\");\nconst node_1 = __webpack_require__(/*! ./node */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node.js\");\nconst Stats_1 = __webpack_require__(/*! ./Stats */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Stats.js\");\nconst Dirent_1 = __webpack_require__(/*! ./Dirent */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Dirent.js\");\nconst buffer_1 = __webpack_require__(/*! ./internal/buffer */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/internal/buffer.js\");\nconst setImmediate_1 = __webpack_require__(/*! ./setImmediate */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/setImmediate.js\");\nconst queueMicrotask_1 = __webpack_require__(/*! ./queueMicrotask */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/queueMicrotask.js\");\nconst process_1 = __webpack_require__(/*! ./process */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/process.js\");\nconst setTimeoutUnref_1 = __webpack_require__(/*! ./setTimeoutUnref */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/setTimeoutUnref.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/constants.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst encoding_1 = __webpack_require__(/*! ./encoding */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/encoding.js\");\nconst FileHandle_1 = __webpack_require__(/*! ./node/FileHandle */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/FileHandle.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst FsPromises_1 = __webpack_require__(/*! ./node/FsPromises */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/FsPromises.js\");\nconst print_1 = __webpack_require__(/*! ./print */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/print/index.js\");\nconst constants_2 = __webpack_require__(/*! ./node/constants */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/constants.js\");\nconst options_1 = __webpack_require__(/*! ./node/options */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/options.js\");\nconst util_1 = __webpack_require__(/*! ./node/util */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/node/util.js\");\nconst Dir_1 = __webpack_require__(/*! ./Dir */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/Dir.js\");\nconst resolveCrossPlatform = pathModule.resolve;\nconst { O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_TRUNC, O_APPEND, O_DIRECTORY, O_SYMLINK, F_OK, COPYFILE_EXCL, COPYFILE_FICLONE_FORCE, } = constants_1.constants;\nconst { sep, relative, join, dirname } = pathModule.posix ? pathModule.posix : pathModule;\n// ---------------------------------------- Constants\nconst kMinPoolSpace = 128;\n// ---------------------------------------- Error messages\nconst EPERM = 'EPERM';\nconst ENOENT = 'ENOENT';\nconst EBADF = 'EBADF';\nconst EINVAL = 'EINVAL';\nconst EEXIST = 'EEXIST';\nconst ENOTDIR = 'ENOTDIR';\nconst EMFILE = 'EMFILE';\nconst EACCES = 'EACCES';\nconst EISDIR = 'EISDIR';\nconst ENOTEMPTY = 'ENOTEMPTY';\nconst ENOSYS = 'ENOSYS';\nconst ERR_FS_EISDIR = 'ERR_FS_EISDIR';\nconst ERR_OUT_OF_RANGE = 'ERR_OUT_OF_RANGE';\nlet resolve = (filename, base = process_1.default.cwd()) => resolveCrossPlatform(base, filename);\nif (util_1.isWin) {\n    const _resolve = resolve;\n    resolve = (filename, base) => (0, util_1.unixify)(_resolve(filename, base));\n}\nfunction filenameToSteps(filename, base) {\n    const fullPath = resolve(filename, base);\n    const fullPathSansSlash = fullPath.substring(1);\n    if (!fullPathSansSlash)\n        return [];\n    return fullPathSansSlash.split(sep);\n}\nfunction pathToSteps(path) {\n    return filenameToSteps((0, util_1.pathToFilename)(path));\n}\nfunction dataToStr(data, encoding = encoding_1.ENCODING_UTF8) {\n    if (buffer_1.Buffer.isBuffer(data))\n        return data.toString(encoding);\n    else if (data instanceof Uint8Array)\n        return (0, buffer_1.bufferFrom)(data).toString(encoding);\n    else\n        return String(data);\n}\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time) {\n    // tslint:disable-next-line triple-equals\n    if (typeof time === 'string' && +time == time) {\n        return +time;\n    }\n    if (time instanceof Date) {\n        return time.getTime() / 1000;\n    }\n    if (isFinite(time)) {\n        if (time < 0) {\n            return Date.now() / 1000;\n        }\n        return time;\n    }\n    throw new Error('Cannot parse time: ' + time);\n}\nfunction validateUid(uid) {\n    if (typeof uid !== 'number')\n        throw TypeError(constants_2.ERRSTR.UID);\n}\nfunction validateGid(gid) {\n    if (typeof gid !== 'number')\n        throw TypeError(constants_2.ERRSTR.GID);\n}\nfunction flattenJSON(nestedJSON) {\n    const flatJSON = {};\n    function flatten(pathPrefix, node) {\n        for (const path in node) {\n            const contentOrNode = node[path];\n            const joinedPath = join(pathPrefix, path);\n            if (typeof contentOrNode === 'string' || contentOrNode instanceof buffer_1.Buffer) {\n                flatJSON[joinedPath] = contentOrNode;\n            }\n            else if (typeof contentOrNode === 'object' && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {\n                // empty directories need an explicit entry and therefore get handled in `else`, non-empty ones are implicitly considered\n                flatten(joinedPath, contentOrNode);\n            }\n            else {\n                // without this branch null, empty-object or non-object entries would not be handled in the same way\n                // by both fromJSON() and fromNestedJSON()\n                flatJSON[joinedPath] = null;\n            }\n        }\n    }\n    flatten('', nestedJSON);\n    return flatJSON;\n}\nconst notImplemented = () => {\n    throw new Error('Not implemented');\n};\n/**\n * `Volume` represents a file system.\n */\nclass Volume {\n    static fromJSON(json, cwd) {\n        const vol = new Volume();\n        vol.fromJSON(json, cwd);\n        return vol;\n    }\n    static fromNestedJSON(json, cwd) {\n        const vol = new Volume();\n        vol.fromNestedJSON(json, cwd);\n        return vol;\n    }\n    get promises() {\n        if (this.promisesApi === null)\n            throw new Error('Promise is not supported in this environment.');\n        return this.promisesApi;\n    }\n    constructor(props = {}) {\n        // I-node number counter.\n        this.ino = 0;\n        // A mapping for i-node numbers to i-nodes (`Node`);\n        this.inodes = {};\n        // List of released i-node numbers, for reuse.\n        this.releasedInos = [];\n        // A mapping for file descriptors to `File`s.\n        this.fds = {};\n        // A list of reusable (opened and closed) file descriptors, that should be\n        // used first before creating a new file descriptor.\n        this.releasedFds = [];\n        // Max number of open files.\n        this.maxFiles = 10000;\n        // Current number of open files.\n        this.openFiles = 0;\n        this.promisesApi = new FsPromises_1.FsPromises(this, FileHandle_1.FileHandle);\n        this.statWatchers = {};\n        this.cpSync = notImplemented;\n        this.statfsSync = notImplemented;\n        this.cp = notImplemented;\n        this.statfs = notImplemented;\n        this.openAsBlob = notImplemented;\n        this.props = Object.assign({ Node: node_1.Node, Link: node_1.Link, File: node_1.File }, props);\n        const root = this.createLink();\n        root.setNode(this.createNode(true));\n        const self = this; // tslint:disable-line no-this-assignment\n        this.StatWatcher = class extends StatWatcher {\n            constructor() {\n                super(self);\n            }\n        };\n        const _ReadStream = FsReadStream;\n        this.ReadStream = class extends _ReadStream {\n            constructor(...args) {\n                super(self, ...args);\n            }\n        };\n        const _WriteStream = FsWriteStream;\n        this.WriteStream = class extends _WriteStream {\n            constructor(...args) {\n                super(self, ...args);\n            }\n        };\n        this.FSWatcher = class extends FSWatcher {\n            constructor() {\n                super(self);\n            }\n        };\n        root.setChild('.', root);\n        root.getNode().nlink++;\n        root.setChild('..', root);\n        root.getNode().nlink++;\n        this.root = root;\n    }\n    createLink(parent, name, isDirectory = false, perm) {\n        if (!parent) {\n            return new this.props.Link(this, null, '');\n        }\n        if (!name) {\n            throw new Error('createLink: name cannot be empty');\n        }\n        return parent.createChild(name, this.createNode(isDirectory, perm));\n    }\n    deleteLink(link) {\n        const parent = link.parent;\n        if (parent) {\n            parent.deleteChild(link);\n            return true;\n        }\n        return false;\n    }\n    newInoNumber() {\n        const releasedFd = this.releasedInos.pop();\n        if (releasedFd)\n            return releasedFd;\n        else {\n            this.ino = (this.ino + 1) % 0xffffffff;\n            return this.ino;\n        }\n    }\n    newFdNumber() {\n        const releasedFd = this.releasedFds.pop();\n        return typeof releasedFd === 'number' ? releasedFd : Volume.fd--;\n    }\n    createNode(isDirectory = false, perm) {\n        perm !== null && perm !== void 0 ? perm : (perm = isDirectory ? 0o777 : 0o666);\n        const node = new this.props.Node(this.newInoNumber(), perm);\n        if (isDirectory)\n            node.setIsDirectory();\n        this.inodes[node.ino] = node;\n        return node;\n    }\n    deleteNode(node) {\n        node.del();\n        delete this.inodes[node.ino];\n        this.releasedInos.push(node.ino);\n    }\n    walk(stepsOrFilenameOrLink, resolveSymlinks = false, checkExistence = false, checkAccess = false, funcName) {\n        var _a;\n        let steps;\n        let filename;\n        if (stepsOrFilenameOrLink instanceof node_1.Link) {\n            steps = stepsOrFilenameOrLink.steps;\n            filename = sep + steps.join(sep);\n        }\n        else if (typeof stepsOrFilenameOrLink === 'string') {\n            steps = filenameToSteps(stepsOrFilenameOrLink);\n            filename = stepsOrFilenameOrLink;\n        }\n        else {\n            steps = stepsOrFilenameOrLink;\n            filename = sep + steps.join(sep);\n        }\n        let curr = this.root;\n        let i = 0;\n        while (i < steps.length) {\n            let node = curr.getNode();\n            // Check access permissions if current link is a directory\n            if (node.isDirectory()) {\n                if (checkAccess && !node.canExecute()) {\n                    throw (0, util_1.createError)(EACCES, funcName, filename);\n                }\n            }\n            else {\n                if (i < steps.length - 1)\n                    throw (0, util_1.createError)(ENOTDIR, funcName, filename);\n            }\n            curr = (_a = curr.getChild(steps[i])) !== null && _a !== void 0 ? _a : null;\n            // Check existence of current link\n            if (!curr)\n                if (checkExistence)\n                    throw (0, util_1.createError)(ENOENT, funcName, filename);\n                else\n                    return null;\n            node = curr === null || curr === void 0 ? void 0 : curr.getNode();\n            // Resolve symlink\n            if (resolveSymlinks && node.isSymlink()) {\n                steps = node.symlink.concat(steps.slice(i + 1));\n                curr = this.root;\n                i = 0;\n                continue;\n            }\n            i++;\n        }\n        return curr;\n    }\n    // Returns a `Link` (hard link) referenced by path \"split\" into steps.\n    getLink(steps) {\n        return this.walk(steps, false, false, false);\n    }\n    // Just link `getLink`, but throws a correct user error, if link to found.\n    getLinkOrThrow(filename, funcName) {\n        return this.walk(filename, false, true, true, funcName);\n    }\n    // Just like `getLink`, but also dereference/resolves symbolic links.\n    getResolvedLink(filenameOrSteps) {\n        return this.walk(filenameOrSteps, true, false, false);\n    }\n    // Just like `getLinkOrThrow`, but also dereference/resolves symbolic links.\n    getResolvedLinkOrThrow(filename, funcName) {\n        return this.walk(filename, true, true, true, funcName);\n    }\n    resolveSymlinks(link) {\n        return this.getResolvedLink(link.steps.slice(1));\n    }\n    // Just like `getLinkOrThrow`, but also verifies that the link is a directory.\n    getLinkAsDirOrThrow(filename, funcName) {\n        const link = this.getLinkOrThrow(filename, funcName);\n        if (!link.getNode().isDirectory())\n            throw (0, util_1.createError)(ENOTDIR, funcName, filename);\n        return link;\n    }\n    // Get the immediate parent directory of the link.\n    getLinkParent(steps) {\n        return this.getLink(steps.slice(0, -1));\n    }\n    getLinkParentAsDirOrThrow(filenameOrSteps, funcName) {\n        const steps = (filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps)).slice(0, -1);\n        const filename = sep + steps.join(sep);\n        const link = this.getLinkOrThrow(filename, funcName);\n        if (!link.getNode().isDirectory())\n            throw (0, util_1.createError)(ENOTDIR, funcName, filename);\n        return link;\n    }\n    getFileByFd(fd) {\n        return this.fds[String(fd)];\n    }\n    getFileByFdOrThrow(fd, funcName) {\n        if (!(0, util_1.isFd)(fd))\n            throw TypeError(constants_2.ERRSTR.FD);\n        const file = this.getFileByFd(fd);\n        if (!file)\n            throw (0, util_1.createError)(EBADF, funcName);\n        return file;\n    }\n    /**\n     * @todo This is not used anymore. Remove.\n     */\n    /*\n    private getNodeByIdOrCreate(id: TFileId, flags: number, perm: number): Node {\n      if (typeof id === 'number') {\n        const file = this.getFileByFd(id);\n        if (!file) throw Error('File nto found');\n        return file.node;\n      } else {\n        const steps = pathToSteps(id as PathLike);\n        let link = this.getLink(steps);\n        if (link) return link.getNode();\n  \n        // Try creating a node if not found.\n        if (flags & O_CREAT) {\n          const dirLink = this.getLinkParent(steps);\n          if (dirLink) {\n            const name = steps[steps.length - 1];\n            link = this.createLink(dirLink, name, false, perm);\n            return link.getNode();\n          }\n        }\n  \n        throw createError(ENOENT, 'getNodeByIdOrCreate', pathToFilename(id));\n      }\n    }\n    */\n    wrapAsync(method, args, callback) {\n        (0, util_1.validateCallback)(callback);\n        (0, setImmediate_1.default)(() => {\n            let result;\n            try {\n                result = method.apply(this, args);\n            }\n            catch (err) {\n                callback(err);\n                return;\n            }\n            callback(null, result);\n        });\n    }\n    _toJSON(link = this.root, json = {}, path, asBuffer) {\n        let isEmpty = true;\n        let children = link.children;\n        if (link.getNode().isFile()) {\n            children = new Map([[link.getName(), link.parent.getChild(link.getName())]]);\n            link = link.parent;\n        }\n        for (const name of children.keys()) {\n            if (name === '.' || name === '..') {\n                continue;\n            }\n            isEmpty = false;\n            const child = link.getChild(name);\n            if (!child) {\n                throw new Error('_toJSON: unexpected undefined');\n            }\n            const node = child.getNode();\n            if (node.isFile()) {\n                let filename = child.getPath();\n                if (path)\n                    filename = relative(path, filename);\n                json[filename] = asBuffer ? node.getBuffer() : node.getString();\n            }\n            else if (node.isDirectory()) {\n                this._toJSON(child, json, path, asBuffer);\n            }\n        }\n        let dirPath = link.getPath();\n        if (path)\n            dirPath = relative(path, dirPath);\n        if (dirPath && isEmpty) {\n            json[dirPath] = null;\n        }\n        return json;\n    }\n    toJSON(paths, json = {}, isRelative = false, asBuffer = false) {\n        const links = [];\n        if (paths) {\n            if (!Array.isArray(paths))\n                paths = [paths];\n            for (const path of paths) {\n                const filename = (0, util_1.pathToFilename)(path);\n                const link = this.getResolvedLink(filename);\n                if (!link)\n                    continue;\n                links.push(link);\n            }\n        }\n        else {\n            links.push(this.root);\n        }\n        if (!links.length)\n            return json;\n        for (const link of links)\n            this._toJSON(link, json, isRelative ? link.getPath() : '', asBuffer);\n        return json;\n    }\n    // TODO: `cwd` should probably not invoke `process.cwd()`.\n    fromJSON(json, cwd = process_1.default.cwd()) {\n        for (let filename in json) {\n            const data = json[filename];\n            filename = resolve(filename, cwd);\n            if (typeof data === 'string' || data instanceof buffer_1.Buffer) {\n                const dir = dirname(filename);\n                this.mkdirpBase(dir, 511 /* MODE.DIR */);\n                this.writeFileSync(filename, data);\n            }\n            else {\n                this.mkdirpBase(filename, 511 /* MODE.DIR */);\n            }\n        }\n    }\n    fromNestedJSON(json, cwd) {\n        this.fromJSON(flattenJSON(json), cwd);\n    }\n    toTree(opts = { separator: sep }) {\n        return (0, print_1.toTreeSync)(this, opts);\n    }\n    reset() {\n        this.ino = 0;\n        this.inodes = {};\n        this.releasedInos = [];\n        this.fds = {};\n        this.releasedFds = [];\n        this.openFiles = 0;\n        this.root = this.createLink();\n        this.root.setNode(this.createNode(true));\n    }\n    // Legacy interface\n    mountSync(mountpoint, json) {\n        this.fromJSON(json, mountpoint);\n    }\n    openLink(link, flagsNum, resolveSymlinks = true) {\n        if (this.openFiles >= this.maxFiles) {\n            // Too many open files.\n            throw (0, util_1.createError)(EMFILE, 'open', link.getPath());\n        }\n        // Resolve symlinks.\n        //\n        // @TODO: This should be superfluous. This method is only ever called by openFile(), which does its own symlink resolution\n        // prior to calling.\n        let realLink = link;\n        if (resolveSymlinks)\n            realLink = this.getResolvedLinkOrThrow(link.getPath(), 'open');\n        const node = realLink.getNode();\n        // Check whether node is a directory\n        if (node.isDirectory()) {\n            if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY)\n                throw (0, util_1.createError)(EISDIR, 'open', link.getPath());\n        }\n        else {\n            if (flagsNum & O_DIRECTORY)\n                throw (0, util_1.createError)(ENOTDIR, 'open', link.getPath());\n        }\n        // Check node permissions\n        if (!(flagsNum & O_WRONLY)) {\n            if (!node.canRead()) {\n                throw (0, util_1.createError)(EACCES, 'open', link.getPath());\n            }\n        }\n        if (!(flagsNum & O_RDONLY)) {\n            if (!node.canWrite()) {\n                throw (0, util_1.createError)(EACCES, 'open', link.getPath());\n            }\n        }\n        const file = new this.props.File(link, node, flagsNum, this.newFdNumber());\n        this.fds[file.fd] = file;\n        this.openFiles++;\n        if (flagsNum & O_TRUNC)\n            file.truncate();\n        return file;\n    }\n    openFile(filename, flagsNum, modeNum, resolveSymlinks = true) {\n        const steps = filenameToSteps(filename);\n        let link;\n        try {\n            link = resolveSymlinks ? this.getResolvedLinkOrThrow(filename, 'open') : this.getLinkOrThrow(filename, 'open');\n            // Check if file already existed when trying to create it exclusively (O_CREAT and O_EXCL flags are set).\n            // This is an error, see https://pubs.opengroup.org/onlinepubs/009695399/functions/open.html:\n            // \"If O_CREAT and O_EXCL are set, open() shall fail if the file exists.\"\n            if (link && flagsNum & O_CREAT && flagsNum & O_EXCL)\n                throw (0, util_1.createError)(EEXIST, 'open', filename);\n        }\n        catch (err) {\n            // Try creating a new file, if it does not exist and O_CREAT flag is set.\n            // Note that this will still throw if the ENOENT came from one of the\n            // intermediate directories instead of the file itself.\n            if (err.code === ENOENT && flagsNum & O_CREAT) {\n                const dirname = pathModule.dirname(filename);\n                const dirLink = this.getResolvedLinkOrThrow(dirname);\n                const dirNode = dirLink.getNode();\n                // Check that the place we create the new file is actually a directory and that we are allowed to do so:\n                if (!dirNode.isDirectory())\n                    throw (0, util_1.createError)(ENOTDIR, 'open', filename);\n                if (!dirNode.canExecute() || !dirNode.canWrite())\n                    throw (0, util_1.createError)(EACCES, 'open', filename);\n                // This is a difference to the original implementation, which would simply not create a file unless modeNum was specified.\n                // However, current Node versions will default to 0o666.\n                modeNum !== null && modeNum !== void 0 ? modeNum : (modeNum = 0o666);\n                link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);\n            }\n            else\n                throw err;\n        }\n        if (link)\n            return this.openLink(link, flagsNum, resolveSymlinks);\n        throw (0, util_1.createError)(ENOENT, 'open', filename);\n    }\n    openBase(filename, flagsNum, modeNum, resolveSymlinks = true) {\n        const file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);\n        if (!file)\n            throw (0, util_1.createError)(ENOENT, 'open', filename);\n        return file.fd;\n    }\n    openSync(path, flags, mode = 438 /* MODE.DEFAULT */) {\n        // Validate (1) mode; (2) path; (3) flags - in that order.\n        const modeNum = (0, util_1.modeToNumber)(mode);\n        const fileName = (0, util_1.pathToFilename)(path);\n        const flagsNum = (0, util_1.flagsToNumber)(flags);\n        return this.openBase(fileName, flagsNum, modeNum, !(flagsNum & O_SYMLINK));\n    }\n    open(path, flags, a, b) {\n        let mode = a;\n        let callback = b;\n        if (typeof a === 'function') {\n            mode = 438 /* MODE.DEFAULT */;\n            callback = a;\n        }\n        mode = mode || 438 /* MODE.DEFAULT */;\n        const modeNum = (0, util_1.modeToNumber)(mode);\n        const fileName = (0, util_1.pathToFilename)(path);\n        const flagsNum = (0, util_1.flagsToNumber)(flags);\n        this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum, !(flagsNum & O_SYMLINK)], callback);\n    }\n    closeFile(file) {\n        if (!this.fds[file.fd])\n            return;\n        this.openFiles--;\n        delete this.fds[file.fd];\n        this.releasedFds.push(file.fd);\n    }\n    closeSync(fd) {\n        (0, util_1.validateFd)(fd);\n        const file = this.getFileByFdOrThrow(fd, 'close');\n        this.closeFile(file);\n    }\n    close(fd, callback) {\n        (0, util_1.validateFd)(fd);\n        this.wrapAsync(this.closeSync, [fd], callback);\n    }\n    openFileOrGetById(id, flagsNum, modeNum) {\n        if (typeof id === 'number') {\n            const file = this.fds[id];\n            if (!file)\n                throw (0, util_1.createError)(ENOENT);\n            return file;\n        }\n        else {\n            return this.openFile((0, util_1.pathToFilename)(id), flagsNum, modeNum);\n        }\n    }\n    readBase(fd, buffer, offset, length, position) {\n        if (buffer.byteLength < length) {\n            throw (0, util_1.createError)(ERR_OUT_OF_RANGE, 'read', undefined, undefined, RangeError);\n        }\n        const file = this.getFileByFdOrThrow(fd);\n        if (file.node.isSymlink()) {\n            throw (0, util_1.createError)(EPERM, 'read', file.link.getPath());\n        }\n        return file.read(buffer, Number(offset), Number(length), position === -1 || typeof position !== 'number' ? undefined : position);\n    }\n    readSync(fd, buffer, offset, length, position) {\n        (0, util_1.validateFd)(fd);\n        return this.readBase(fd, buffer, offset, length, position);\n    }\n    read(fd, buffer, offset, length, position, callback) {\n        (0, util_1.validateCallback)(callback);\n        // This `if` branch is from Node.js\n        if (length === 0) {\n            return (0, queueMicrotask_1.default)(() => {\n                if (callback)\n                    callback(null, 0, buffer);\n            });\n        }\n        (0, setImmediate_1.default)(() => {\n            try {\n                const bytes = this.readBase(fd, buffer, offset, length, position);\n                callback(null, bytes, buffer);\n            }\n            catch (err) {\n                callback(err);\n            }\n        });\n    }\n    readvBase(fd, buffers, position) {\n        const file = this.getFileByFdOrThrow(fd);\n        let p = position !== null && position !== void 0 ? position : undefined;\n        if (p === -1) {\n            p = undefined;\n        }\n        let bytesRead = 0;\n        for (const buffer of buffers) {\n            const bytes = file.read(buffer, 0, buffer.byteLength, p);\n            p = undefined;\n            bytesRead += bytes;\n            if (bytes < buffer.byteLength)\n                break;\n        }\n        return bytesRead;\n    }\n    readv(fd, buffers, a, b) {\n        let position = a;\n        let callback = b;\n        if (typeof a === 'function') {\n            position = null;\n            callback = a;\n        }\n        (0, util_1.validateCallback)(callback);\n        (0, setImmediate_1.default)(() => {\n            try {\n                const bytes = this.readvBase(fd, buffers, position);\n                callback(null, bytes, buffers);\n            }\n            catch (err) {\n                callback(err);\n            }\n        });\n    }\n    readvSync(fd, buffers, position) {\n        (0, util_1.validateFd)(fd);\n        return this.readvBase(fd, buffers, position);\n    }\n    readFileBase(id, flagsNum, encoding) {\n        let result;\n        const isUserFd = typeof id === 'number';\n        const userOwnsFd = isUserFd && (0, util_1.isFd)(id);\n        let fd;\n        if (userOwnsFd)\n            fd = id;\n        else {\n            const filename = (0, util_1.pathToFilename)(id);\n            const link = this.getResolvedLinkOrThrow(filename, 'open');\n            const node = link.getNode();\n            if (node.isDirectory())\n                throw (0, util_1.createError)(EISDIR, 'open', link.getPath());\n            fd = this.openSync(id, flagsNum);\n        }\n        try {\n            result = (0, util_1.bufferToEncoding)(this.getFileByFdOrThrow(fd).getBuffer(), encoding);\n        }\n        finally {\n            if (!userOwnsFd) {\n                this.closeSync(fd);\n            }\n        }\n        return result;\n    }\n    readFileSync(file, options) {\n        const opts = (0, options_1.getReadFileOptions)(options);\n        const flagsNum = (0, util_1.flagsToNumber)(opts.flag);\n        return this.readFileBase(file, flagsNum, opts.encoding);\n    }\n    readFile(id, a, b) {\n        const [opts, callback] = (0, options_1.optsAndCbGenerator)(options_1.getReadFileOptions)(a, b);\n        const flagsNum = (0, util_1.flagsToNumber)(opts.flag);\n        this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);\n    }\n    writeBase(fd, buf, offset, length, position) {\n        const file = this.getFileByFdOrThrow(fd, 'write');\n        if (file.node.isSymlink()) {\n            throw (0, util_1.createError)(EBADF, 'write', file.link.getPath());\n        }\n        return file.write(buf, offset, length, position === -1 || typeof position !== 'number' ? undefined : position);\n    }\n    writeSync(fd, a, b, c, d) {\n        const [, buf, offset, length, position] = (0, util_1.getWriteSyncArgs)(fd, a, b, c, d);\n        return this.writeBase(fd, buf, offset, length, position);\n    }\n    write(fd, a, b, c, d, e) {\n        const [, asStr, buf, offset, length, position, cb] = (0, util_1.getWriteArgs)(fd, a, b, c, d, e);\n        (0, setImmediate_1.default)(() => {\n            try {\n                const bytes = this.writeBase(fd, buf, offset, length, position);\n                if (!asStr) {\n                    cb(null, bytes, buf);\n                }\n                else {\n                    cb(null, bytes, a);\n                }\n            }\n            catch (err) {\n                cb(err);\n            }\n        });\n    }\n    writevBase(fd, buffers, position) {\n        const file = this.getFileByFdOrThrow(fd);\n        let p = position !== null && position !== void 0 ? position : undefined;\n        if (p === -1) {\n            p = undefined;\n        }\n        let bytesWritten = 0;\n        for (const buffer of buffers) {\n            const nodeBuf = buffer_1.Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n            const bytes = file.write(nodeBuf, 0, nodeBuf.byteLength, p);\n            p = undefined;\n            bytesWritten += bytes;\n            if (bytes < nodeBuf.byteLength)\n                break;\n        }\n        return bytesWritten;\n    }\n    writev(fd, buffers, a, b) {\n        let position = a;\n        let callback = b;\n        if (typeof a === 'function') {\n            position = null;\n            callback = a;\n        }\n        (0, util_1.validateCallback)(callback);\n        (0, setImmediate_1.default)(() => {\n            try {\n                const bytes = this.writevBase(fd, buffers, position);\n                callback(null, bytes, buffers);\n            }\n            catch (err) {\n                callback(err);\n            }\n        });\n    }\n    writevSync(fd, buffers, position) {\n        (0, util_1.validateFd)(fd);\n        return this.writevBase(fd, buffers, position);\n    }\n    writeFileBase(id, buf, flagsNum, modeNum) {\n        // console.log('writeFileBase', id, buf, flagsNum, modeNum);\n        // const node = this.getNodeByIdOrCreate(id, flagsNum, modeNum);\n        // node.setBuffer(buf);\n        const isUserFd = typeof id === 'number';\n        let fd;\n        if (isUserFd)\n            fd = id;\n        else {\n            fd = this.openBase((0, util_1.pathToFilename)(id), flagsNum, modeNum);\n            // fd = this.openSync(id as PathLike, flagsNum, modeNum);\n        }\n        let offset = 0;\n        let length = buf.length;\n        let position = flagsNum & O_APPEND ? undefined : 0;\n        try {\n            while (length > 0) {\n                const written = this.writeSync(fd, buf, offset, length, position);\n                offset += written;\n                length -= written;\n                if (position !== undefined)\n                    position += written;\n            }\n        }\n        finally {\n            if (!isUserFd)\n                this.closeSync(fd);\n        }\n    }\n    writeFileSync(id, data, options) {\n        const opts = (0, options_1.getWriteFileOptions)(options);\n        const flagsNum = (0, util_1.flagsToNumber)(opts.flag);\n        const modeNum = (0, util_1.modeToNumber)(opts.mode);\n        const buf = (0, util_1.dataToBuffer)(data, opts.encoding);\n        this.writeFileBase(id, buf, flagsNum, modeNum);\n    }\n    writeFile(id, data, a, b) {\n        let options = a;\n        let callback = b;\n        if (typeof a === 'function') {\n            options = options_1.writeFileDefaults;\n            callback = a;\n        }\n        const cb = (0, util_1.validateCallback)(callback);\n        const opts = (0, options_1.getWriteFileOptions)(options);\n        const flagsNum = (0, util_1.flagsToNumber)(opts.flag);\n        const modeNum = (0, util_1.modeToNumber)(opts.mode);\n        const buf = (0, util_1.dataToBuffer)(data, opts.encoding);\n        this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);\n    }\n    linkBase(filename1, filename2) {\n        let link1;\n        try {\n            link1 = this.getLinkOrThrow(filename1, 'link');\n        }\n        catch (err) {\n            // Augment error with filename2\n            if (err.code)\n                err = (0, util_1.createError)(err.code, 'link', filename1, filename2);\n            throw err;\n        }\n        const dirname2 = pathModule.dirname(filename2);\n        let dir2;\n        try {\n            dir2 = this.getLinkOrThrow(dirname2, 'link');\n        }\n        catch (err) {\n            // Augment error with filename1\n            if (err.code)\n                err = (0, util_1.createError)(err.code, 'link', filename1, filename2);\n            throw err;\n        }\n        const name = pathModule.basename(filename2);\n        // Check if new file already exists.\n        if (dir2.getChild(name))\n            throw (0, util_1.createError)(EEXIST, 'link', filename1, filename2);\n        const node = link1.getNode();\n        node.nlink++;\n        dir2.createChild(name, node);\n    }\n    copyFileBase(src, dest, flags) {\n        const buf = this.readFileSync(src);\n        if (flags & COPYFILE_EXCL) {\n            if (this.existsSync(dest)) {\n                throw (0, util_1.createError)(EEXIST, 'copyFile', src, dest);\n            }\n        }\n        if (flags & COPYFILE_FICLONE_FORCE) {\n            throw (0, util_1.createError)(ENOSYS, 'copyFile', src, dest);\n        }\n        this.writeFileBase(dest, buf, constants_2.FLAGS.w, 438 /* MODE.DEFAULT */);\n    }\n    copyFileSync(src, dest, flags) {\n        const srcFilename = (0, util_1.pathToFilename)(src);\n        const destFilename = (0, util_1.pathToFilename)(dest);\n        return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);\n    }\n    copyFile(src, dest, a, b) {\n        const srcFilename = (0, util_1.pathToFilename)(src);\n        const destFilename = (0, util_1.pathToFilename)(dest);\n        let flags;\n        let callback;\n        if (typeof a === 'function') {\n            flags = 0;\n            callback = a;\n        }\n        else {\n            flags = a;\n            callback = b;\n        }\n        (0, util_1.validateCallback)(callback);\n        this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);\n    }\n    linkSync(existingPath, newPath) {\n        const existingPathFilename = (0, util_1.pathToFilename)(existingPath);\n        const newPathFilename = (0, util_1.pathToFilename)(newPath);\n        this.linkBase(existingPathFilename, newPathFilename);\n    }\n    link(existingPath, newPath, callback) {\n        const existingPathFilename = (0, util_1.pathToFilename)(existingPath);\n        const newPathFilename = (0, util_1.pathToFilename)(newPath);\n        this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);\n    }\n    unlinkBase(filename) {\n        const link = this.getLinkOrThrow(filename, 'unlink');\n        // TODO: Check if it is file, dir, other...\n        if (link.length)\n            throw Error('Dir not empty...');\n        this.deleteLink(link);\n        const node = link.getNode();\n        node.nlink--;\n        // When all hard links to i-node are deleted, remove the i-node, too.\n        if (node.nlink <= 0) {\n            this.deleteNode(node);\n        }\n    }\n    unlinkSync(path) {\n        const filename = (0, util_1.pathToFilename)(path);\n        this.unlinkBase(filename);\n    }\n    unlink(path, callback) {\n        const filename = (0, util_1.pathToFilename)(path);\n        this.wrapAsync(this.unlinkBase, [filename], callback);\n    }\n    symlinkBase(targetFilename, pathFilename) {\n        const pathSteps = filenameToSteps(pathFilename);\n        // Check if directory exists, where we about to create a symlink.\n        let dirLink;\n        try {\n            dirLink = this.getLinkParentAsDirOrThrow(pathSteps);\n        }\n        catch (err) {\n            // Catch error to populate with the correct fields - getLinkParentAsDirOrThrow won't be aware of the second path\n            if (err.code)\n                err = (0, util_1.createError)(err.code, 'symlink', targetFilename, pathFilename);\n            throw err;\n        }\n        const name = pathSteps[pathSteps.length - 1];\n        // Check if new file already exists.\n        if (dirLink.getChild(name))\n            throw (0, util_1.createError)(EEXIST, 'symlink', targetFilename, pathFilename);\n        // Check permissions on the path where we are creating the symlink.\n        // Note we're not checking permissions on the target path: It is not an error to create a symlink to a\n        // non-existent or inaccessible target\n        const node = dirLink.getNode();\n        if (!node.canExecute() || !node.canWrite())\n            throw (0, util_1.createError)(EACCES, 'symlink', targetFilename, pathFilename);\n        // Create symlink.\n        const symlink = dirLink.createChild(name);\n        symlink.getNode().makeSymlink(filenameToSteps(targetFilename));\n        return symlink;\n    }\n    // `type` argument works only on Windows.\n    symlinkSync(target, path, type) {\n        const targetFilename = (0, util_1.pathToFilename)(target);\n        const pathFilename = (0, util_1.pathToFilename)(path);\n        this.symlinkBase(targetFilename, pathFilename);\n    }\n    symlink(target, path, a, b) {\n        const callback = (0, util_1.validateCallback)(typeof a === 'function' ? a : b);\n        const targetFilename = (0, util_1.pathToFilename)(target);\n        const pathFilename = (0, util_1.pathToFilename)(path);\n        this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);\n    }\n    realpathBase(filename, encoding) {\n        debugger;\n        const realLink = this.getResolvedLinkOrThrow(filename, 'realpath');\n        return (0, encoding_1.strToEncoding)(realLink.getPath() || '/', encoding);\n    }\n    realpathSync(path, options) {\n        return this.realpathBase((0, util_1.pathToFilename)(path), (0, options_1.getRealpathOptions)(options).encoding);\n    }\n    realpath(path, a, b) {\n        const [opts, callback] = (0, options_1.getRealpathOptsAndCb)(a, b);\n        const pathFilename = (0, util_1.pathToFilename)(path);\n        this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);\n    }\n    lstatBase(filename, bigint = false, throwIfNoEntry = false) {\n        let link;\n        try {\n            link = this.getLinkOrThrow(filename, 'lstat');\n        }\n        catch (err) {\n            if (err.code === ENOENT && !throwIfNoEntry)\n                return undefined;\n            else\n                throw err;\n        }\n        return Stats_1.default.build(link.getNode(), bigint);\n    }\n    lstatSync(path, options) {\n        const { throwIfNoEntry = true, bigint = false } = (0, options_1.getStatOptions)(options);\n        return this.lstatBase((0, util_1.pathToFilename)(path), bigint, throwIfNoEntry);\n    }\n    lstat(path, a, b) {\n        const [{ throwIfNoEntry = true, bigint = false }, callback] = (0, options_1.getStatOptsAndCb)(a, b);\n        this.wrapAsync(this.lstatBase, [(0, util_1.pathToFilename)(path), bigint, throwIfNoEntry], callback);\n    }\n    statBase(filename, bigint = false, throwIfNoEntry = true) {\n        let link;\n        try {\n            link = this.getResolvedLinkOrThrow(filename, 'stat');\n        }\n        catch (err) {\n            if (err.code === ENOENT && !throwIfNoEntry)\n                return undefined;\n            else\n                throw err;\n        }\n        return Stats_1.default.build(link.getNode(), bigint);\n    }\n    statSync(path, options) {\n        const { bigint = true, throwIfNoEntry = true } = (0, options_1.getStatOptions)(options);\n        return this.statBase((0, util_1.pathToFilename)(path), bigint, throwIfNoEntry);\n    }\n    stat(path, a, b) {\n        const [{ bigint = false, throwIfNoEntry = true }, callback] = (0, options_1.getStatOptsAndCb)(a, b);\n        this.wrapAsync(this.statBase, [(0, util_1.pathToFilename)(path), bigint, throwIfNoEntry], callback);\n    }\n    fstatBase(fd, bigint = false) {\n        const file = this.getFileByFd(fd);\n        if (!file)\n            throw (0, util_1.createError)(EBADF, 'fstat');\n        return Stats_1.default.build(file.node, bigint);\n    }\n    fstatSync(fd, options) {\n        return this.fstatBase(fd, (0, options_1.getStatOptions)(options).bigint);\n    }\n    fstat(fd, a, b) {\n        const [opts, callback] = (0, options_1.getStatOptsAndCb)(a, b);\n        this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);\n    }\n    renameBase(oldPathFilename, newPathFilename) {\n        let link;\n        try {\n            link = this.getResolvedLinkOrThrow(oldPathFilename);\n        }\n        catch (err) {\n            // Augment err with newPathFilename\n            if (err.code)\n                err = (0, util_1.createError)(err.code, 'rename', oldPathFilename, newPathFilename);\n            throw err;\n        }\n        // TODO: Check if it is directory, if non-empty, we cannot move it, right?\n        // Check directory exists for the new location.\n        let newPathDirLink;\n        try {\n            newPathDirLink = this.getLinkParentAsDirOrThrow(newPathFilename);\n        }\n        catch (err) {\n            // Augment error with oldPathFilename\n            if (err.code)\n                err = (0, util_1.createError)(err.code, 'rename', oldPathFilename, newPathFilename);\n            throw err;\n        }\n        // TODO: Also treat cases with directories and symbolic links.\n        // TODO: See: http://man7.org/linux/man-pages/man2/rename.2.html\n        // Remove hard link from old folder.\n        const oldLinkParent = link.parent;\n        // Check we have access and write permissions in both places\n        const oldParentNode = oldLinkParent.getNode();\n        const newPathDirNode = newPathDirLink.getNode();\n        if (!oldParentNode.canExecute() ||\n            !oldParentNode.canWrite() ||\n            !newPathDirNode.canExecute() ||\n            !newPathDirNode.canWrite()) {\n            throw (0, util_1.createError)(EACCES, 'rename', oldPathFilename, newPathFilename);\n        }\n        oldLinkParent.deleteChild(link);\n        // Rename should overwrite the new path, if that exists.\n        const name = pathModule.basename(newPathFilename);\n        link.name = name;\n        link.steps = [...newPathDirLink.steps, name];\n        newPathDirLink.setChild(link.getName(), link);\n    }\n    renameSync(oldPath, newPath) {\n        const oldPathFilename = (0, util_1.pathToFilename)(oldPath);\n        const newPathFilename = (0, util_1.pathToFilename)(newPath);\n        this.renameBase(oldPathFilename, newPathFilename);\n    }\n    rename(oldPath, newPath, callback) {\n        const oldPathFilename = (0, util_1.pathToFilename)(oldPath);\n        const newPathFilename = (0, util_1.pathToFilename)(newPath);\n        this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);\n    }\n    existsBase(filename) {\n        return !!this.statBase(filename);\n    }\n    existsSync(path) {\n        try {\n            return this.existsBase((0, util_1.pathToFilename)(path));\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    exists(path, callback) {\n        const filename = (0, util_1.pathToFilename)(path);\n        if (typeof callback !== 'function')\n            throw Error(constants_2.ERRSTR.CB);\n        (0, setImmediate_1.default)(() => {\n            try {\n                callback(this.existsBase(filename));\n            }\n            catch (err) {\n                callback(false);\n            }\n        });\n    }\n    accessBase(filename, mode) {\n        const link = this.getLinkOrThrow(filename, 'access');\n    }\n    accessSync(path, mode = F_OK) {\n        const filename = (0, util_1.pathToFilename)(path);\n        mode = mode | 0;\n        this.accessBase(filename, mode);\n    }\n    access(path, a, b) {\n        let mode = F_OK;\n        let callback;\n        if (typeof a !== 'function') {\n            mode = a | 0; // cast to number\n            callback = (0, util_1.validateCallback)(b);\n        }\n        else {\n            callback = a;\n        }\n        const filename = (0, util_1.pathToFilename)(path);\n        this.wrapAsync(this.accessBase, [filename, mode], callback);\n    }\n    appendFileSync(id, data, options) {\n        const opts = (0, options_1.getAppendFileOpts)(options);\n        // force append behavior when using a supplied file descriptor\n        if (!opts.flag || (0, util_1.isFd)(id))\n            opts.flag = 'a';\n        this.writeFileSync(id, data, opts);\n    }\n    appendFile(id, data, a, b) {\n        const [opts, callback] = (0, options_1.getAppendFileOptsAndCb)(a, b);\n        // force append behavior when using a supplied file descriptor\n        if (!opts.flag || (0, util_1.isFd)(id))\n            opts.flag = 'a';\n        this.writeFile(id, data, opts, callback);\n    }\n    readdirBase(filename, options) {\n        const steps = filenameToSteps(filename);\n        const link = this.getResolvedLinkOrThrow(filename, 'scandir');\n        const node = link.getNode();\n        if (!node.isDirectory())\n            throw (0, util_1.createError)(ENOTDIR, 'scandir', filename);\n        // Check we have permissions\n        if (!node.canRead())\n            throw (0, util_1.createError)(EACCES, 'scandir', filename);\n        const list = []; // output list\n        for (const name of link.children.keys()) {\n            const child = link.getChild(name);\n            if (!child || name === '.' || name === '..')\n                continue;\n            list.push(Dirent_1.default.build(child, options.encoding));\n            // recursion\n            if (options.recursive && child.children.size) {\n                const recurseOptions = Object.assign(Object.assign({}, options), { recursive: true, withFileTypes: true });\n                const childList = this.readdirBase(child.getPath(), recurseOptions);\n                list.push(...childList);\n            }\n        }\n        if (!util_1.isWin && options.encoding !== 'buffer')\n            list.sort((a, b) => {\n                if (a.name < b.name)\n                    return -1;\n                if (a.name > b.name)\n                    return 1;\n                return 0;\n            });\n        if (options.withFileTypes)\n            return list;\n        let filename2 = filename;\n        if (util_1.isWin) {\n            filename2 = filename2.replace(/\\\\/g, '/');\n        }\n        return list.map(dirent => {\n            if (options.recursive) {\n                let fullPath = pathModule.join(dirent.parentPath, dirent.name.toString());\n                if (util_1.isWin) {\n                    fullPath = fullPath.replace(/\\\\/g, '/');\n                }\n                return fullPath.replace(filename2 + pathModule.posix.sep, '');\n            }\n            return dirent.name;\n        });\n    }\n    readdirSync(path, options) {\n        const opts = (0, options_1.getReaddirOptions)(options);\n        const filename = (0, util_1.pathToFilename)(path);\n        return this.readdirBase(filename, opts);\n    }\n    readdir(path, a, b) {\n        const [options, callback] = (0, options_1.getReaddirOptsAndCb)(a, b);\n        const filename = (0, util_1.pathToFilename)(path);\n        this.wrapAsync(this.readdirBase, [filename, options], callback);\n    }\n    readlinkBase(filename, encoding) {\n        const link = this.getLinkOrThrow(filename, 'readlink');\n        const node = link.getNode();\n        if (!node.isSymlink())\n            throw (0, util_1.createError)(EINVAL, 'readlink', filename);\n        const str = sep + node.symlink.join(sep);\n        return (0, encoding_1.strToEncoding)(str, encoding);\n    }\n    readlinkSync(path, options) {\n        const opts = (0, options_1.getDefaultOpts)(options);\n        const filename = (0, util_1.pathToFilename)(path);\n        return this.readlinkBase(filename, opts.encoding);\n    }\n    readlink(path, a, b) {\n        const [opts, callback] = (0, options_1.getDefaultOptsAndCb)(a, b);\n        const filename = (0, util_1.pathToFilename)(path);\n        this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);\n    }\n    fsyncBase(fd) {\n        this.getFileByFdOrThrow(fd, 'fsync');\n    }\n    fsyncSync(fd) {\n        this.fsyncBase(fd);\n    }\n    fsync(fd, callback) {\n        this.wrapAsync(this.fsyncBase, [fd], callback);\n    }\n    fdatasyncBase(fd) {\n        this.getFileByFdOrThrow(fd, 'fdatasync');\n    }\n    fdatasyncSync(fd) {\n        this.fdatasyncBase(fd);\n    }\n    fdatasync(fd, callback) {\n        this.wrapAsync(this.fdatasyncBase, [fd], callback);\n    }\n    ftruncateBase(fd, len) {\n        const file = this.getFileByFdOrThrow(fd, 'ftruncate');\n        file.truncate(len);\n    }\n    ftruncateSync(fd, len) {\n        this.ftruncateBase(fd, len);\n    }\n    ftruncate(fd, a, b) {\n        const len = typeof a === 'number' ? a : 0;\n        const callback = (0, util_1.validateCallback)(typeof a === 'number' ? b : a);\n        this.wrapAsync(this.ftruncateBase, [fd, len], callback);\n    }\n    truncateBase(path, len) {\n        const fd = this.openSync(path, 'r+');\n        try {\n            this.ftruncateSync(fd, len);\n        }\n        finally {\n            this.closeSync(fd);\n        }\n    }\n    /**\n     * `id` should be a file descriptor or a path. `id` as file descriptor will\n     * not be supported soon.\n     */\n    truncateSync(id, len) {\n        if ((0, util_1.isFd)(id))\n            return this.ftruncateSync(id, len);\n        this.truncateBase(id, len);\n    }\n    truncate(id, a, b) {\n        const len = typeof a === 'number' ? a : 0;\n        const callback = (0, util_1.validateCallback)(typeof a === 'number' ? b : a);\n        if ((0, util_1.isFd)(id))\n            return this.ftruncate(id, len, callback);\n        this.wrapAsync(this.truncateBase, [id, len], callback);\n    }\n    futimesBase(fd, atime, mtime) {\n        const file = this.getFileByFdOrThrow(fd, 'futimes');\n        const node = file.node;\n        node.atime = new Date(atime * 1000);\n        node.mtime = new Date(mtime * 1000);\n    }\n    futimesSync(fd, atime, mtime) {\n        this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));\n    }\n    futimes(fd, atime, mtime, callback) {\n        this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);\n    }\n    utimesBase(filename, atime, mtime, followSymlinks = true) {\n        const link = followSymlinks\n            ? this.getResolvedLinkOrThrow(filename, 'utimes')\n            : this.getLinkOrThrow(filename, 'lutimes');\n        const node = link.getNode();\n        node.atime = new Date(atime * 1000);\n        node.mtime = new Date(mtime * 1000);\n    }\n    utimesSync(path, atime, mtime) {\n        this.utimesBase((0, util_1.pathToFilename)(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), true);\n    }\n    utimes(path, atime, mtime, callback) {\n        this.wrapAsync(this.utimesBase, [(0, util_1.pathToFilename)(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), true], callback);\n    }\n    lutimesSync(path, atime, mtime) {\n        this.utimesBase((0, util_1.pathToFilename)(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), false);\n    }\n    lutimes(path, atime, mtime, callback) {\n        this.wrapAsync(this.utimesBase, [(0, util_1.pathToFilename)(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), false], callback);\n    }\n    mkdirBase(filename, modeNum) {\n        const steps = filenameToSteps(filename);\n        // This will throw if user tries to create root dir `fs.mkdirSync('/')`.\n        if (!steps.length) {\n            throw (0, util_1.createError)(EEXIST, 'mkdir', filename);\n        }\n        const dir = this.getLinkParentAsDirOrThrow(filename, 'mkdir');\n        // Check path already exists.\n        const name = steps[steps.length - 1];\n        if (dir.getChild(name))\n            throw (0, util_1.createError)(EEXIST, 'mkdir', filename);\n        const node = dir.getNode();\n        if (!node.canWrite() || !node.canExecute())\n            throw (0, util_1.createError)(EACCES, 'mkdir', filename);\n        dir.createChild(name, this.createNode(true, modeNum));\n    }\n    /**\n     * Creates directory tree recursively.\n     */\n    mkdirpBase(filename, modeNum) {\n        let created = false;\n        const steps = filenameToSteps(filename);\n        let curr = null;\n        let i = steps.length;\n        // Find the longest subpath of filename that still exists:\n        for (i = steps.length; i >= 0; i--) {\n            curr = this.getResolvedLink(steps.slice(0, i));\n            if (curr)\n                break;\n        }\n        if (!curr) {\n            curr = this.root;\n            i = 0;\n        }\n        // curr is now the last directory that still exists.\n        // (If none of them existed, curr is the root.)\n        // Check access the lazy way:\n        curr = this.getResolvedLinkOrThrow(sep + steps.slice(0, i).join(sep), 'mkdir');\n        // Start creating directories:\n        for (i; i < steps.length; i++) {\n            const node = curr.getNode();\n            if (node.isDirectory()) {\n                // Check we have permissions\n                if (!node.canExecute() || !node.canWrite())\n                    throw (0, util_1.createError)(EACCES, 'mkdir', filename);\n            }\n            else {\n                throw (0, util_1.createError)(ENOTDIR, 'mkdir', filename);\n            }\n            created = true;\n            curr = curr.createChild(steps[i], this.createNode(true, modeNum));\n        }\n        return created ? filename : undefined;\n    }\n    mkdirSync(path, options) {\n        const opts = (0, options_1.getMkdirOptions)(options);\n        const modeNum = (0, util_1.modeToNumber)(opts.mode, 0o777);\n        const filename = (0, util_1.pathToFilename)(path);\n        if (opts.recursive)\n            return this.mkdirpBase(filename, modeNum);\n        this.mkdirBase(filename, modeNum);\n    }\n    mkdir(path, a, b) {\n        const opts = (0, options_1.getMkdirOptions)(a);\n        const callback = (0, util_1.validateCallback)(typeof a === 'function' ? a : b);\n        const modeNum = (0, util_1.modeToNumber)(opts.mode, 0o777);\n        const filename = (0, util_1.pathToFilename)(path);\n        if (opts.recursive)\n            this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);\n        else\n            this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);\n    }\n    mkdtempBase(prefix, encoding, retry = 5) {\n        const filename = prefix + (0, util_1.genRndStr6)();\n        try {\n            this.mkdirBase(filename, 511 /* MODE.DIR */);\n            return (0, encoding_1.strToEncoding)(filename, encoding);\n        }\n        catch (err) {\n            if (err.code === EEXIST) {\n                if (retry > 1)\n                    return this.mkdtempBase(prefix, encoding, retry - 1);\n                else\n                    throw Error('Could not create temp dir.');\n            }\n            else\n                throw err;\n        }\n    }\n    mkdtempSync(prefix, options) {\n        const { encoding } = (0, options_1.getDefaultOpts)(options);\n        if (!prefix || typeof prefix !== 'string')\n            throw new TypeError('filename prefix is required');\n        (0, util_1.nullCheck)(prefix);\n        return this.mkdtempBase(prefix, encoding);\n    }\n    mkdtemp(prefix, a, b) {\n        const [{ encoding }, callback] = (0, options_1.getDefaultOptsAndCb)(a, b);\n        if (!prefix || typeof prefix !== 'string')\n            throw new TypeError('filename prefix is required');\n        if (!(0, util_1.nullCheck)(prefix))\n            return;\n        this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);\n    }\n    rmdirBase(filename, options) {\n        const opts = (0, options_1.getRmdirOptions)(options);\n        const link = this.getLinkAsDirOrThrow(filename, 'rmdir');\n        // Check directory is empty.\n        if (link.length && !opts.recursive)\n            throw (0, util_1.createError)(ENOTEMPTY, 'rmdir', filename);\n        this.deleteLink(link);\n    }\n    rmdirSync(path, options) {\n        this.rmdirBase((0, util_1.pathToFilename)(path), options);\n    }\n    rmdir(path, a, b) {\n        const opts = (0, options_1.getRmdirOptions)(a);\n        const callback = (0, util_1.validateCallback)(typeof a === 'function' ? a : b);\n        this.wrapAsync(this.rmdirBase, [(0, util_1.pathToFilename)(path), opts], callback);\n    }\n    rmBase(filename, options = {}) {\n        // \"stat\" is used to match Node's native error message.\n        let link;\n        try {\n            link = this.getResolvedLinkOrThrow(filename, 'stat');\n        }\n        catch (err) {\n            // Silently ignore missing paths if force option is true\n            if (err.code === ENOENT && options.force)\n                return;\n            else\n                throw err;\n        }\n        if (link.getNode().isDirectory() && !options.recursive)\n            throw (0, util_1.createError)(ERR_FS_EISDIR, 'rm', filename);\n        // Check permissions\n        if (!link.parent.getNode().canWrite())\n            throw (0, util_1.createError)(EACCES, 'rm', filename);\n        this.deleteLink(link);\n    }\n    rmSync(path, options) {\n        this.rmBase((0, util_1.pathToFilename)(path), options);\n    }\n    rm(path, a, b) {\n        const [opts, callback] = (0, options_1.getRmOptsAndCb)(a, b);\n        this.wrapAsync(this.rmBase, [(0, util_1.pathToFilename)(path), opts], callback);\n    }\n    fchmodBase(fd, modeNum) {\n        const file = this.getFileByFdOrThrow(fd, 'fchmod');\n        file.chmod(modeNum);\n    }\n    fchmodSync(fd, mode) {\n        this.fchmodBase(fd, (0, util_1.modeToNumber)(mode));\n    }\n    fchmod(fd, mode, callback) {\n        this.wrapAsync(this.fchmodBase, [fd, (0, util_1.modeToNumber)(mode)], callback);\n    }\n    chmodBase(filename, modeNum, followSymlinks = true) {\n        const link = followSymlinks\n            ? this.getResolvedLinkOrThrow(filename, 'chmod')\n            : this.getLinkOrThrow(filename, 'chmod');\n        const node = link.getNode();\n        node.chmod(modeNum);\n    }\n    chmodSync(path, mode) {\n        const modeNum = (0, util_1.modeToNumber)(mode);\n        const filename = (0, util_1.pathToFilename)(path);\n        this.chmodBase(filename, modeNum, true);\n    }\n    chmod(path, mode, callback) {\n        const modeNum = (0, util_1.modeToNumber)(mode);\n        const filename = (0, util_1.pathToFilename)(path);\n        this.wrapAsync(this.chmodBase, [filename, modeNum], callback);\n    }\n    lchmodBase(filename, modeNum) {\n        this.chmodBase(filename, modeNum, false);\n    }\n    lchmodSync(path, mode) {\n        const modeNum = (0, util_1.modeToNumber)(mode);\n        const filename = (0, util_1.pathToFilename)(path);\n        this.lchmodBase(filename, modeNum);\n    }\n    lchmod(path, mode, callback) {\n        const modeNum = (0, util_1.modeToNumber)(mode);\n        const filename = (0, util_1.pathToFilename)(path);\n        this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);\n    }\n    fchownBase(fd, uid, gid) {\n        this.getFileByFdOrThrow(fd, 'fchown').chown(uid, gid);\n    }\n    fchownSync(fd, uid, gid) {\n        validateUid(uid);\n        validateGid(gid);\n        this.fchownBase(fd, uid, gid);\n    }\n    fchown(fd, uid, gid, callback) {\n        validateUid(uid);\n        validateGid(gid);\n        this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);\n    }\n    chownBase(filename, uid, gid) {\n        const link = this.getResolvedLinkOrThrow(filename, 'chown');\n        const node = link.getNode();\n        node.chown(uid, gid);\n        // if(node.isFile() || node.isSymlink()) {\n        //\n        // } else if(node.isDirectory()) {\n        //\n        // } else {\n        // TODO: What do we do here?\n        // }\n    }\n    chownSync(path, uid, gid) {\n        validateUid(uid);\n        validateGid(gid);\n        this.chownBase((0, util_1.pathToFilename)(path), uid, gid);\n    }\n    chown(path, uid, gid, callback) {\n        validateUid(uid);\n        validateGid(gid);\n        this.wrapAsync(this.chownBase, [(0, util_1.pathToFilename)(path), uid, gid], callback);\n    }\n    lchownBase(filename, uid, gid) {\n        this.getLinkOrThrow(filename, 'lchown').getNode().chown(uid, gid);\n    }\n    lchownSync(path, uid, gid) {\n        validateUid(uid);\n        validateGid(gid);\n        this.lchownBase((0, util_1.pathToFilename)(path), uid, gid);\n    }\n    lchown(path, uid, gid, callback) {\n        validateUid(uid);\n        validateGid(gid);\n        this.wrapAsync(this.lchownBase, [(0, util_1.pathToFilename)(path), uid, gid], callback);\n    }\n    watchFile(path, a, b) {\n        const filename = (0, util_1.pathToFilename)(path);\n        let options = a;\n        let listener = b;\n        if (typeof options === 'function') {\n            listener = a;\n            options = null;\n        }\n        if (typeof listener !== 'function') {\n            throw Error('\"watchFile()\" requires a listener function');\n        }\n        let interval = 5007;\n        let persistent = true;\n        if (options && typeof options === 'object') {\n            if (typeof options.interval === 'number')\n                interval = options.interval;\n            if (typeof options.persistent === 'boolean')\n                persistent = options.persistent;\n        }\n        let watcher = this.statWatchers[filename];\n        if (!watcher) {\n            watcher = new this.StatWatcher();\n            watcher.start(filename, persistent, interval);\n            this.statWatchers[filename] = watcher;\n        }\n        watcher.addListener('change', listener);\n        return watcher;\n    }\n    unwatchFile(path, listener) {\n        const filename = (0, util_1.pathToFilename)(path);\n        const watcher = this.statWatchers[filename];\n        if (!watcher)\n            return;\n        if (typeof listener === 'function') {\n            watcher.removeListener('change', listener);\n        }\n        else {\n            watcher.removeAllListeners('change');\n        }\n        if (watcher.listenerCount('change') === 0) {\n            watcher.stop();\n            delete this.statWatchers[filename];\n        }\n    }\n    createReadStream(path, options) {\n        return new this.ReadStream(path, options);\n    }\n    createWriteStream(path, options) {\n        return new this.WriteStream(path, options);\n    }\n    // watch(path: PathLike): FSWatcher;\n    // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;\n    watch(path, options, listener) {\n        const filename = (0, util_1.pathToFilename)(path);\n        let givenOptions = options;\n        if (typeof options === 'function') {\n            listener = options;\n            givenOptions = null;\n        }\n        // tslint:disable-next-line prefer-const\n        let { persistent, recursive, encoding } = (0, options_1.getDefaultOpts)(givenOptions);\n        if (persistent === undefined)\n            persistent = true;\n        if (recursive === undefined)\n            recursive = false;\n        const watcher = new this.FSWatcher();\n        watcher.start(filename, persistent, recursive, encoding);\n        if (listener) {\n            watcher.addListener('change', listener);\n        }\n        return watcher;\n    }\n    opendirBase(filename, options) {\n        const link = this.getResolvedLinkOrThrow(filename, 'scandir');\n        const node = link.getNode();\n        if (!node.isDirectory())\n            throw (0, util_1.createError)(ENOTDIR, 'scandir', filename);\n        return new Dir_1.Dir(link, options);\n    }\n    opendirSync(path, options) {\n        const opts = (0, options_1.getOpendirOptions)(options);\n        const filename = (0, util_1.pathToFilename)(path);\n        return this.opendirBase(filename, opts);\n    }\n    opendir(path, a, b) {\n        const [options, callback] = (0, options_1.getOpendirOptsAndCb)(a, b);\n        const filename = (0, util_1.pathToFilename)(path);\n        this.wrapAsync(this.opendirBase, [filename, options], callback);\n    }\n}\nexports.Volume = Volume;\n/**\n * Global file descriptor counter. UNIX file descriptors start from 0 and go sequentially\n * up, so here, in order not to conflict with them, we choose some big number and descrease\n * the file descriptor of every new opened file.\n * @type {number}\n * @todo This should not be static, right?\n */\nVolume.fd = 0x7fffffff;\nfunction emitStop(self) {\n    self.emit('stop');\n}\nclass StatWatcher extends events_1.EventEmitter {\n    constructor(vol) {\n        super();\n        this.onInterval = () => {\n            try {\n                const stats = this.vol.statSync(this.filename);\n                if (this.hasChanged(stats)) {\n                    this.emit('change', stats, this.prev);\n                    this.prev = stats;\n                }\n            }\n            finally {\n                this.loop();\n            }\n        };\n        this.vol = vol;\n    }\n    loop() {\n        this.timeoutRef = this.setTimeout(this.onInterval, this.interval);\n    }\n    hasChanged(stats) {\n        // if(!this.prev) return false;\n        if (stats.mtimeMs > this.prev.mtimeMs)\n            return true;\n        if (stats.nlink !== this.prev.nlink)\n            return true;\n        return false;\n    }\n    start(path, persistent = true, interval = 5007) {\n        this.filename = (0, util_1.pathToFilename)(path);\n        this.setTimeout = persistent\n            ? setTimeout.bind(typeof globalThis !== 'undefined' ? globalThis : global)\n            : setTimeoutUnref_1.default;\n        this.interval = interval;\n        this.prev = this.vol.statSync(this.filename);\n        this.loop();\n    }\n    stop() {\n        clearTimeout(this.timeoutRef);\n        (0, queueMicrotask_1.default)(() => {\n            emitStop.call(this, this);\n        });\n    }\n}\nexports.StatWatcher = StatWatcher;\n/* tslint:disable no-var-keyword prefer-const */\n// ---------------------------------------- ReadStream\nvar pool;\nfunction allocNewPool(poolSize) {\n    pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);\n    pool.used = 0;\n}\nutil.inherits(FsReadStream, stream_1.Readable);\nexports.ReadStream = FsReadStream;\nfunction FsReadStream(vol, path, options) {\n    if (!(this instanceof FsReadStream))\n        return new FsReadStream(vol, path, options);\n    this._vol = vol;\n    // a little bit bigger buffer and water marks by default\n    options = Object.assign({}, (0, options_1.getOptions)(options, {}));\n    if (options.highWaterMark === undefined)\n        options.highWaterMark = 64 * 1024;\n    stream_1.Readable.call(this, options);\n    this.path = (0, util_1.pathToFilename)(path);\n    this.fd = options.fd === undefined ? null : options.fd;\n    this.flags = options.flags === undefined ? 'r' : options.flags;\n    this.mode = options.mode === undefined ? 0o666 : options.mode;\n    this.start = options.start;\n    this.end = options.end;\n    this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n    this.pos = undefined;\n    this.bytesRead = 0;\n    if (this.start !== undefined) {\n        if (typeof this.start !== 'number') {\n            throw new TypeError('\"start\" option must be a Number');\n        }\n        if (this.end === undefined) {\n            this.end = Infinity;\n        }\n        else if (typeof this.end !== 'number') {\n            throw new TypeError('\"end\" option must be a Number');\n        }\n        if (this.start > this.end) {\n            throw new Error('\"start\" option must be <= \"end\" option');\n        }\n        this.pos = this.start;\n    }\n    if (typeof this.fd !== 'number')\n        this.open();\n    this.on('end', function () {\n        if (this.autoClose) {\n            if (this.destroy)\n                this.destroy();\n        }\n    });\n}\nFsReadStream.prototype.open = function () {\n    var self = this; // tslint:disable-line no-this-assignment\n    this._vol.open(this.path, this.flags, this.mode, (er, fd) => {\n        if (er) {\n            if (self.autoClose) {\n                if (self.destroy)\n                    self.destroy();\n            }\n            self.emit('error', er);\n            return;\n        }\n        self.fd = fd;\n        self.emit('open', fd);\n        // start the flow of data.\n        self.read();\n    });\n};\nFsReadStream.prototype._read = function (n) {\n    if (typeof this.fd !== 'number') {\n        return this.once('open', function () {\n            this._read(n);\n        });\n    }\n    if (this.destroyed)\n        return;\n    if (!pool || pool.length - pool.used < kMinPoolSpace) {\n        // discard the old pool.\n        allocNewPool(this._readableState.highWaterMark);\n    }\n    // Grab another reference to the pool in the case that while we're\n    // in the thread pool another read() finishes up the pool, and\n    // allocates a new one.\n    var thisPool = pool;\n    var toRead = Math.min(pool.length - pool.used, n);\n    var start = pool.used;\n    if (this.pos !== undefined)\n        toRead = Math.min(this.end - this.pos + 1, toRead);\n    // already read everything we were supposed to read!\n    // treat as EOF.\n    if (toRead <= 0)\n        return this.push(null);\n    // the actual read.\n    var self = this; // tslint:disable-line no-this-assignment\n    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);\n    // move the pool positions, and internal position for reading.\n    if (this.pos !== undefined)\n        this.pos += toRead;\n    pool.used += toRead;\n    function onread(er, bytesRead) {\n        if (er) {\n            if (self.autoClose && self.destroy) {\n                self.destroy();\n            }\n            self.emit('error', er);\n        }\n        else {\n            var b = null;\n            if (bytesRead > 0) {\n                self.bytesRead += bytesRead;\n                b = thisPool.slice(start, start + bytesRead);\n            }\n            self.push(b);\n        }\n    }\n};\nFsReadStream.prototype._destroy = function (err, cb) {\n    this.close(err2 => {\n        cb(err || err2);\n    });\n};\nFsReadStream.prototype.close = function (cb) {\n    var _a;\n    if (cb)\n        this.once('close', cb);\n    if (this.closed || typeof this.fd !== 'number') {\n        if (typeof this.fd !== 'number') {\n            this.once('open', closeOnOpen);\n            return;\n        }\n        return (0, queueMicrotask_1.default)(() => this.emit('close'));\n    }\n    // Since Node 18, there is only a getter for '.closed'.\n    // The first branch mimics other setters from Readable.\n    // See https://github.com/nodejs/node/blob/v18.0.0/lib/internal/streams/readable.js#L1243\n    if (typeof ((_a = this._readableState) === null || _a === void 0 ? void 0 : _a.closed) === 'boolean') {\n        this._readableState.closed = true;\n    }\n    else {\n        this.closed = true;\n    }\n    this._vol.close(this.fd, er => {\n        if (er)\n            this.emit('error', er);\n        else\n            this.emit('close');\n    });\n    this.fd = null;\n};\n// needed because as it will be called with arguments\n// that does not match this.close() signature\nfunction closeOnOpen(fd) {\n    this.close();\n}\nutil.inherits(FsWriteStream, stream_1.Writable);\nexports.WriteStream = FsWriteStream;\nfunction FsWriteStream(vol, path, options) {\n    if (!(this instanceof FsWriteStream))\n        return new FsWriteStream(vol, path, options);\n    this._vol = vol;\n    options = Object.assign({}, (0, options_1.getOptions)(options, {}));\n    stream_1.Writable.call(this, options);\n    this.path = (0, util_1.pathToFilename)(path);\n    this.fd = options.fd === undefined ? null : options.fd;\n    this.flags = options.flags === undefined ? 'w' : options.flags;\n    this.mode = options.mode === undefined ? 0o666 : options.mode;\n    this.start = options.start;\n    this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;\n    this.pos = undefined;\n    this.bytesWritten = 0;\n    this.pending = true;\n    if (this.start !== undefined) {\n        if (typeof this.start !== 'number') {\n            throw new TypeError('\"start\" option must be a Number');\n        }\n        if (this.start < 0) {\n            throw new Error('\"start\" must be >= zero');\n        }\n        this.pos = this.start;\n    }\n    if (options.encoding)\n        this.setDefaultEncoding(options.encoding);\n    if (typeof this.fd !== 'number')\n        this.open();\n    // dispose on finish.\n    this.once('finish', function () {\n        if (this.autoClose) {\n            this.close();\n        }\n    });\n}\nFsWriteStream.prototype.open = function () {\n    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {\n        if (er) {\n            if (this.autoClose && this.destroy) {\n                this.destroy();\n            }\n            this.emit('error', er);\n            return;\n        }\n        this.fd = fd;\n        this.pending = false;\n        this.emit('open', fd);\n    }.bind(this));\n};\nFsWriteStream.prototype._write = function (data, encoding, cb) {\n    if (!(data instanceof buffer_1.Buffer || data instanceof Uint8Array))\n        return this.emit('error', new Error('Invalid data'));\n    if (typeof this.fd !== 'number') {\n        return this.once('open', function () {\n            this._write(data, encoding, cb);\n        });\n    }\n    var self = this; // tslint:disable-line no-this-assignment\n    this._vol.write(this.fd, data, 0, data.length, this.pos, (er, bytes) => {\n        if (er) {\n            if (self.autoClose && self.destroy) {\n                self.destroy();\n            }\n            return cb(er);\n        }\n        self.bytesWritten += bytes;\n        cb();\n    });\n    if (this.pos !== undefined)\n        this.pos += data.length;\n};\nFsWriteStream.prototype._writev = function (data, cb) {\n    if (typeof this.fd !== 'number') {\n        return this.once('open', function () {\n            this._writev(data, cb);\n        });\n    }\n    const self = this; // tslint:disable-line no-this-assignment\n    const len = data.length;\n    const chunks = new Array(len);\n    var size = 0;\n    for (var i = 0; i < len; i++) {\n        var chunk = data[i].chunk;\n        chunks[i] = chunk;\n        size += chunk.length;\n    }\n    const buf = buffer_1.Buffer.concat(chunks);\n    this._vol.write(this.fd, buf, 0, buf.length, this.pos, (er, bytes) => {\n        if (er) {\n            if (self.destroy)\n                self.destroy();\n            return cb(er);\n        }\n        self.bytesWritten += bytes;\n        cb();\n    });\n    if (this.pos !== undefined)\n        this.pos += size;\n};\nFsWriteStream.prototype.close = function (cb) {\n    var _a;\n    if (cb)\n        this.once('close', cb);\n    if (this.closed || typeof this.fd !== 'number') {\n        if (typeof this.fd !== 'number') {\n            this.once('open', closeOnOpen);\n            return;\n        }\n        return (0, queueMicrotask_1.default)(() => this.emit('close'));\n    }\n    // Since Node 18, there is only a getter for '.closed'.\n    // The first branch mimics other setters from Writable.\n    // See https://github.com/nodejs/node/blob/v18.0.0/lib/internal/streams/writable.js#L766\n    if (typeof ((_a = this._writableState) === null || _a === void 0 ? void 0 : _a.closed) === 'boolean') {\n        this._writableState.closed = true;\n    }\n    else {\n        this.closed = true;\n    }\n    this._vol.close(this.fd, er => {\n        if (er)\n            this.emit('error', er);\n        else\n            this.emit('close');\n    });\n    this.fd = null;\n};\nFsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;\n// There is no shutdown() for files.\nFsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;\n// ---------------------------------------- FSWatcher\nclass FSWatcher extends events_1.EventEmitter {\n    constructor(vol) {\n        super();\n        this._filename = '';\n        this._filenameEncoded = '';\n        // _persistent: boolean = true;\n        this._recursive = false;\n        this._encoding = encoding_1.ENCODING_UTF8;\n        // inode -> removers\n        this._listenerRemovers = new Map();\n        this._onParentChild = (link) => {\n            if (link.getName() === this._getName()) {\n                this._emit('rename');\n            }\n        };\n        this._emit = (type) => {\n            this.emit('change', type, this._filenameEncoded);\n        };\n        this._persist = () => {\n            this._timer = setTimeout(this._persist, 1e6);\n        };\n        this._vol = vol;\n        // TODO: Emit \"error\" messages when watching.\n        // this._handle.onchange = function(status, eventType, filename) {\n        //     if (status < 0) {\n        //         self._handle.close();\n        //         const error = !filename ?\n        //             errnoException(status, 'Error watching file for changes:') :\n        //             errnoException(status, `Error watching file ${filename} for changes:`);\n        //         error.filename = filename;\n        //         self.emit('error', error);\n        //     } else {\n        //         self.emit('change', eventType, filename);\n        //     }\n        // };\n    }\n    _getName() {\n        return this._steps[this._steps.length - 1];\n    }\n    start(path, persistent = true, recursive = false, encoding = encoding_1.ENCODING_UTF8) {\n        this._filename = (0, util_1.pathToFilename)(path);\n        this._steps = filenameToSteps(this._filename);\n        this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);\n        // this._persistent = persistent;\n        this._recursive = recursive;\n        this._encoding = encoding;\n        try {\n            this._link = this._vol.getLinkOrThrow(this._filename, 'FSWatcher');\n        }\n        catch (err) {\n            const error = new Error(`watch ${this._filename} ${err.code}`);\n            error.code = err.code;\n            error.errno = err.code;\n            throw error;\n        }\n        const watchLinkNodeChanged = (link) => {\n            var _a;\n            const filepath = link.getPath();\n            const node = link.getNode();\n            const onNodeChange = () => {\n                let filename = relative(this._filename, filepath);\n                if (!filename) {\n                    filename = this._getName();\n                }\n                return this.emit('change', 'change', filename);\n            };\n            node.on('change', onNodeChange);\n            const removers = (_a = this._listenerRemovers.get(node.ino)) !== null && _a !== void 0 ? _a : [];\n            removers.push(() => node.removeListener('change', onNodeChange));\n            this._listenerRemovers.set(node.ino, removers);\n        };\n        const watchLinkChildrenChanged = (link) => {\n            var _a;\n            const node = link.getNode();\n            // when a new link added\n            const onLinkChildAdd = (l) => {\n                this.emit('change', 'rename', relative(this._filename, l.getPath()));\n                setTimeout(() => {\n                    // 1. watch changes of the new link-node\n                    watchLinkNodeChanged(l);\n                    // 2. watch changes of the new link-node's children\n                    watchLinkChildrenChanged(l);\n                });\n            };\n            // when a new link deleted\n            const onLinkChildDelete = (l) => {\n                // remove the listeners of the children nodes\n                const removeLinkNodeListeners = (curLink) => {\n                    const ino = curLink.getNode().ino;\n                    const removers = this._listenerRemovers.get(ino);\n                    if (removers) {\n                        removers.forEach(r => r());\n                        this._listenerRemovers.delete(ino);\n                    }\n                    for (const [name, childLink] of curLink.children.entries()) {\n                        if (childLink && name !== '.' && name !== '..') {\n                            removeLinkNodeListeners(childLink);\n                        }\n                    }\n                };\n                removeLinkNodeListeners(l);\n                this.emit('change', 'rename', relative(this._filename, l.getPath()));\n            };\n            // children nodes changed\n            for (const [name, childLink] of link.children.entries()) {\n                if (childLink && name !== '.' && name !== '..') {\n                    watchLinkNodeChanged(childLink);\n                }\n            }\n            // link children add/remove\n            link.on('child:add', onLinkChildAdd);\n            link.on('child:delete', onLinkChildDelete);\n            const removers = (_a = this._listenerRemovers.get(node.ino)) !== null && _a !== void 0 ? _a : [];\n            removers.push(() => {\n                link.removeListener('child:add', onLinkChildAdd);\n                link.removeListener('child:delete', onLinkChildDelete);\n            });\n            if (recursive) {\n                for (const [name, childLink] of link.children.entries()) {\n                    if (childLink && name !== '.' && name !== '..') {\n                        watchLinkChildrenChanged(childLink);\n                    }\n                }\n            }\n        };\n        watchLinkNodeChanged(this._link);\n        watchLinkChildrenChanged(this._link);\n        const parent = this._link.parent;\n        if (parent) {\n            // parent.on('child:add', this._onParentChild);\n            parent.setMaxListeners(parent.getMaxListeners() + 1);\n            parent.on('child:delete', this._onParentChild);\n        }\n        if (persistent)\n            this._persist();\n    }\n    close() {\n        clearTimeout(this._timer);\n        this._listenerRemovers.forEach(removers => {\n            removers.forEach(r => r());\n        });\n        this._listenerRemovers.clear();\n        const parent = this._link.parent;\n        if (parent) {\n            // parent.removeListener('child:add', this._onParentChild);\n            parent.removeListener('child:delete', this._onParentChild);\n        }\n    }\n}\nexports.FSWatcher = FSWatcher;\n//# sourceMappingURL=volume.js.map\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/volume.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js ***!
  \**************************************************************************************/
/***/ ((module) => {

eval("/*!\n * range-parser\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = rangeParser\n\n/**\n * Parse \"Range\" header `str` relative to the given file `size`.\n *\n * @param {Number} size\n * @param {String} str\n * @param {Object} [options]\n * @return {Array}\n * @public\n */\n\nfunction rangeParser (size, str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string')\n  }\n\n  var index = str.indexOf('=')\n\n  if (index === -1) {\n    return -2\n  }\n\n  // split the range string\n  var arr = str.slice(index + 1).split(',')\n  var ranges = []\n\n  // add ranges type\n  ranges.type = str.slice(0, index)\n\n  // parse all ranges\n  for (var i = 0; i < arr.length; i++) {\n    var range = arr[i].split('-')\n    var start = parseInt(range[0], 10)\n    var end = parseInt(range[1], 10)\n\n    // -nnn\n    if (isNaN(start)) {\n      start = size - end\n      end = size - 1\n    // nnn-\n    } else if (isNaN(end)) {\n      end = size - 1\n    }\n\n    // limit last-byte-pos to current length\n    if (end > size - 1) {\n      end = size - 1\n    }\n\n    // invalid or unsatisifiable\n    if (isNaN(start) || isNaN(end) || start > end || start < 0) {\n      continue\n    }\n\n    // add range\n    ranges.push({\n      start: start,\n      end: end\n    })\n  }\n\n  if (ranges.length < 1) {\n    // unsatisifiable\n    return -1\n  }\n\n  return options && options.combine\n    ? combineRanges(ranges)\n    : ranges\n}\n\n/**\n * Combine overlapping & adjacent ranges.\n * @private\n */\n\nfunction combineRanges (ranges) {\n  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)\n\n  for (var j = 0, i = 1; i < ordered.length; i++) {\n    var range = ordered[i]\n    var current = ordered[j]\n\n    if (range.start > current.end + 1) {\n      // next range\n      ordered[++j] = range\n    } else if (range.end > current.end) {\n      // extend range\n      current.end = range.end\n      current.index = Math.min(current.index, range.index)\n    }\n  }\n\n  // trim ordered array\n  ordered.length = j + 1\n\n  // generate combined range\n  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)\n\n  // copy ranges type\n  combined.type = ranges.type\n\n  return combined\n}\n\n/**\n * Map function to add index value to ranges.\n * @private\n */\n\nfunction mapWithIndex (range, index) {\n  return {\n    start: range.start,\n    end: range.end,\n    index: index\n  }\n}\n\n/**\n * Map function to remove index value from ranges.\n * @private\n */\n\nfunction mapWithoutIndex (range) {\n  return {\n    start: range.start,\n    end: range.end\n  }\n}\n\n/**\n * Sort function to sort ranges by index.\n * @private\n */\n\nfunction sortByRangeIndex (a, b) {\n  return a.index - b.index\n}\n\n/**\n * Sort function to sort ranges by start position.\n * @private\n */\n\nfunction sortByRangeStart (a, b) {\n  return a.start - b.start\n}\n\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/ValidationError.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/ValidationError.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _memorize = _interopRequireDefault(__webpack_require__(/*! ./util/memorize */ \"../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/memorize.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/** @typedef {import(\"json-schema\").JSONSchema6} JSONSchema6 */\n/** @typedef {import(\"json-schema\").JSONSchema7} JSONSchema7 */\n\n/** @typedef {import(\"./validate\").Schema} Schema */\n/** @typedef {import(\"./validate\").ValidationErrorConfiguration} ValidationErrorConfiguration */\n/** @typedef {import(\"./validate\").PostFormatter} PostFormatter */\n/** @typedef {import(\"./validate\").SchemaUtilErrorObject} SchemaUtilErrorObject */\n/** @enum {number} */\nconst SPECIFICITY = {\n  type: 1,\n  not: 1,\n  oneOf: 1,\n  anyOf: 1,\n  if: 1,\n  enum: 1,\n  const: 1,\n  instanceof: 1,\n  required: 2,\n  pattern: 2,\n  patternRequired: 2,\n  format: 2,\n  formatMinimum: 2,\n  formatMaximum: 2,\n  minimum: 2,\n  exclusiveMinimum: 2,\n  maximum: 2,\n  exclusiveMaximum: 2,\n  multipleOf: 2,\n  uniqueItems: 2,\n  contains: 2,\n  minLength: 2,\n  maxLength: 2,\n  minItems: 2,\n  maxItems: 2,\n  minProperties: 2,\n  maxProperties: 2,\n  dependencies: 2,\n  propertyNames: 2,\n  additionalItems: 2,\n  additionalProperties: 2,\n  absolutePath: 2\n};\n\n/**\n * @param {string} value\n * @returns {value is number}\n */\nfunction isNumeric(value) {\n  return /^-?\\d+$/.test(value);\n}\n\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} array\n * @param {(item: SchemaUtilErrorObject) => number} fn\n * @returns {Array<SchemaUtilErrorObject>}\n */\nfunction filterMax(array, fn) {\n  const evaluatedMax = array.reduce((max, item) => Math.max(max, fn(item)), 0);\n  return array.filter(item => fn(item) === evaluatedMax);\n}\n\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} children\n * @returns {Array<SchemaUtilErrorObject>}\n */\nfunction filterChildren(children) {\n  let newChildren = children;\n  newChildren = filterMax(newChildren,\n  /**\n   *\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => error.instancePath ? error.instancePath.length : 0);\n  newChildren = filterMax(newChildren,\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => SPECIFICITY[/** @type {keyof typeof SPECIFICITY} */error.keyword] || 2);\n  return newChildren;\n}\n\n/**\n * Find all children errors\n * @param {Array<SchemaUtilErrorObject>} children\n * @param {Array<string>} schemaPaths\n * @return {number} returns index of first child\n */\nfunction findAllChildren(children, schemaPaths) {\n  let i = children.length - 1;\n  const predicate =\n  /**\n   * @param {string} schemaPath\n   * @returns {boolean}\n   */\n  schemaPath => children[i].schemaPath.indexOf(schemaPath) !== 0;\n  while (i > -1 && !schemaPaths.every(predicate)) {\n    if (children[i].keyword === \"anyOf\" || children[i].keyword === \"oneOf\") {\n      const refs = extractRefs(children[i]);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));\n      i = childrenStart - 1;\n    } else {\n      i -= 1;\n    }\n  }\n  return i + 1;\n}\n\n/**\n * Extracts all refs from schema\n * @param {SchemaUtilErrorObject} error\n * @return {Array<string>}\n */\nfunction extractRefs(error) {\n  const {\n    schema\n  } = error;\n  if (!Array.isArray(schema)) {\n    return [];\n  }\n  return schema.map(({\n    $ref\n  }) => $ref).filter(s => s);\n}\n\n/**\n * Groups children by their first level parent (assuming that error is root)\n * @param {Array<SchemaUtilErrorObject>} children\n * @return {Array<SchemaUtilErrorObject>}\n */\nfunction groupChildrenByFirstChild(children) {\n  const result = [];\n  let i = children.length - 1;\n  while (i > 0) {\n    const child = children[i];\n    if (child.keyword === \"anyOf\" || child.keyword === \"oneOf\") {\n      const refs = extractRefs(child);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));\n      if (childrenStart !== i) {\n        result.push(Object.assign({}, child, {\n          children: children.slice(childrenStart, i)\n        }));\n        i = childrenStart;\n      } else {\n        result.push(child);\n      }\n    } else {\n      result.push(child);\n    }\n    i -= 1;\n  }\n  if (i === 0) {\n    result.push(children[i]);\n  }\n  return result.reverse();\n}\n\n/**\n * @param {string} str\n * @param {string} prefix\n * @returns {string}\n */\nfunction indent(str, prefix) {\n  return str.replace(/\\n(?!$)/g, `\\n${prefix}`);\n}\n\n/**\n * @param {Schema} schema\n * @returns {schema is (Schema & {not: Schema})}\n */\nfunction hasNotInSchema(schema) {\n  return !!schema.not;\n}\n\n/**\n * @param {Schema} schema\n * @return {Schema}\n */\nfunction findFirstTypedSchema(schema) {\n  if (hasNotInSchema(schema)) {\n    return findFirstTypedSchema(schema.not);\n  }\n  return schema;\n}\n\n/**\n * @param {Schema} schema\n * @return {boolean}\n */\nfunction canApplyNot(schema) {\n  const typedSchema = findFirstTypedSchema(schema);\n  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);\n}\n\n/**\n * @param {any} maybeObj\n * @returns {boolean}\n */\nfunction isObject(maybeObj) {\n  return typeof maybeObj === \"object\" && maybeObj !== null;\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeNumber(schema) {\n  return schema.type === \"number\" || typeof schema.minimum !== \"undefined\" || typeof schema.exclusiveMinimum !== \"undefined\" || typeof schema.maximum !== \"undefined\" || typeof schema.exclusiveMaximum !== \"undefined\" || typeof schema.multipleOf !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeInteger(schema) {\n  return schema.type === \"integer\" || typeof schema.minimum !== \"undefined\" || typeof schema.exclusiveMinimum !== \"undefined\" || typeof schema.maximum !== \"undefined\" || typeof schema.exclusiveMaximum !== \"undefined\" || typeof schema.multipleOf !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeString(schema) {\n  return schema.type === \"string\" || typeof schema.minLength !== \"undefined\" || typeof schema.maxLength !== \"undefined\" || typeof schema.pattern !== \"undefined\" || typeof schema.format !== \"undefined\" || typeof schema.formatMinimum !== \"undefined\" || typeof schema.formatMaximum !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeBoolean(schema) {\n  return schema.type === \"boolean\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeArray(schema) {\n  return schema.type === \"array\" || typeof schema.minItems === \"number\" || typeof schema.maxItems === \"number\" || typeof schema.uniqueItems !== \"undefined\" || typeof schema.items !== \"undefined\" || typeof schema.additionalItems !== \"undefined\" || typeof schema.contains !== \"undefined\";\n}\n\n/**\n * @param {Schema & {patternRequired?: Array<string>}} schema\n * @returns {boolean}\n */\nfunction likeObject(schema) {\n  return schema.type === \"object\" || typeof schema.minProperties !== \"undefined\" || typeof schema.maxProperties !== \"undefined\" || typeof schema.required !== \"undefined\" || typeof schema.properties !== \"undefined\" || typeof schema.patternProperties !== \"undefined\" || typeof schema.additionalProperties !== \"undefined\" || typeof schema.dependencies !== \"undefined\" || typeof schema.propertyNames !== \"undefined\" || typeof schema.patternRequired !== \"undefined\";\n}\n\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction likeNull(schema) {\n  return schema.type === \"null\";\n}\n\n/**\n * @param {string} type\n * @returns {string}\n */\nfunction getArticle(type) {\n  if (/^[aeiou]/i.test(type)) {\n    return \"an\";\n  }\n  return \"a\";\n}\n\n/**\n * @param {Schema=} schema\n * @returns {string}\n */\nfunction getSchemaNonTypes(schema) {\n  if (!schema) {\n    return \"\";\n  }\n  if (!schema.type) {\n    if (likeNumber(schema) || likeInteger(schema)) {\n      return \" | should be any non-number\";\n    }\n    if (likeString(schema)) {\n      return \" | should be any non-string\";\n    }\n    if (likeArray(schema)) {\n      return \" | should be any non-array\";\n    }\n    if (likeObject(schema)) {\n      return \" | should be any non-object\";\n    }\n  }\n  return \"\";\n}\n\n/**\n * @param {Array<string>} hints\n * @returns {string}\n */\nfunction formatHints(hints) {\n  return hints.length > 0 ? `(${hints.join(\", \")})` : \"\";\n}\nconst getUtilHints = (0, _memorize.default)(() =>\n// eslint-disable-next-line global-require\n__webpack_require__(/*! ./util/hints */ \"../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/hints.js\"));\n\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @returns {string[]}\n */\nfunction getHints(schema, logic) {\n  if (likeNumber(schema) || likeInteger(schema)) {\n    const util = getUtilHints();\n    return util.numberHints(schema, logic);\n  } else if (likeString(schema)) {\n    const util = getUtilHints();\n    return util.stringHints(schema, logic);\n  }\n  return [];\n}\nclass ValidationError extends Error {\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @param {Schema} schema\n   * @param {ValidationErrorConfiguration} configuration\n   */\n  constructor(errors, schema, configuration = {}) {\n    super();\n\n    /** @type {string} */\n    this.name = \"ValidationError\";\n    /** @type {Array<SchemaUtilErrorObject>} */\n    this.errors = errors;\n    /** @type {Schema} */\n    this.schema = schema;\n    let headerNameFromSchema;\n    let baseDataPathFromSchema;\n    if (schema.title && (!configuration.name || !configuration.baseDataPath)) {\n      const splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);\n      if (splittedTitleFromSchema) {\n        if (!configuration.name) {\n          [, headerNameFromSchema] = splittedTitleFromSchema;\n        }\n        if (!configuration.baseDataPath) {\n          [,, baseDataPathFromSchema] = splittedTitleFromSchema;\n        }\n      }\n    }\n\n    /** @type {string} */\n    this.headerName = configuration.name || headerNameFromSchema || \"Object\";\n    /** @type {string} */\n    this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || \"configuration\";\n\n    /** @type {PostFormatter | null} */\n    this.postFormatter = configuration.postFormatter || null;\n    const header = `Invalid ${this.baseDataPath} object. ${this.headerName} has been initialized using ${getArticle(this.baseDataPath)} ${this.baseDataPath} object that does not match the API schema.\\n`;\n\n    /** @type {string} */\n    this.message = `${header}${this.formatValidationErrors(errors)}`;\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  /**\n   * @param {string} path\n   * @returns {Schema}\n   */\n  getSchemaPart(path) {\n    const newPath = path.split(\"/\");\n    let schemaPart = this.schema;\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[/** @type {keyof Schema} */newPath[i]];\n      if (!inner) {\n        break;\n      }\n      schemaPart = inner;\n    }\n    return schemaPart;\n  }\n\n  /**\n   * @param {Schema} schema\n   * @param {boolean} logic\n   * @param {Array<Object>} prevSchemas\n   * @returns {string}\n   */\n  formatSchema(schema, logic = true, prevSchemas = []) {\n    let newLogic = logic;\n    const formatInnerSchema =\n    /**\n     *\n     * @param {Object} innerSchema\n     * @param {boolean=} addSelf\n     * @returns {string}\n     */\n    (innerSchema, addSelf) => {\n      if (!addSelf) {\n        return this.formatSchema(innerSchema, newLogic, prevSchemas);\n      }\n      if (prevSchemas.includes(innerSchema)) {\n        return \"(recursive)\";\n      }\n      return this.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));\n    };\n    if (hasNotInSchema(schema) && !likeObject(schema)) {\n      if (canApplyNot(schema.not)) {\n        newLogic = !logic;\n        return formatInnerSchema(schema.not);\n      }\n      const needApplyLogicHere = !schema.not.not;\n      const prefix = logic ? \"\" : \"non \";\n      newLogic = !logic;\n      return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);\n    }\n    if ( /** @type {Schema & {instanceof: string | Array<string>}} */schema.instanceof) {\n      const {\n        instanceof: value\n      } = /** @type {Schema & {instanceof: string | Array<string>}} */schema;\n      const values = !Array.isArray(value) ? [value] : value;\n      return values.map(\n      /**\n       * @param {string} item\n       * @returns {string}\n       */\n      item => item === \"Function\" ? \"function\" : item).join(\" | \");\n    }\n    if (schema.enum) {\n      const enumValues = /** @type {Array<any>} */schema.enum.map(item => {\n        if (item === null && schema.undefinedAsNull) {\n          return `${JSON.stringify(item)} | undefined`;\n        }\n        return JSON.stringify(item);\n      }).join(\" | \");\n      return `${enumValues}`;\n    }\n    if (typeof schema.const !== \"undefined\") {\n      return JSON.stringify(schema.const);\n    }\n    if (schema.oneOf) {\n      return (/** @type {Array<Schema>} */schema.oneOf.map(item => formatInnerSchema(item, true)).join(\" | \")\n      );\n    }\n    if (schema.anyOf) {\n      return (/** @type {Array<Schema>} */schema.anyOf.map(item => formatInnerSchema(item, true)).join(\" | \")\n      );\n    }\n    if (schema.allOf) {\n      return (/** @type {Array<Schema>} */schema.allOf.map(item => formatInnerSchema(item, true)).join(\" & \")\n      );\n    }\n    if ( /** @type {JSONSchema7} */schema.if) {\n      const {\n        if: ifValue,\n        then: thenValue,\n        else: elseValue\n      } = /** @type {JSONSchema7} */schema;\n      return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : \"\"}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : \"\"}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : \"\"}`;\n    }\n    if (schema.$ref) {\n      return formatInnerSchema(this.getSchemaPart(schema.$ref), true);\n    }\n    if (likeNumber(schema) || likeInteger(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : \"\"}`;\n      return logic ? str : hints.length > 0 ? `non-${type} | ${str}` : `non-${type}`;\n    }\n    if (likeString(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : \"\"}`;\n      return logic ? str : str === \"string\" ? \"non-string\" : `non-string | ${str}`;\n    }\n    if (likeBoolean(schema)) {\n      return `${logic ? \"\" : \"non-\"}boolean`;\n    }\n    if (likeArray(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n      if (typeof schema.minItems === \"number\") {\n        hints.push(`should not have fewer than ${schema.minItems} item${schema.minItems > 1 ? \"s\" : \"\"}`);\n      }\n      if (typeof schema.maxItems === \"number\") {\n        hints.push(`should not have more than ${schema.maxItems} item${schema.maxItems > 1 ? \"s\" : \"\"}`);\n      }\n      if (schema.uniqueItems) {\n        hints.push(\"should not have duplicate items\");\n      }\n      const hasAdditionalItems = typeof schema.additionalItems === \"undefined\" || Boolean(schema.additionalItems);\n      let items = \"\";\n      if (schema.items) {\n        if (Array.isArray(schema.items) && schema.items.length > 0) {\n          items = `${\n          /** @type {Array<Schema>} */schema.items.map(item => formatInnerSchema(item)).join(\", \")}`;\n          if (hasAdditionalItems) {\n            if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {\n              hints.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`);\n            }\n          }\n        } else if (schema.items && Object.keys(schema.items).length > 0) {\n          // \"additionalItems\" is ignored\n          items = `${formatInnerSchema(schema.items)}`;\n        } else {\n          // Fallback for empty `items` value\n          items = \"any\";\n        }\n      } else {\n        // \"additionalItems\" is ignored\n        items = \"any\";\n      }\n      if (schema.contains && Object.keys(schema.contains).length > 0) {\n        hints.push(`should contains at least one ${this.formatSchema(schema.contains)} item`);\n      }\n      return `[${items}${hasAdditionalItems ? \", ...\" : \"\"}]${hints.length > 0 ? ` (${hints.join(\", \")})` : \"\"}`;\n    }\n    if (likeObject(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n      if (typeof schema.minProperties === \"number\") {\n        hints.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties > 1 ? \"properties\" : \"property\"}`);\n      }\n      if (typeof schema.maxProperties === \"number\") {\n        hints.push(`should not have more than ${schema.maxProperties} ${schema.minProperties && schema.minProperties > 1 ? \"properties\" : \"property\"}`);\n      }\n      if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {\n        const patternProperties = Object.keys(schema.patternProperties);\n        hints.push(`additional property names should match pattern${patternProperties.length > 1 ? \"s\" : \"\"} ${patternProperties.map(pattern => JSON.stringify(pattern)).join(\" | \")}`);\n      }\n      const properties = schema.properties ? Object.keys(schema.properties) : [];\n      /** @type {Array<string>} */\n      // @ts-ignore\n      const required = schema.required ? schema.required : [];\n      const allProperties = [...new Set( /** @type {Array<string>} */[].concat(required).concat(properties))];\n      const objectStructure = allProperties.map(property => {\n        const isRequired = required.includes(property);\n\n        // Some properties need quotes, maybe we should add check\n        // Maybe we should output type of property (`foo: string`), but it is looks very unreadable\n        return `${property}${isRequired ? \"\" : \"?\"}`;\n      }).concat(typeof schema.additionalProperties === \"undefined\" || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [`<key>: ${formatInnerSchema(schema.additionalProperties)}`] : [\"\"] : []).join(\", \");\n      const {\n        dependencies,\n        propertyNames,\n        patternRequired\n      } = /** @type {Schema & {patternRequired?: Array<string>;}} */schema;\n      if (dependencies) {\n        Object.keys(dependencies).forEach(dependencyName => {\n          const dependency = dependencies[dependencyName];\n          if (Array.isArray(dependency)) {\n            hints.push(`should have ${dependency.length > 1 ? \"properties\" : \"property\"} ${dependency.map(dep => `'${dep}'`).join(\", \")} when property '${dependencyName}' is present`);\n          } else {\n            hints.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property '${dependencyName}' is present`);\n          }\n        });\n      }\n      if (propertyNames && Object.keys(propertyNames).length > 0) {\n        hints.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`);\n      }\n      if (patternRequired && patternRequired.length > 0) {\n        hints.push(`should have property matching pattern ${patternRequired.map(\n        /**\n         * @param {string} item\n         * @returns {string}\n         */\n        item => JSON.stringify(item))}`);\n      }\n      return `object {${objectStructure ? ` ${objectStructure} ` : \"\"}}${hints.length > 0 ? ` (${hints.join(\", \")})` : \"\"}`;\n    }\n    if (likeNull(schema)) {\n      return `${logic ? \"\" : \"non-\"}null`;\n    }\n    if (Array.isArray(schema.type)) {\n      // not logic already applied in formatValidationError\n      return `${schema.type.join(\" | \")}`;\n    }\n\n    // Fallback for unknown keywords\n    // not logic already applied in formatValidationError\n    /* istanbul ignore next */\n    return JSON.stringify(schema, null, 2);\n  }\n\n  /**\n   * @param {Schema=} schemaPart\n   * @param {(boolean | Array<string>)=} additionalPath\n   * @param {boolean=} needDot\n   * @param {boolean=} logic\n   * @returns {string}\n   */\n  getSchemaPartText(schemaPart, additionalPath, needDot = false, logic = true) {\n    if (!schemaPart) {\n      return \"\";\n    }\n    if (Array.isArray(additionalPath)) {\n      for (let i = 0; i < additionalPath.length; i++) {\n        /** @type {Schema | undefined} */\n        const inner = schemaPart[/** @type {keyof Schema} */additionalPath[i]];\n        if (inner) {\n          // eslint-disable-next-line no-param-reassign\n          schemaPart = inner;\n        } else {\n          break;\n        }\n      }\n    }\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n    let schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? \".\" : \"\"}`;\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n    if (schemaPart.link) {\n      schemaText += `\\n-> Read more at ${schemaPart.link}`;\n    }\n    return schemaText;\n  }\n\n  /**\n   * @param {Schema=} schemaPart\n   * @returns {string}\n   */\n  getSchemaPartDescription(schemaPart) {\n    if (!schemaPart) {\n      return \"\";\n    }\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n    let schemaText = \"\";\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n    if (schemaPart.link) {\n      schemaText += `\\n-> Read more at ${schemaPart.link}`;\n    }\n    return schemaText;\n  }\n\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {string}\n   */\n  formatValidationError(error) {\n    const {\n      keyword,\n      instancePath: errorInstancePath\n    } = error;\n    const splittedInstancePath = errorInstancePath.split(\"/\");\n    /**\n     * @type {Array<string>}\n     */\n    const defaultValue = [];\n    const prettyInstancePath = splittedInstancePath.reduce((acc, val) => {\n      if (val.length > 0) {\n        if (isNumeric(val)) {\n          acc.push(`[${val}]`);\n        } else if (/^\\[/.test(val)) {\n          acc.push(val);\n        } else {\n          acc.push(`.${val}`);\n        }\n      }\n      return acc;\n    }, defaultValue).join(\"\");\n    const instancePath = `${this.baseDataPath}${prettyInstancePath}`;\n\n    // const { keyword, instancePath: errorInstancePath } = error;\n    // const instancePath = `${this.baseDataPath}${errorInstancePath.replace(/\\//g, '.')}`;\n\n    switch (keyword) {\n      case \"type\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          switch (params.type) {\n            case \"number\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"integer\":\n              return `${instancePath} should be an ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"string\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"boolean\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            case \"array\":\n              return `${instancePath} should be an array:\\n${this.getSchemaPartText(parentSchema)}`;\n            case \"object\":\n              return `${instancePath} should be an object:\\n${this.getSchemaPartText(parentSchema)}`;\n            case \"null\":\n              return `${instancePath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n            default:\n              return `${instancePath} should be:\\n${this.getSchemaPartText(parentSchema)}`;\n          }\n        }\n      case \"instanceof\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${instancePath} should be an instance of ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n      case \"pattern\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            pattern\n          } = params;\n          return `${instancePath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"format\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            format\n          } = params;\n          return `${instancePath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"formatMinimum\":\n      case \"formatExclusiveMinimum\":\n      case \"formatMaximum\":\n      case \"formatExclusiveMaximum\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            comparison,\n            limit\n          } = params;\n          return `${instancePath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minimum\":\n      case \"maximum\":\n      case \"exclusiveMinimum\":\n      case \"exclusiveMaximum\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const {\n            comparison,\n            limit\n          } = params;\n          const [, ...hints] = getHints( /** @type {Schema} */parentSchema, true);\n          if (hints.length === 0) {\n            hints.push(`should be ${comparison} ${limit}`);\n          }\n          return `${instancePath} ${hints.join(\" \")}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"multipleOf\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            multipleOf\n          } = params;\n          return `${instancePath} should be multiple of ${multipleOf}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"patternRequired\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            missingPattern\n          } = params;\n          return `${instancePath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minLength\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          if (limit === 1) {\n            return `${instancePath} should be a non-empty string${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n          const length = limit - 1;\n          return `${instancePath} should be longer than ${length} character${length > 1 ? \"s\" : \"\"}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          if (limit === 1) {\n            return `${instancePath} should be a non-empty array${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n          return `${instancePath} should not have fewer than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"minProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          if (limit === 1) {\n            return `${instancePath} should be a non-empty object${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n          return `${instancePath} should not have fewer than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"maxLength\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          const max = limit + 1;\n          return `${instancePath} should be shorter than ${max} character${max > 1 ? \"s\" : \"\"}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"maxItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          return `${instancePath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"maxProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          return `${instancePath} should not have more than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"uniqueItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            i\n          } = params;\n          return `${instancePath} should not contain the item '${\n          /** @type {{ data: Array<any> }} **/error.data[i]}' twice${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"additionalItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } = params;\n          return `${instancePath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}. These items are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"contains\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${instancePath} should contains at least one ${this.getSchemaPartText(parentSchema, [\"contains\"])} item${getSchemaNonTypes(parentSchema)}.`;\n        }\n      case \"required\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const missingProperty = params.missingProperty.replace(/^\\./, \"\");\n          const hasProperty = parentSchema && Boolean( /** @type {Schema} */\n          parentSchema.properties && /** @type {Schema} */\n          parentSchema.properties[missingProperty]);\n          return `${instancePath} misses the property '${missingProperty}'${getSchemaNonTypes(parentSchema)}.${hasProperty ? ` Should be:\\n${this.getSchemaPartText(parentSchema, [\"properties\", missingProperty])}` : this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"additionalProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            additionalProperty\n          } = params;\n          return `${instancePath} has an unknown property '${additionalProperty}'${getSchemaNonTypes(parentSchema)}. These properties are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"dependencies\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            property,\n            deps\n          } = params;\n          const dependencies = deps.split(\",\").map(\n          /**\n           * @param {string} dep\n           * @returns {string}\n           */\n          dep => `'${dep.trim()}'`).join(\", \");\n          return `${instancePath} should have properties ${dependencies} when property '${property}' is present${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"propertyNames\":\n        {\n          const {\n            params,\n            parentSchema,\n            schema\n          } = error;\n          const {\n            propertyName\n          } = params;\n          return `${instancePath} property name '${propertyName}' is invalid${getSchemaNonTypes(parentSchema)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      case \"enum\":\n        {\n          const {\n            parentSchema\n          } = error;\n          if (parentSchema && /** @type {Schema} */\n          parentSchema.enum && /** @type {Schema} */\n          parentSchema.enum.length === 1) {\n            return `${instancePath} should be ${this.getSchemaPartText(parentSchema, false, true)}`;\n          }\n          return `${instancePath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"const\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${instancePath} should be equal to constant ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n      case \"not\":\n        {\n          const postfix = likeObject( /** @type {Schema} */error.parentSchema) ? `\\n${this.getSchemaPartText(error.parentSchema)}` : \"\";\n          const schemaOutput = this.getSchemaPartText(error.schema, false, false, false);\n          if (canApplyNot(error.schema)) {\n            return `${instancePath} should be any ${schemaOutput}${postfix}.`;\n          }\n          const {\n            schema,\n            parentSchema\n          } = error;\n          return `${instancePath} should not be ${this.getSchemaPartText(schema, false, true)}${parentSchema && likeObject(parentSchema) ? `\\n${this.getSchemaPartText(parentSchema)}` : \"\"}`;\n        }\n      case \"oneOf\":\n      case \"anyOf\":\n        {\n          const {\n            parentSchema,\n            children\n          } = error;\n          if (children && children.length > 0) {\n            if (error.schema.length === 1) {\n              const lastChild = children[children.length - 1];\n              const remainingChildren = children.slice(0, children.length - 1);\n              return this.formatValidationError(Object.assign({}, lastChild, {\n                children: remainingChildren,\n                parentSchema: Object.assign({}, parentSchema, lastChild.parentSchema)\n              }));\n            }\n            let filteredChildren = filterChildren(children);\n            if (filteredChildren.length === 1) {\n              return this.formatValidationError(filteredChildren[0]);\n            }\n            filteredChildren = groupChildrenByFirstChild(filteredChildren);\n            return `${instancePath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}\\nDetails:\\n${filteredChildren.map(\n            /**\n             * @param {SchemaUtilErrorObject} nestedError\n             * @returns {string}\n             */\n            nestedError => ` * ${indent(this.formatValidationError(nestedError), \"   \")}`).join(\"\\n\")}`;\n          }\n          return `${instancePath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n      case \"if\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            failingKeyword\n          } = params;\n          return `${instancePath} should match \"${failingKeyword}\" schema:\\n${this.getSchemaPartText(parentSchema, [failingKeyword])}`;\n        }\n      case \"absolutePath\":\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          return `${instancePath}: ${message}${this.getSchemaPartDescription(parentSchema)}`;\n        }\n      /* istanbul ignore next */\n      default:\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          const ErrorInJSON = JSON.stringify(error, null, 2);\n\n          // For `custom`, `false schema`, `$ref` keywords\n          // Fallback for unknown keywords\n          return `${instancePath} ${message} (${ErrorInJSON}).\\n${this.getSchemaPartText(parentSchema, false)}`;\n        }\n    }\n  }\n\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @returns {string}\n   */\n  formatValidationErrors(errors) {\n    return errors.map(error => {\n      let formattedError = this.formatValidationError(error);\n      if (this.postFormatter) {\n        formattedError = this.postFormatter(formattedError, error);\n      }\n      return ` - ${indent(formattedError, \"   \")}`;\n    }).join(\"\\n\");\n  }\n}\nvar _default = ValidationError;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/ValidationError.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/index.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/index.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  validate,\n  ValidationError,\n  enableValidation,\n  disableValidation,\n  needValidate\n} = __webpack_require__(/*! ./validate */ \"../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/validate.js\");\nmodule.exports = {\n  validate,\n  ValidationError,\n  enableValidation,\n  disableValidation,\n  needValidate\n};\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/keywords/absolutePath.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/keywords/absolutePath.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n/** @typedef {import(\"ajv\").default} Ajv */\n/** @typedef {import(\"ajv\").SchemaValidateFunction} SchemaValidateFunction */\n/** @typedef {import(\"ajv\").AnySchemaObject} AnySchemaObject */\n/** @typedef {import(\"../validate\").SchemaUtilErrorObject} SchemaUtilErrorObject */\n\n/**\n * @param {string} message\n * @param {object} schema\n * @param {string} data\n * @returns {SchemaUtilErrorObject}\n */\nfunction errorMessage(message, schema, data) {\n  return {\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    dataPath: undefined,\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    schemaPath: undefined,\n    keyword: \"absolutePath\",\n    params: {\n      absolutePath: data\n    },\n    message,\n    parentSchema: schema\n  };\n}\n\n/**\n * @param {boolean} shouldBeAbsolute\n * @param {object} schema\n * @param {string} data\n * @returns {SchemaUtilErrorObject}\n */\nfunction getErrorFor(shouldBeAbsolute, schema, data) {\n  const message = shouldBeAbsolute ? `The provided value ${JSON.stringify(data)} is not an absolute path!` : `A relative path is expected. However, the provided value ${JSON.stringify(data)} is an absolute path!`;\n  return errorMessage(message, schema, data);\n}\n\n/**\n *\n * @param {Ajv} ajv\n * @returns {Ajv}\n */\nfunction addAbsolutePathKeyword(ajv) {\n  ajv.addKeyword({\n    keyword: \"absolutePath\",\n    type: \"string\",\n    errors: true,\n    /**\n     * @param {boolean} schema\n     * @param {AnySchemaObject} parentSchema\n     * @returns {SchemaValidateFunction}\n     */\n    compile(schema, parentSchema) {\n      /** @type {SchemaValidateFunction} */\n      const callback = data => {\n        let passes = true;\n        const isExclamationMarkPresent = data.includes(\"!\");\n        if (isExclamationMarkPresent) {\n          callback.errors = [errorMessage(`The provided value ${JSON.stringify(data)} contains exclamation mark (!) which is not allowed because it's reserved for loader syntax.`, parentSchema, data)];\n          passes = false;\n        }\n\n        // ?:[A-Za-z]:\\\\ - Windows absolute path\n        // \\\\\\\\ - Windows network absolute path\n        // \\/ - Unix-like OS absolute path\n        const isCorrectAbsolutePath = schema === /^(?:[A-Za-z]:(\\\\|\\/)|\\\\\\\\|\\/)/.test(data);\n        if (!isCorrectAbsolutePath) {\n          callback.errors = [getErrorFor(schema, parentSchema, data)];\n          passes = false;\n        }\n        return passes;\n      };\n      callback.errors = [];\n      return callback;\n    }\n  });\n  return ajv;\n}\nvar _default = addAbsolutePathKeyword;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/keywords/absolutePath.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/keywords/undefinedAsNull.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/keywords/undefinedAsNull.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n/** @typedef {import(\"ajv\").default} Ajv */\n/** @typedef {import(\"ajv\").SchemaValidateFunction} SchemaValidateFunction */\n/** @typedef {import(\"ajv\").AnySchemaObject} AnySchemaObject */\n/** @typedef {import(\"ajv\").ValidateFunction} ValidateFunction */\n\n/**\n *\n * @param {Ajv} ajv\n * @returns {Ajv}\n */\nfunction addUndefinedAsNullKeyword(ajv) {\n  ajv.addKeyword({\n    keyword: \"undefinedAsNull\",\n    before: \"enum\",\n    modifying: true,\n    /** @type {SchemaValidateFunction} */\n    validate(kwVal, data, metadata, dataCxt) {\n      if (kwVal && dataCxt && metadata && typeof metadata.enum !== \"undefined\") {\n        const idx = dataCxt.parentDataProperty;\n        if (typeof dataCxt.parentData[idx] === \"undefined\") {\n          // eslint-disable-next-line no-param-reassign\n          dataCxt.parentData[dataCxt.parentDataProperty] = null;\n        }\n      }\n      return true;\n    }\n  });\n  return ajv;\n}\nvar _default = addUndefinedAsNullKeyword;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/keywords/undefinedAsNull.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/Range.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/Range.js ***!
  \************************************************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\n\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === \"left\") {\n      return exclusive ? \">\" : \">=\";\n    }\n    return exclusive ? \"<\" : \"<=\";\n  }\n\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n    return `should be ${Range.getOperator(\"right\", exclusive)} ${value}`;\n  }\n\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n    return `should be ${Range.getOperator(\"left\", exclusive)} ${value}`;\n  }\n\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = \"should be\";\n    result += ` ${Range.getOperator(logic ? \"left\" : \"right\", logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? \"and\" : \"or\";\n    result += ` ${Range.getOperator(logic ? \"right\" : \"left\", logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ? /** @type {RangeValueCallback} */\n    ([value]) => value <= minMax : /** @type {RangeValueCallback} */\n    ([value]) => value >= minMax;\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n    if (j > -1) {\n      return values[j];\n    }\n    return [Infinity, true];\n  }\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n    this._right = [];\n  }\n\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n  left(value, exclusive = false) {\n    this._left.push([value, exclusive]);\n  }\n\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n  right(value, exclusive = false) {\n    this._right.push([value, exclusive]);\n  }\n\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n  format(logic = true) {\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return \"\";\n    }\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end;\n\n    // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n    if (realStart === realEnd) {\n      return `should be ${logic ? \"\" : \"!\"}= ${realStart}`;\n    }\n\n    // e.g. 4 < x < \n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    }\n\n    // e.g.  < x < 4\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n}\nmodule.exports = Range;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/Range.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/hints.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/hints.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Range = __webpack_require__(/*! ./Range */ \"../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/Range.js\");\n\n/** @typedef {import(\"../validate\").Schema} Schema */\n\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @return {string[]}\n */\nmodule.exports.stringHints = function stringHints(schema, logic) {\n  const hints = [];\n  let type = \"string\";\n  const currentSchema = {\n    ...schema\n  };\n  if (!logic) {\n    const tmpLength = currentSchema.minLength;\n    const tmpFormat = currentSchema.formatMinimum;\n    currentSchema.minLength = currentSchema.maxLength;\n    currentSchema.maxLength = tmpLength;\n    currentSchema.formatMinimum = currentSchema.formatMaximum;\n    currentSchema.formatMaximum = tmpFormat;\n  }\n  if (typeof currentSchema.minLength === \"number\") {\n    if (currentSchema.minLength === 1) {\n      type = \"non-empty string\";\n    } else {\n      const length = Math.max(currentSchema.minLength - 1, 0);\n      hints.push(`should be longer than ${length} character${length > 1 ? \"s\" : \"\"}`);\n    }\n  }\n  if (typeof currentSchema.maxLength === \"number\") {\n    if (currentSchema.maxLength === 0) {\n      type = \"empty string\";\n    } else {\n      const length = currentSchema.maxLength + 1;\n      hints.push(`should be shorter than ${length} character${length > 1 ? \"s\" : \"\"}`);\n    }\n  }\n  if (currentSchema.pattern) {\n    hints.push(`should${logic ? \"\" : \" not\"} match pattern ${JSON.stringify(currentSchema.pattern)}`);\n  }\n  if (currentSchema.format) {\n    hints.push(`should${logic ? \"\" : \" not\"} match format ${JSON.stringify(currentSchema.format)}`);\n  }\n  if (currentSchema.formatMinimum) {\n    hints.push(`should be ${currentSchema.formatExclusiveMinimum ? \">\" : \">=\"} ${JSON.stringify(currentSchema.formatMinimum)}`);\n  }\n  if (currentSchema.formatMaximum) {\n    hints.push(`should be ${currentSchema.formatExclusiveMaximum ? \"<\" : \"<=\"} ${JSON.stringify(currentSchema.formatMaximum)}`);\n  }\n  return [type].concat(hints);\n};\n\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @return {string[]}\n */\nmodule.exports.numberHints = function numberHints(schema, logic) {\n  const hints = [schema.type === \"integer\" ? \"integer\" : \"number\"];\n  const range = new Range();\n  if (typeof schema.minimum === \"number\") {\n    range.left(schema.minimum);\n  }\n  if (typeof schema.exclusiveMinimum === \"number\") {\n    range.left(schema.exclusiveMinimum, true);\n  }\n  if (typeof schema.maximum === \"number\") {\n    range.right(schema.maximum);\n  }\n  if (typeof schema.exclusiveMaximum === \"number\") {\n    range.right(schema.exclusiveMaximum, true);\n  }\n  const rangeFormat = range.format(logic);\n  if (rangeFormat) {\n    hints.push(rangeFormat);\n  }\n  if (typeof schema.multipleOf === \"number\") {\n    hints.push(`should${logic ? \"\" : \" not\"} be multiple of ${schema.multipleOf}`);\n  }\n  return hints;\n};\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/hints.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/memorize.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/memorize.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n/**\n * @template T\n * @param fn {(function(): any) | undefined}\n * @returns {function(): T}\n */\nconst memoize = fn => {\n  let cache = false;\n  /** @type {T} */\n  let result;\n  return () => {\n    if (cache) {\n      return result;\n    }\n    result = /** @type {function(): any} */fn();\n    cache = true;\n    // Allow to clean up memory for fn\n    // and all dependent resources\n    // eslint-disable-next-line no-undefined, no-param-reassign\n    fn = undefined;\n    return result;\n  };\n};\nvar _default = memoize;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/memorize.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/validate.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/validate.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"ValidationError\", ({\n  enumerable: true,\n  get: function () {\n    return _ValidationError.default;\n  }\n}));\nexports.disableValidation = disableValidation;\nexports.enableValidation = enableValidation;\nexports.needValidate = needValidate;\nexports.validate = validate;\nvar _ValidationError = _interopRequireDefault(__webpack_require__(/*! ./ValidationError */ \"../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/ValidationError.js\"));\nvar _memorize = _interopRequireDefault(__webpack_require__(/*! ./util/memorize */ \"../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/util/memorize.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nconst getAjv = (0, _memorize.default)(() => {\n  // Use CommonJS require for ajv libs so TypeScript consumers aren't locked into esModuleInterop (see #110).\n  // eslint-disable-next-line global-require\n  const Ajv = (__webpack_require__(/*! ajv */ \"../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js\")[\"default\"]);\n  // eslint-disable-next-line global-require\n  const ajvKeywords = (__webpack_require__(/*! ajv-keywords */ \"../../node_modules/.pnpm/ajv-keywords@5.1.0_ajv@8.17.1/node_modules/ajv-keywords/dist/index.js\")[\"default\"]);\n  // eslint-disable-next-line global-require\n  const addFormats = (__webpack_require__(/*! ajv-formats */ \"../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js\")[\"default\"]);\n\n  /**\n   * @type {Ajv}\n   */\n  const ajv = new Ajv({\n    strict: false,\n    allErrors: true,\n    verbose: true,\n    $data: true\n  });\n  ajvKeywords(ajv, [\"instanceof\", \"patternRequired\"]);\n  addFormats(ajv, {\n    keywords: true\n  });\n\n  // Custom keywords\n  // eslint-disable-next-line global-require\n  const addAbsolutePathKeyword = (__webpack_require__(/*! ./keywords/absolutePath */ \"../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/keywords/absolutePath.js\")[\"default\"]);\n  addAbsolutePathKeyword(ajv);\n  const addUndefinedAsNullKeyword =\n  // eslint-disable-next-line global-require\n  (__webpack_require__(/*! ./keywords/undefinedAsNull */ \"../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/keywords/undefinedAsNull.js\")[\"default\"]);\n  addUndefinedAsNullKeyword(ajv);\n  return ajv;\n});\n\n/** @typedef {import(\"json-schema\").JSONSchema4} JSONSchema4 */\n/** @typedef {import(\"json-schema\").JSONSchema6} JSONSchema6 */\n/** @typedef {import(\"json-schema\").JSONSchema7} JSONSchema7 */\n/** @typedef {import(\"ajv\").ErrorObject} ErrorObject */\n\n/**\n * @typedef {Object} Extend\n * @property {string=} formatMinimum\n * @property {string=} formatMaximum\n * @property {string=} formatExclusiveMinimum\n * @property {string=} formatExclusiveMaximum\n * @property {string=} link\n * @property {boolean=} undefinedAsNull\n */\n\n/** @typedef {(JSONSchema4 | JSONSchema6 | JSONSchema7) & Extend} Schema */\n\n/** @typedef {ErrorObject & { children?: Array<ErrorObject> }} SchemaUtilErrorObject */\n\n/**\n * @callback PostFormatter\n * @param {string} formattedError\n * @param {SchemaUtilErrorObject} error\n * @returns {string}\n */\n\n/**\n * @typedef {Object} ValidationErrorConfiguration\n * @property {string=} name\n * @property {string=} baseDataPath\n * @property {PostFormatter=} postFormatter\n */\n\n/**\n * @param {SchemaUtilErrorObject} error\n * @param {number} idx\n * @returns {SchemaUtilErrorObject}\n */\nfunction applyPrefix(error, idx) {\n  // eslint-disable-next-line no-param-reassign\n  error.instancePath = `[${idx}]${error.instancePath}`;\n  if (error.children) {\n    error.children.forEach(err => applyPrefix(err, idx));\n  }\n  return error;\n}\nlet skipValidation = false;\n\n// We use `process.env.SKIP_VALIDATION` because you can have multiple `schema-utils` with different version,\n// so we want to disable it globally, `process.env` doesn't supported by browsers, so we have the local `skipValidation` variables\n\n// Enable validation\nfunction enableValidation() {\n  skipValidation = false;\n\n  // Disable validation for any versions\n  if (process && process.env) {\n    process.env.SKIP_VALIDATION = \"n\";\n  }\n}\n\n// Disable validation\nfunction disableValidation() {\n  skipValidation = true;\n  if (process && process.env) {\n    process.env.SKIP_VALIDATION = \"y\";\n  }\n}\n\n// Check if we need to confirm\nfunction needValidate() {\n  if (skipValidation) {\n    return false;\n  }\n  if (process && process.env && process.env.SKIP_VALIDATION) {\n    const value = process.env.SKIP_VALIDATION.trim();\n    if (/^(?:y|yes|true|1|on)$/i.test(value)) {\n      return false;\n    }\n    if (/^(?:n|no|false|0|off)$/i.test(value)) {\n      return true;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Schema} schema\n * @param {Array<object> | object} options\n * @param {ValidationErrorConfiguration=} configuration\n * @returns {void}\n */\nfunction validate(schema, options, configuration) {\n  if (!needValidate()) {\n    return;\n  }\n  let errors = [];\n  if (Array.isArray(options)) {\n    for (let i = 0; i <= options.length - 1; i++) {\n      errors.push(...validateObject(schema, options[i]).map(err => applyPrefix(err, i)));\n    }\n  } else {\n    errors = validateObject(schema, options);\n  }\n  if (errors.length > 0) {\n    throw new _ValidationError.default(errors, schema, configuration);\n  }\n}\n\n/**\n * @param {Schema} schema\n * @param {Array<object> | object} options\n * @returns {Array<SchemaUtilErrorObject>}\n */\nfunction validateObject(schema, options) {\n  // Not need to cache, because `ajv@8` has built-in cache\n  const compiledSchema = getAjv().compile(schema);\n  const valid = compiledSchema(options);\n  if (valid) return [];\n  return compiledSchema.errors ? filterErrors(compiledSchema.errors) : [];\n}\n\n/**\n * @param {Array<ErrorObject>} errors\n * @returns {Array<SchemaUtilErrorObject>}\n */\nfunction filterErrors(errors) {\n  /** @type {Array<SchemaUtilErrorObject>} */\n  let newErrors = [];\n  for (const error of /** @type {Array<SchemaUtilErrorObject>} */errors) {\n    const {\n      instancePath\n    } = error;\n    /** @type {Array<SchemaUtilErrorObject>} */\n    let children = [];\n    newErrors = newErrors.filter(oldError => {\n      if (oldError.instancePath.includes(instancePath)) {\n        if (oldError.children) {\n          children = children.concat(oldError.children.slice(0));\n        }\n\n        // eslint-disable-next-line no-undefined, no-param-reassign\n        oldError.children = undefined;\n        children.push(oldError);\n        return false;\n      }\n      return true;\n    });\n    if (children.length) {\n      error.children = children;\n    }\n    newErrors.push(error);\n  }\n  return newErrors;\n}\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/validate.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/tree-dump@1.0.2_tslib@2.8.1/node_modules/tree-dump/lib/index.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/tree-dump@1.0.2_tslib@2.8.1/node_modules/tree-dump/lib/index.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./printTree */ \"../../node_modules/.pnpm/tree-dump@1.0.2_tslib@2.8.1/node_modules/tree-dump/lib/printTree.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./printBinary */ \"../../node_modules/.pnpm/tree-dump@1.0.2_tslib@2.8.1/node_modules/tree-dump/lib/printBinary.js\"), exports);\n\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/tree-dump@1.0.2_tslib@2.8.1/node_modules/tree-dump/lib/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/tree-dump@1.0.2_tslib@2.8.1/node_modules/tree-dump/lib/printBinary.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/tree-dump@1.0.2_tslib@2.8.1/node_modules/tree-dump/lib/printBinary.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.printBinary = void 0;\nconst printBinary = (tab = '', children) => {\n    const left = children[0], right = children[1];\n    let str = '';\n    if (left)\n        str += '\\n' + tab + ' ' + left(tab + '  ');\n    if (right)\n        str += '\\n' + tab + ' ' + right(tab + '  ');\n    return str;\n};\nexports.printBinary = printBinary;\n\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/tree-dump@1.0.2_tslib@2.8.1/node_modules/tree-dump/lib/printBinary.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/tree-dump@1.0.2_tslib@2.8.1/node_modules/tree-dump/lib/printTree.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/tree-dump@1.0.2_tslib@2.8.1/node_modules/tree-dump/lib/printTree.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.printTree = void 0;\nconst printTree = (tab = '', children) => {\n    let str = '';\n    let last = children.length - 1;\n    for (; last >= 0; last--)\n        if (children[last])\n            break;\n    for (let i = 0; i <= last; i++) {\n        const fn = children[i];\n        if (!fn)\n            continue;\n        const isLast = i === last;\n        const child = fn(tab + (isLast ? ' ' : '') + '  ');\n        const branch = child ? (isLast ? '' : '') : '';\n        str += '\\n' + tab + branch + (child ? ' ' + child : '');\n    }\n    return str;\n};\nexports.printTree = printTree;\n\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/tree-dump@1.0.2_tslib@2.8.1/node_modules/tree-dump/lib/printTree.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/index.js":
/*!******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/index.js ***!
  \******************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {\n  validate\n} = __webpack_require__(/*! schema-utils */ \"../../node_modules/.pnpm/schema-utils@4.2.0/node_modules/schema-utils/dist/index.js\");\nconst mime = __webpack_require__(/*! mime-types */ \"../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js\");\nconst middleware = __webpack_require__(/*! ./middleware */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/middleware.js\");\nconst getFilenameFromUrl = __webpack_require__(/*! ./utils/getFilenameFromUrl */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/getFilenameFromUrl.js\");\nconst setupHooks = __webpack_require__(/*! ./utils/setupHooks */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/setupHooks.js\");\nconst setupWriteToDisk = __webpack_require__(/*! ./utils/setupWriteToDisk */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/setupWriteToDisk.js\");\nconst setupOutputFileSystem = __webpack_require__(/*! ./utils/setupOutputFileSystem */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/setupOutputFileSystem.js\");\nconst ready = __webpack_require__(/*! ./utils/ready */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/ready.js\");\nconst schema = __webpack_require__(/*! ./options.json */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/options.json\");\nconst noop = () => {};\n\n/** @typedef {import(\"schema-utils/declarations/validate\").Schema} Schema */\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n/** @typedef {import(\"webpack\").MultiCompiler} MultiCompiler */\n/** @typedef {import(\"webpack\").Configuration} Configuration */\n/** @typedef {import(\"webpack\").Stats} Stats */\n/** @typedef {import(\"webpack\").MultiStats} MultiStats */\n/** @typedef {import(\"fs\").ReadStream} ReadStream */\n\n/**\n * @typedef {Object} ExtendedServerResponse\n * @property {{ webpack?: { devMiddleware?: Context<IncomingMessage, ServerResponse> } }} [locals]\n */\n\n/** @typedef {import(\"http\").IncomingMessage} IncomingMessage */\n/** @typedef {import(\"http\").ServerResponse & ExtendedServerResponse} ServerResponse */\n\n/**\n * @callback NextFunction\n * @param {any} [err]\n * @return {void}\n */\n\n/**\n * @typedef {NonNullable<Configuration[\"watchOptions\"]>} WatchOptions\n */\n\n/**\n * @typedef {Compiler[\"watching\"]} Watching\n */\n\n/**\n * @typedef {ReturnType<MultiCompiler[\"watch\"]>} MultiWatching\n */\n\n/**\n * @typedef {import(\"webpack\").OutputFileSystem & { createReadStream?: import(\"fs\").createReadStream, statSync: import(\"fs\").statSync, readFileSync: import(\"fs\").readFileSync }} OutputFileSystem\n */\n\n/** @typedef {ReturnType<Compiler[\"getInfrastructureLogger\"]>} Logger */\n\n/**\n * @callback Callback\n * @param {Stats | MultiStats} [stats]\n */\n\n/**\n * @typedef {Object} ResponseData\n * @property {Buffer | ReadStream} data\n * @property {number} byteLength\n */\n\n/**\n * @template {IncomingMessage} [RequestInternal=IncomingMessage]\n * @template {ServerResponse} [ResponseInternal=ServerResponse]\n * @callback ModifyResponseData\n * @param {RequestInternal} req\n * @param {ResponseInternal} res\n * @param {Buffer | ReadStream} data\n * @param {number} byteLength\n * @return {ResponseData}\n */\n\n/**\n * @template {IncomingMessage} [RequestInternal=IncomingMessage]\n * @template {ServerResponse} [ResponseInternal=ServerResponse]\n * @typedef {Object} Context\n * @property {boolean} state\n * @property {Stats | MultiStats | undefined} stats\n * @property {Callback[]} callbacks\n * @property {Options<RequestInternal, ResponseInternal>} options\n * @property {Compiler | MultiCompiler} compiler\n * @property {Watching | MultiWatching | undefined} watching\n * @property {Logger} logger\n * @property {OutputFileSystem} outputFileSystem\n */\n\n/**\n * @template {IncomingMessage} [RequestInternal=IncomingMessage]\n * @template {ServerResponse} [ResponseInternal=ServerResponse]\n * @typedef {WithoutUndefined<Context<RequestInternal, ResponseInternal>, \"watching\">} FilledContext\n */\n\n/** @typedef {Record<string, string | number> | Array<{ key: string, value: number | string }>} NormalizedHeaders */\n\n/**\n * @template {IncomingMessage} [RequestInternal=IncomingMessage]\n * @template {ServerResponse} [ResponseInternal=ServerResponse]\n * @typedef {NormalizedHeaders | ((req: RequestInternal, res: ResponseInternal, context: Context<RequestInternal, ResponseInternal>) =>  void | undefined | NormalizedHeaders) | undefined} Headers\n */\n\n/**\n * @template {IncomingMessage} [RequestInternal = IncomingMessage]\n * @template {ServerResponse} [ResponseInternal = ServerResponse]\n * @typedef {Object} Options\n * @property {{[key: string]: string}} [mimeTypes]\n * @property {string | undefined} [mimeTypeDefault]\n * @property {boolean | ((targetPath: string) => boolean)} [writeToDisk]\n * @property {string[]} [methods]\n * @property {Headers<RequestInternal, ResponseInternal>} [headers]\n * @property {NonNullable<Configuration[\"output\"]>[\"publicPath\"]} [publicPath]\n * @property {Configuration[\"stats\"]} [stats]\n * @property {boolean} [serverSideRender]\n * @property {OutputFileSystem} [outputFileSystem]\n * @property {boolean | string} [index]\n * @property {ModifyResponseData<RequestInternal, ResponseInternal>} [modifyResponseData]\n * @property {\"weak\" | \"strong\"} [etag]\n * @property {boolean} [lastModified]\n * @property {boolean | number | string | { maxAge?: number, immutable?: boolean }} [cacheControl]\n * @property {boolean} [cacheImmutable]\n */\n\n/**\n * @template {IncomingMessage} [RequestInternal=IncomingMessage]\n * @template {ServerResponse} [ResponseInternal=ServerResponse]\n * @callback Middleware\n * @param {RequestInternal} req\n * @param {ResponseInternal} res\n * @param {NextFunction} next\n * @return {Promise<void>}\n */\n\n/** @typedef {import(\"./utils/getFilenameFromUrl\").Extra} Extra */\n\n/**\n * @callback GetFilenameFromUrl\n * @param {string} url\n * @param {Extra=} extra\n * @returns {string | undefined}\n */\n\n/**\n * @callback WaitUntilValid\n * @param {Callback} callback\n */\n\n/**\n * @callback Invalidate\n * @param {Callback} callback\n */\n\n/**\n * @callback Close\n * @param {(err: Error | null | undefined) => void} callback\n */\n\n/**\n * @template {IncomingMessage} RequestInternal\n * @template {ServerResponse} ResponseInternal\n * @typedef {Object} AdditionalMethods\n * @property {GetFilenameFromUrl} getFilenameFromUrl\n * @property {WaitUntilValid} waitUntilValid\n * @property {Invalidate} invalidate\n * @property {Close} close\n * @property {Context<RequestInternal, ResponseInternal>} context\n */\n\n/**\n * @template {IncomingMessage} [RequestInternal=IncomingMessage]\n * @template {ServerResponse} [ResponseInternal=ServerResponse]\n * @typedef {Middleware<RequestInternal, ResponseInternal> & AdditionalMethods<RequestInternal, ResponseInternal>} API\n */\n\n/**\n * @template T\n * @template {keyof T} K\n * @typedef {Omit<T, K> & Partial<T>} WithOptional\n */\n\n/**\n * @template T\n * @template {keyof T} K\n * @typedef {T & { [P in K]: NonNullable<T[P]> }} WithoutUndefined\n */\n\n/**\n * @template {IncomingMessage} [RequestInternal=IncomingMessage]\n * @template {ServerResponse} [ResponseInternal=ServerResponse]\n * @param {Compiler | MultiCompiler} compiler\n * @param {Options<RequestInternal, ResponseInternal>} [options]\n * @returns {API<RequestInternal, ResponseInternal>}\n */\nfunction wdm(compiler, options = {}) {\n  validate( /** @type {Schema} */schema, options, {\n    name: \"Dev Middleware\",\n    baseDataPath: \"options\"\n  });\n  const {\n    mimeTypes\n  } = options;\n  if (mimeTypes) {\n    const {\n      types\n    } = mime;\n\n    // mimeTypes from user provided options should take priority\n    // over existing, known types\n    // @ts-ignore\n    mime.types = {\n      ...types,\n      ...mimeTypes\n    };\n  }\n\n  /**\n   * @type {WithOptional<Context<RequestInternal, ResponseInternal>, \"watching\" | \"outputFileSystem\">}\n   */\n  const context = {\n    state: false,\n    // eslint-disable-next-line no-undefined\n    stats: undefined,\n    callbacks: [],\n    options,\n    compiler,\n    logger: compiler.getInfrastructureLogger(\"webpack-dev-middleware\")\n  };\n  setupHooks(context);\n  if (options.writeToDisk) {\n    setupWriteToDisk(context);\n  }\n  setupOutputFileSystem(context);\n\n  // Start watching\n  if ( /** @type {Compiler} */context.compiler.watching) {\n    context.watching = /** @type {Compiler} */context.compiler.watching;\n  } else {\n    /**\n     * @param {Error | null | undefined} error\n     */\n    const errorHandler = error => {\n      if (error) {\n        // TODO: improve that in future\n        // For example - `writeToDisk` can throw an error and right now it is ends watching.\n        // We can improve that and keep watching active, but it is require API on webpack side.\n        // Let's implement that in webpack@5 because it is rare case.\n        context.logger.error(error);\n      }\n    };\n    if (Array.isArray( /** @type {MultiCompiler} */context.compiler.compilers)) {\n      const c = /** @type {MultiCompiler} */context.compiler;\n      const watchOptions = c.compilers.map(childCompiler => childCompiler.options.watchOptions || {});\n      context.watching = compiler.watch(watchOptions, errorHandler);\n    } else {\n      const c = /** @type {Compiler} */context.compiler;\n      const watchOptions = c.options.watchOptions || {};\n      context.watching = compiler.watch(watchOptions, errorHandler);\n    }\n  }\n  const filledContext = /** @type {FilledContext<RequestInternal, ResponseInternal>} */\n  context;\n  const instance = /** @type {API<RequestInternal, ResponseInternal>} */\n  middleware(filledContext);\n\n  // API\n  instance.getFilenameFromUrl = (url, extra) => getFilenameFromUrl(filledContext, url, extra);\n  instance.waitUntilValid = (callback = noop) => {\n    ready(filledContext, callback);\n  };\n  instance.invalidate = (callback = noop) => {\n    ready(filledContext, callback);\n    filledContext.watching.invalidate();\n  };\n  instance.close = (callback = noop) => {\n    filledContext.watching.close(callback);\n  };\n  instance.context = filledContext;\n  return instance;\n}\n\n/**\n * @template S\n * @template O\n * @typedef {Object} HapiPluginBase\n * @property {(server: S, options: O) => void | Promise<void>} register\n */\n\n/**\n * @template S\n * @template O\n * @typedef {HapiPluginBase<S, O> & { pkg: { name: string }, multiple: boolean }} HapiPlugin\n */\n\n/**\n * @typedef {Options & { compiler: Compiler | MultiCompiler }} HapiOptions\n */\n\n/**\n * @template HapiServer\n * @template {HapiOptions} HapiOptionsInternal\n * @returns {HapiPlugin<HapiServer, HapiOptionsInternal>}\n */\nfunction hapiWrapper() {\n  return {\n    pkg: {\n      name: \"webpack-dev-middleware\"\n    },\n    // Allow to have multiple middleware\n    multiple: true,\n    register(server, options) {\n      const {\n        compiler,\n        ...rest\n      } = options;\n      if (!compiler) {\n        throw new Error(\"The compiler options is required.\");\n      }\n      const devMiddleware = wdm(compiler, rest);\n\n      // @ts-ignore\n      if (!server.decorations.server.includes(\"webpackDevMiddleware\")) {\n        // @ts-ignore\n        server.decorate(\"server\", \"webpackDevMiddleware\", devMiddleware);\n      }\n\n      // @ts-ignore\n      server.ext(\"onRequest\", (request, h) => new Promise((resolve, reject) => {\n        let isFinished = false;\n\n        /**\n         * @param {string | Buffer} [data]\n         */\n        // eslint-disable-next-line no-param-reassign\n        request.raw.res.send = data => {\n          isFinished = true;\n          request.raw.res.end(data);\n        };\n\n        /**\n         * @param {string | Buffer} [data]\n         */\n        // eslint-disable-next-line no-param-reassign\n        request.raw.res.finish = data => {\n          isFinished = true;\n          request.raw.res.end(data);\n        };\n        devMiddleware(request.raw.req, request.raw.res, error => {\n          if (error) {\n            reject(error);\n            return;\n          }\n          if (!isFinished) {\n            resolve(request);\n          }\n        });\n      }).then(() => h.continue).catch(error => {\n        throw error;\n      }));\n    }\n  };\n}\nwdm.hapiWrapper = hapiWrapper;\n\n/**\n * @template {IncomingMessage} [RequestInternal=IncomingMessage]\n * @template {ServerResponse} [ResponseInternal=ServerResponse]\n * @param {Compiler | MultiCompiler} compiler\n * @param {Options<RequestInternal, ResponseInternal>} [options]\n * @returns {(ctx: any, next: Function) => Promise<void> | void}\n */\nfunction koaWrapper(compiler, options) {\n  const devMiddleware = wdm(compiler, options);\n\n  /**\n   * @param {{ req: RequestInternal, res: ResponseInternal & import(\"./utils/compatibleAPI\").ExpectedServerResponse, status: number, body: string | Buffer | import(\"fs\").ReadStream | { message: string }, state: Object }} ctx\n   * @param {Function} next\n   * @returns {Promise<void>}\n   */\n\n  const wrapper = async function webpackDevMiddleware(ctx, next) {\n    const {\n      req,\n      res\n    } = ctx;\n    res.locals = ctx.state;\n    let {\n      status\n    } = ctx;\n\n    /**\n     * @returns {number} code\n     */\n    res.getStatusCode = () => status;\n\n    /**\n     * @param {number} statusCode status code\n     */\n    res.setStatusCode = statusCode => {\n      status = statusCode;\n      // eslint-disable-next-line no-param-reassign\n      ctx.status = statusCode;\n    };\n    res.getReadyReadableStreamState = () => \"open\";\n    try {\n      await new Promise(\n      /**\n       * @param {(value: void) => void} resolve\n       * @param {(reason?: any) => void} reject\n       */\n      (resolve, reject) => {\n        /**\n         * @param {import(\"fs\").ReadStream} stream readable stream\n         */\n        res.stream = stream => {\n          // eslint-disable-next-line no-param-reassign\n          ctx.body = stream;\n        };\n        /**\n         * @param {string | Buffer} data data\n         */\n        res.send = data => {\n          // eslint-disable-next-line no-param-reassign\n          ctx.body = data;\n        };\n\n        /**\n         * @param {string | Buffer} [data] data\n         */\n        res.finish = data => {\n          // eslint-disable-next-line no-param-reassign\n          ctx.status = status;\n          res.end(data);\n        };\n        devMiddleware(req, res, err => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          resolve();\n        });\n      });\n    } catch (err) {\n      // eslint-disable-next-line no-param-reassign\n      ctx.status = /** @type {Error & { statusCode: number }} */err.statusCode || /** @type {Error & { status: number }} */err.status || 500;\n      // eslint-disable-next-line no-param-reassign\n      ctx.body = {\n        message: /** @type {Error} */err.message\n      };\n    }\n    await next();\n  };\n  wrapper.devMiddleware = devMiddleware;\n  return wrapper;\n}\nwdm.koaWrapper = koaWrapper;\n\n/**\n * @template {IncomingMessage} [RequestInternal=IncomingMessage]\n * @template {ServerResponse} [ResponseInternal=ServerResponse]\n * @param {Compiler | MultiCompiler} compiler\n * @param {Options<RequestInternal, ResponseInternal>} [options]\n * @returns {(ctx: any, next: Function) => Promise<void> | void}\n */\nfunction honoWrapper(compiler, options) {\n  const devMiddleware = wdm(compiler, options);\n\n  /**\n   * @param {{ env: any, body: any, json: any, status: any, set:any, req: RequestInternal & import(\"./utils/compatibleAPI\").ExpectedIncomingMessage & { header: (name: string) => string }, res: ResponseInternal & import(\"./utils/compatibleAPI\").ExpectedServerResponse & { headers: any, status: any } }} c\n   * @param {Function} next\n   * @returns {Promise<void>}\n   */\n  // eslint-disable-next-line consistent-return\n  const wrapper = async function webpackDevMiddleware(c, next) {\n    const {\n      req,\n      res\n    } = c;\n    c.set(\"webpack\", {\n      devMiddleware: devMiddleware.context\n    });\n\n    /**\n     * @returns {string | undefined}\n     */\n    req.getMethod = () => c.req.method;\n\n    /**\n     * @param {string} name\n     * @returns {string | string[] | undefined}\n     */\n    req.getHeader = name => c.req.header(name);\n\n    /**\n     * @returns {string | undefined}\n     */\n    req.getURL = () => c.req.url;\n    let {\n      status\n    } = c.res;\n\n    /**\n     * @returns {number} code\n     */\n    res.getStatusCode = () => status;\n\n    /**\n     * @param {number} code\n     */\n    res.setStatusCode = code => {\n      status = code;\n    };\n\n    /**\n     * @param {string} name header name\n     */\n    res.getHeader = name => c.res.headers.get(name);\n\n    /**\n     * @param {string} name\n     * @param {string | number | Readonly<string[]>} value\n     */\n    res.setHeader = (name, value) => {\n      c.res.headers.append(name, value);\n      return c.res;\n    };\n\n    /**\n     * @param {string} name\n     */\n    res.removeHeader = name => {\n      c.res.headers.delete(name);\n    };\n\n    /**\n     * @returns {string[]}\n     */\n    res.getResponseHeaders = () => Array.from(c.res.headers.keys());\n\n    /**\n     * @returns {ServerResponse}\n     */\n    res.getOutgoing = () => c.env.outgoing;\n    res.setState = () => {\n      // Do nothing, because we set it before\n    };\n    res.getReadyReadableStreamState = () => \"readable\";\n    res.getHeadersSent = () => c.env.outgoing.headersSent;\n    let body;\n    try {\n      await new Promise(\n      /**\n       * @param {(value: void) => void} resolve\n       * @param {(reason?: any) => void} reject\n       */\n      (resolve, reject) => {\n        /**\n         * @param {import(\"fs\").ReadStream} stream readable stream\n         */\n        res.stream = stream => {\n          body = stream;\n          // responseHandler(stream);\n        };\n\n        /**\n         * @param {string | Buffer} data data\n         */\n        res.send = data => {\n          body = data;\n        };\n\n        /**\n         * @param {string | Buffer} [data] data\n         */\n        res.finish = data => {\n          body = typeof data !== \"undefined\" ? data : null;\n        };\n        devMiddleware(req, res, err => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          resolve();\n        });\n      });\n    } catch (err) {\n      c.status(500);\n      return c.json({\n        message: /** @type {Error} */err.message\n      });\n    }\n    if (typeof body !== \"undefined\") {\n      return c.body(body, status);\n    }\n    await next();\n  };\n  wrapper.devMiddleware = devMiddleware;\n  return wrapper;\n}\nwdm.honoWrapper = honoWrapper;\nmodule.exports = wdm;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/middleware.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/middleware.js ***!
  \***********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst mime = __webpack_require__(/*! mime-types */ \"../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js\");\nconst onFinishedStream = __webpack_require__(/*! on-finished */ \"../../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js\");\nconst getFilenameFromUrl = __webpack_require__(/*! ./utils/getFilenameFromUrl */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/getFilenameFromUrl.js\");\nconst {\n  setStatusCode,\n  getStatusCode,\n  getRequestHeader,\n  getRequestMethod,\n  getRequestURL,\n  getResponseHeader,\n  setResponseHeader,\n  removeResponseHeader,\n  getResponseHeaders,\n  getHeadersSent,\n  send,\n  finish,\n  pipe,\n  createReadStreamOrReadFileSync,\n  getOutgoing,\n  initState,\n  setState,\n  getReadyReadableStreamState\n} = __webpack_require__(/*! ./utils/compatibleAPI */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/compatibleAPI.js\");\nconst ready = __webpack_require__(/*! ./utils/ready */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/ready.js\");\nconst parseTokenList = __webpack_require__(/*! ./utils/parseTokenList */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/parseTokenList.js\");\nconst memorize = __webpack_require__(/*! ./utils/memorize */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/memorize.js\");\n\n/** @typedef {import(\"./index.js\").NextFunction} NextFunction */\n/** @typedef {import(\"./index.js\").IncomingMessage} IncomingMessage */\n/** @typedef {import(\"./index.js\").ServerResponse} ServerResponse */\n/** @typedef {import(\"./index.js\").NormalizedHeaders} NormalizedHeaders */\n/** @typedef {import(\"fs\").ReadStream} ReadStream */\n\nconst BYTES_RANGE_REGEXP = /^ *bytes/i;\n\n/**\n * @param {string} type\n * @param {number} size\n * @param {import(\"range-parser\").Range} [range]\n * @returns {string}\n */\nfunction getValueContentRangeHeader(type, size, range) {\n  return `${type} ${range ? `${range.start}-${range.end}` : \"*\"}/${size}`;\n}\n\n/**\n * Parse an HTTP Date into a number.\n *\n * @param {string} date\n * @returns {number}\n */\nfunction parseHttpDate(date) {\n  const timestamp = date && Date.parse(date);\n\n  // istanbul ignore next: guard against date.js Date.parse patching\n  return typeof timestamp === \"number\" ? timestamp : NaN;\n}\nconst CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\\s*?no-cache\\s*?(?:,|$)/;\n\n/**\n * @param {import(\"fs\").ReadStream} stream stream\n * @param {boolean} suppress do need suppress?\n * @returns {void}\n */\nfunction destroyStream(stream, suppress) {\n  if (typeof stream.destroy === \"function\") {\n    stream.destroy();\n  }\n  if (typeof stream.close === \"function\") {\n    // Node.js core bug workaround\n    stream.on(\"open\",\n    /**\n     * @this {import(\"fs\").ReadStream}\n     */\n    function onOpenClose() {\n      // @ts-ignore\n      if (typeof this.fd === \"number\") {\n        // actually close down the fd\n        this.close();\n      }\n    });\n  }\n  if (typeof stream.addListener === \"function\" && suppress) {\n    stream.removeAllListeners(\"error\");\n    stream.addListener(\"error\", () => {});\n  }\n}\n\n/** @type {Record<number, string>} */\nconst statuses = {\n  400: \"Bad Request\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  416: \"Range Not Satisfiable\",\n  500: \"Internal Server Error\"\n};\nconst parseRangeHeaders = memorize(\n/**\n * @param {string} value\n * @returns {import(\"range-parser\").Result | import(\"range-parser\").Ranges}\n */\nvalue => {\n  const [len, rangeHeader] = value.split(\"|\");\n\n  // eslint-disable-next-line global-require\n  return __webpack_require__(/*! range-parser */ \"../../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js\")(Number(len), rangeHeader, {\n    combine: true\n  });\n});\nconst MAX_MAX_AGE = 31536000000;\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @typedef {Object} SendErrorOptions send error options\n * @property {Record<string, number | string | string[] | undefined>=} headers headers\n * @property {import(\"./index\").ModifyResponseData<Request, Response>=} modifyResponseData modify response data callback\n */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"./index.js\").FilledContext<Request, Response>} context\n * @return {import(\"./index.js\").Middleware<Request, Response>}\n */\nfunction wrapper(context) {\n  return async function middleware(req, res, next) {\n    const acceptedMethods = context.options.methods || [\"GET\", \"HEAD\"];\n    initState(res);\n    async function goNext() {\n      if (!context.options.serverSideRender) {\n        return next();\n      }\n      return new Promise(resolve => {\n        ready(context, () => {\n          setState(res, \"webpack\", {\n            devMiddleware: context\n          });\n          resolve(next());\n        }, req);\n      });\n    }\n    const method = getRequestMethod(req);\n    if (method && !acceptedMethods.includes(method)) {\n      await goNext();\n      return;\n    }\n\n    /**\n     * @param {number} status status\n     * @param {Partial<SendErrorOptions<Request, Response>>=} options options\n     * @returns {void}\n     */\n    function sendError(status, options) {\n      // eslint-disable-next-line global-require\n      const escapeHtml = __webpack_require__(/*! ./utils/escapeHtml */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/escapeHtml.js\");\n      const content = statuses[status] || String(status);\n      let document = Buffer.from(`<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Error</title>\n</head>\n<body>\n<pre>${escapeHtml(content)}</pre>\n</body>\n</html>`, \"utf-8\");\n\n      // Clear existing headers\n      const headers = getResponseHeaders(res);\n      for (let i = 0; i < headers.length; i++) {\n        removeResponseHeader(res, headers[i]);\n      }\n      if (options && options.headers) {\n        const keys = Object.keys(options.headers);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const value = options.headers[key];\n          if (typeof value !== \"undefined\") {\n            setResponseHeader(res, key, value);\n          }\n        }\n      }\n\n      // Send basic response\n      setStatusCode(res, status);\n      setResponseHeader(res, \"Content-Type\", \"text/html; charset=utf-8\");\n      setResponseHeader(res, \"Content-Security-Policy\", \"default-src 'none'\");\n      setResponseHeader(res, \"X-Content-Type-Options\", \"nosniff\");\n      let byteLength = Buffer.byteLength(document);\n      if (options && options.modifyResponseData) {\n        ({\n          data: document,\n          byteLength\n        } = /** @type {{ data: Buffer, byteLength: number }} */\n        options.modifyResponseData(req, res, document, byteLength));\n      }\n      setResponseHeader(res, \"Content-Length\", byteLength);\n      finish(res, document);\n    }\n\n    /**\n     * @param {NodeJS.ErrnoException} error\n     */\n    function errorHandler(error) {\n      switch (error.code) {\n        case \"ENAMETOOLONG\":\n        case \"ENOENT\":\n        case \"ENOTDIR\":\n          sendError(404, {\n            modifyResponseData: context.options.modifyResponseData\n          });\n          break;\n        default:\n          sendError(500, {\n            modifyResponseData: context.options.modifyResponseData\n          });\n          break;\n      }\n    }\n    function isConditionalGET() {\n      return getRequestHeader(req, \"if-match\") || getRequestHeader(req, \"if-unmodified-since\") || getRequestHeader(req, \"if-none-match\") || getRequestHeader(req, \"if-modified-since\");\n    }\n    function isPreconditionFailure() {\n      // if-match\n      const ifMatch = /** @type {string} */getRequestHeader(req, \"if-match\");\n\n      // A recipient MUST ignore If-Unmodified-Since if the request contains\n      // an If-Match header field; the condition in If-Match is considered to\n      // be a more accurate replacement for the condition in\n      // If-Unmodified-Since, and the two are only combined for the sake of\n      // interoperating with older intermediaries that might not implement If-Match.\n      if (ifMatch) {\n        const etag = getResponseHeader(res, \"ETag\");\n        return !etag || ifMatch !== \"*\" && parseTokenList(ifMatch).every(match => match !== etag && match !== `W/${etag}` && `W/${match}` !== etag);\n      }\n\n      // if-unmodified-since\n      const ifUnmodifiedSince = /** @type {string} */\n      getRequestHeader(req, \"if-unmodified-since\");\n      if (ifUnmodifiedSince) {\n        const unmodifiedSince = parseHttpDate(ifUnmodifiedSince);\n\n        // A recipient MUST ignore the If-Unmodified-Since header field if the\n        // received field-value is not a valid HTTP-date.\n        if (!isNaN(unmodifiedSince)) {\n          const lastModified = parseHttpDate( /** @type {string} */getResponseHeader(res, \"Last-Modified\"));\n          return isNaN(lastModified) || lastModified > unmodifiedSince;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * @returns {boolean} is cachable\n     */\n    function isCachable() {\n      const statusCode = getStatusCode(res);\n      return statusCode >= 200 && statusCode < 300 || statusCode === 304 ||\n      // For Koa and Hono, because by default status code is 404, but we already found a file\n      statusCode === 404;\n    }\n\n    /**\n     * @param {import(\"http\").OutgoingHttpHeaders} resHeaders\n     * @returns {boolean}\n     */\n    function isFresh(resHeaders) {\n      // Always return stale when Cache-Control: no-cache to support end-to-end reload requests\n      // https://tools.ietf.org/html/rfc2616#section-14.9.4\n      const cacheControl = /** @type {string} */\n      getRequestHeader(req, \"cache-control\");\n      if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {\n        return false;\n      }\n\n      // fields\n      const noneMatch = /** @type {string} */\n      getRequestHeader(req, \"if-none-match\");\n      const modifiedSince = /** @type {string} */\n      getRequestHeader(req, \"if-modified-since\");\n\n      // unconditional request\n      if (!noneMatch && !modifiedSince) {\n        return false;\n      }\n\n      // if-none-match\n      if (noneMatch && noneMatch !== \"*\") {\n        if (!resHeaders.etag) {\n          return false;\n        }\n        const matches = parseTokenList(noneMatch);\n        let etagStale = true;\n        for (let i = 0; i < matches.length; i++) {\n          const match = matches[i];\n          if (match === resHeaders.etag || match === `W/${resHeaders.etag}` || `W/${match}` === resHeaders.etag) {\n            etagStale = false;\n            break;\n          }\n        }\n        if (etagStale) {\n          return false;\n        }\n      }\n\n      // A recipient MUST ignore If-Modified-Since if the request contains an If-None-Match header field;\n      // the condition in If-None-Match is considered to be a more accurate replacement for the condition in If-Modified-Since,\n      // and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-None-Match.\n      if (noneMatch) {\n        return true;\n      }\n\n      // if-modified-since\n      if (modifiedSince) {\n        const lastModified = resHeaders[\"last-modified\"];\n\n        //  A recipient MUST ignore the If-Modified-Since header field if the\n        //  received field-value is not a valid HTTP-date, or if the request\n        //  method is neither GET nor HEAD.\n        const modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));\n        if (modifiedStale) {\n          return false;\n        }\n      }\n      return true;\n    }\n    function isRangeFresh() {\n      const ifRange = /** @type {string | undefined} */\n      getRequestHeader(req, \"if-range\");\n      if (!ifRange) {\n        return true;\n      }\n\n      // if-range as etag\n      if (ifRange.indexOf('\"') !== -1) {\n        const etag = /** @type {string | undefined} */\n        getResponseHeader(res, \"ETag\");\n        if (!etag) {\n          return true;\n        }\n        return Boolean(etag && ifRange.indexOf(etag) !== -1);\n      }\n\n      // if-range as modified date\n      const lastModified = /** @type {string | undefined} */\n      getResponseHeader(res, \"Last-Modified\");\n      if (!lastModified) {\n        return true;\n      }\n      return parseHttpDate(lastModified) <= parseHttpDate(ifRange);\n    }\n\n    /**\n     * @returns {string | undefined}\n     */\n    function getRangeHeader() {\n      const range = /** @type {string} */getRequestHeader(req, \"range\");\n      if (range && BYTES_RANGE_REGEXP.test(range)) {\n        return range;\n      }\n\n      // eslint-disable-next-line no-undefined\n      return undefined;\n    }\n\n    /**\n     * @param {import(\"range-parser\").Range} range\n     * @returns {[number, number]}\n     */\n    function getOffsetAndLenFromRange(range) {\n      const offset = range.start;\n      const len = range.end - range.start + 1;\n      return [offset, len];\n    }\n\n    /**\n     * @param {number} offset\n     * @param {number} len\n     * @returns {[number, number]}\n     */\n    function calcStartAndEnd(offset, len) {\n      const start = offset;\n      const end = Math.max(offset, offset + len - 1);\n      return [start, end];\n    }\n    async function processRequest() {\n      // Pipe and SendFile\n      /** @type {import(\"./utils/getFilenameFromUrl\").Extra} */\n      const extra = {};\n      const filename = getFilenameFromUrl(context, /** @type {string} */getRequestURL(req), extra);\n      if (extra.errorCode) {\n        if (extra.errorCode === 403) {\n          context.logger.error(`Malicious path \"${filename}\".`);\n        }\n        sendError(extra.errorCode, {\n          modifyResponseData: context.options.modifyResponseData\n        });\n        await goNext();\n        return;\n      }\n      if (!filename) {\n        await goNext();\n        return;\n      }\n      if (getHeadersSent(res)) {\n        await goNext();\n        return;\n      }\n      const {\n        size\n      } = /** @type {import(\"fs\").Stats} */extra.stats;\n      let len = size;\n      let offset = 0;\n\n      // Send logic\n      if (context.options.headers) {\n        let {\n          headers\n        } = context.options;\n        if (typeof headers === \"function\") {\n          headers = /** @type {NormalizedHeaders} */\n          headers(req, res, context);\n        }\n\n        /**\n         * @type {{key: string, value: string | number}[]}\n         */\n        const allHeaders = [];\n        if (typeof headers !== \"undefined\") {\n          if (!Array.isArray(headers)) {\n            // eslint-disable-next-line guard-for-in\n            for (const name in headers) {\n              allHeaders.push({\n                key: name,\n                value: headers[name]\n              });\n            }\n            headers = allHeaders;\n          }\n          for (const {\n            key,\n            value\n          } of headers) {\n            setResponseHeader(res, key, value);\n          }\n        }\n      }\n      if (!getResponseHeader(res, \"Accept-Ranges\")) {\n        setResponseHeader(res, \"Accept-Ranges\", \"bytes\");\n      }\n      if (!getResponseHeader(res, \"Cache-Control\")) {\n        // TODO enable the `cacheImmutable` by default for the next major release\n        const cacheControl = context.options.cacheImmutable && extra.immutable ? {\n          immutable: true\n        } : context.options.cacheControl;\n        if (cacheControl) {\n          let cacheControlValue;\n          if (typeof cacheControl === \"boolean\") {\n            cacheControlValue = \"public, max-age=31536000\";\n          } else if (typeof cacheControl === \"number\") {\n            const maxAge = Math.floor(Math.min(Math.max(0, cacheControl), MAX_MAX_AGE) / 1000);\n            cacheControlValue = `public, max-age=${maxAge}`;\n          } else if (typeof cacheControl === \"string\") {\n            cacheControlValue = cacheControl;\n          } else {\n            const maxAge = cacheControl.maxAge ? Math.floor(Math.min(Math.max(0, cacheControl.maxAge), MAX_MAX_AGE) / 1000) : MAX_MAX_AGE / 1000;\n            cacheControlValue = `public, max-age=${maxAge}`;\n            if (cacheControl.immutable) {\n              cacheControlValue += \", immutable\";\n            }\n          }\n          setResponseHeader(res, \"Cache-Control\", cacheControlValue);\n        }\n      }\n      if (context.options.lastModified && !getResponseHeader(res, \"Last-Modified\")) {\n        const modified = /** @type {import(\"fs\").Stats} */\n        extra.stats.mtime.toUTCString();\n        setResponseHeader(res, \"Last-Modified\", modified);\n      }\n\n      /** @type {number} */\n      let start;\n      /** @type {number} */\n      let end;\n\n      /** @type {undefined | Buffer | ReadStream} */\n      let bufferOrStream;\n      /** @type {number | undefined} */\n      let byteLength;\n      const rangeHeader = getRangeHeader();\n      if (context.options.etag && !getResponseHeader(res, \"ETag\")) {\n        /** @type {import(\"fs\").Stats | Buffer | ReadStream | undefined} */\n        let value;\n\n        // TODO cache etag generation?\n        if (context.options.etag === \"weak\") {\n          value = /** @type {import(\"fs\").Stats} */extra.stats;\n        } else {\n          if (rangeHeader) {\n            const parsedRanges = /** @type {import(\"range-parser\").Ranges | import(\"range-parser\").Result} */\n            parseRangeHeaders(`${size}|${rangeHeader}`);\n            if (parsedRanges !== -2 && parsedRanges !== -1 && parsedRanges.length === 1) {\n              [offset, len] = getOffsetAndLenFromRange(parsedRanges[0]);\n            }\n          }\n          [start, end] = calcStartAndEnd(offset, len);\n          try {\n            const result = createReadStreamOrReadFileSync(filename, context.outputFileSystem, start, end);\n            value = result.bufferOrStream;\n            ({\n              bufferOrStream,\n              byteLength\n            } = result);\n          } catch (error) {\n            errorHandler( /** @type {NodeJS.ErrnoException} */error);\n            await goNext();\n            return;\n          }\n        }\n        if (value) {\n          // eslint-disable-next-line global-require\n          const result = await __webpack_require__(/*! ./utils/etag */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/etag.js\")(value);\n\n          // Because we already read stream, we can cache buffer to avoid extra read from fs\n          if (result.buffer) {\n            bufferOrStream = result.buffer;\n          }\n          setResponseHeader(res, \"ETag\", result.hash);\n        }\n      }\n      if (!getResponseHeader(res, \"Content-Type\") || getStatusCode(res) === 404) {\n        removeResponseHeader(res, \"Content-Type\");\n        // content-type name(like application/javascript; charset=utf-8) or false\n        const contentType = mime.contentType(path.extname(filename));\n\n        // Only set content-type header if media type is known\n        // https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n        if (contentType) {\n          setResponseHeader(res, \"Content-Type\", contentType);\n        } else if (context.options.mimeTypeDefault) {\n          setResponseHeader(res, \"Content-Type\", context.options.mimeTypeDefault);\n        }\n      }\n\n      // Conditional GET support\n      if (isConditionalGET()) {\n        if (isPreconditionFailure()) {\n          sendError(412, {\n            modifyResponseData: context.options.modifyResponseData\n          });\n          await goNext();\n          return;\n        }\n        if (isCachable() && isFresh({\n          etag: ( /** @type {string | undefined} */\n          getResponseHeader(res, \"ETag\")),\n          \"last-modified\": ( /** @type {string | undefined} */\n          getResponseHeader(res, \"Last-Modified\"))\n        })) {\n          setStatusCode(res, 304);\n\n          // Remove content header fields\n          removeResponseHeader(res, \"Content-Encoding\");\n          removeResponseHeader(res, \"Content-Language\");\n          removeResponseHeader(res, \"Content-Length\");\n          removeResponseHeader(res, \"Content-Range\");\n          removeResponseHeader(res, \"Content-Type\");\n          finish(res);\n          await goNext();\n          return;\n        }\n      }\n      let isPartialContent = false;\n      if (rangeHeader) {\n        let parsedRanges = /** @type {import(\"range-parser\").Ranges | import(\"range-parser\").Result | []} */\n        parseRangeHeaders(`${size}|${rangeHeader}`);\n\n        // If-Range support\n        if (!isRangeFresh()) {\n          parsedRanges = [];\n        }\n        if (parsedRanges === -1) {\n          context.logger.error(\"Unsatisfiable range for 'Range' header.\");\n          setResponseHeader(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size));\n          sendError(416, {\n            headers: {\n              \"Content-Range\": getResponseHeader(res, \"Content-Range\")\n            },\n            modifyResponseData: context.options.modifyResponseData\n          });\n          await goNext();\n          return;\n        } else if (parsedRanges === -2) {\n          context.logger.error(\"A malformed 'Range' header was provided. A regular response will be sent for this request.\");\n        } else if (parsedRanges.length > 1) {\n          context.logger.error(\"A 'Range' header with multiple ranges was provided. Multiple ranges are not supported, so a regular response will be sent for this request.\");\n        }\n        if (parsedRanges !== -2 && parsedRanges.length === 1) {\n          // Content-Range\n          setStatusCode(res, 206);\n          setResponseHeader(res, \"Content-Range\", getValueContentRangeHeader(\"bytes\", size, /** @type {import(\"range-parser\").Ranges} */parsedRanges[0]));\n          isPartialContent = true;\n          [offset, len] = getOffsetAndLenFromRange(parsedRanges[0]);\n        }\n      }\n\n      // When strong Etag generation is enabled we already read file, so we can skip extra fs call\n      if (!bufferOrStream) {\n        [start, end] = calcStartAndEnd(offset, len);\n        try {\n          ({\n            bufferOrStream,\n            byteLength\n          } = createReadStreamOrReadFileSync(filename, context.outputFileSystem, start, end));\n        } catch (error) {\n          errorHandler( /** @type {NodeJS.ErrnoException} */error);\n          await goNext();\n          return;\n        }\n      }\n      if (context.options.modifyResponseData) {\n        ({\n          data: bufferOrStream,\n          byteLength\n        } = context.options.modifyResponseData(req, res, bufferOrStream, /** @type {number} */\n        byteLength));\n      }\n      setResponseHeader(res, \"Content-Length\", /** @type {number} */\n      byteLength);\n      if (method === \"HEAD\") {\n        if (!isPartialContent) {\n          setStatusCode(res, 200);\n        }\n        finish(res);\n        await goNext();\n        return;\n      }\n      if (!isPartialContent) {\n        setStatusCode(res, 200);\n      }\n      const isPipeSupports = typeof ( /** @type {import(\"fs\").ReadStream} */bufferOrStream.pipe) === \"function\";\n      if (!isPipeSupports) {\n        send(res, /** @type {Buffer} */bufferOrStream);\n        await goNext();\n        return;\n      }\n\n      // Cleanup\n      const cleanup = () => {\n        destroyStream( /** @type {import(\"fs\").ReadStream} */bufferOrStream, true);\n      };\n\n      // Error handling\n      /** @type {import(\"fs\").ReadStream} */\n      bufferOrStream.on(\"error\", error => {\n        // clean up stream early\n        cleanup();\n        errorHandler(error);\n        goNext();\n      }).on(getReadyReadableStreamState(res), () => {\n        goNext();\n      });\n      pipe(res, /** @type {ReadStream} */bufferOrStream);\n      const outgoing = getOutgoing(res);\n      if (outgoing) {\n        // Response finished, cleanup\n        onFinishedStream(outgoing, cleanup);\n      }\n    }\n    ready(context, processRequest, req);\n  };\n}\nmodule.exports = wrapper;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/middleware.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/compatibleAPI.js":
/*!********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/compatibleAPI.js ***!
  \********************************************************************************************************************************************/
/***/ ((module) => {

eval("\n\n/** @typedef {import(\"../index.js\").IncomingMessage} IncomingMessage */\n/** @typedef {import(\"../index.js\").ServerResponse} ServerResponse */\n/** @typedef {import(\"../index\").OutputFileSystem} OutputFileSystem */\n\n/**\n * @typedef {Object} ExpectedIncomingMessage\n * @property {(name: string) => string | string[] | undefined} [getHeader]\n * @property {() => string | undefined} [getMethod]\n * @property {() => string | undefined} [getURL]\n */\n\n/**\n * @typedef {Object} ExpectedServerResponse\n * @property {(status: number) => void} [setStatusCode]\n * @property {() => number} [getStatusCode]\n * @property {(name: string) => string | string[] | undefined | number} [getHeader]\n * @property {(name: string, value: number | string | Readonly<string[]>) => ExpectedServerResponse} [setHeader]\n * @property {(name: string) => void} [removeHeader]\n * @property {(data: string | Buffer) => void} [send]\n * @property {(data?: string | Buffer) => void} [finish]\n * @property {() => string[]} [getResponseHeaders]\n * @property {() => boolean} [getHeadersSent]\n * @property {(data: any) => void} [stream]\n * @property {() => any} [getOutgoing]\n * @property {(name: string, value: any) => void} [setState]\n * @property {() => \"ready\" | \"open\" | \"readable\"} [getReadyReadableStreamState]\n */\n\n/**\n * @template {IncomingMessage & ExpectedIncomingMessage} Request\n * @param {Request} req\n * @param {string} name\n * @returns {string | string[] | undefined}\n */\nfunction getRequestHeader(req, name) {\n  // Pseudo API\n  if (typeof req.getHeader === \"function\") {\n    return req.getHeader(name);\n  }\n  return req.headers[name];\n}\n\n/**\n * @template {IncomingMessage & ExpectedIncomingMessage} Request\n * @param {Request} req\n * @returns {string | undefined}\n */\nfunction getRequestMethod(req) {\n  // Pseudo API\n  if (typeof req.getMethod === \"function\") {\n    return req.getMethod();\n  }\n  return req.method;\n}\n\n/**\n * @template {IncomingMessage & ExpectedIncomingMessage} Request\n * @param {Request} req\n * @returns {string | undefined}\n */\nfunction getRequestURL(req) {\n  // Pseudo API\n  if (typeof req.getURL === \"function\") {\n    return req.getURL();\n  }\n  return req.url;\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @param {number} code\n */\nfunction setStatusCode(res, code) {\n  // Pseudo API\n  if (typeof res.setStatusCode === \"function\") {\n    res.setStatusCode(code);\n    return;\n  }\n\n  // Node.js API\n  // eslint-disable-next-line no-param-reassign\n  res.statusCode = code;\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @returns {number}\n */\nfunction getStatusCode(res) {\n  // Pseudo API\n  if (typeof res.getStatusCode === \"function\") {\n    return res.getStatusCode();\n  }\n  return res.statusCode;\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @param {string} name\n * @returns {string | string[] | undefined | number}\n */\nfunction getResponseHeader(res, name) {\n  // Real and Pseudo API\n  return res.getHeader(name);\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @param {string} name\n * @param {number | string | Readonly<string[]>} value\n * @returns {Response}\n */\nfunction setResponseHeader(res, name, value) {\n  // Real and Pseudo API\n  return res.setHeader(name, value);\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @param {string} name\n */\nfunction removeResponseHeader(res, name) {\n  // Real and Pseudo API\n  res.removeHeader(name);\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @returns {string[]}\n */\nfunction getResponseHeaders(res) {\n  // Pseudo API\n  if (typeof res.getResponseHeaders === \"function\") {\n    return res.getResponseHeaders();\n  }\n  return res.getHeaderNames();\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @returns {boolean}\n */\nfunction getHeadersSent(res) {\n  // Pseudo API\n  if (typeof res.getHeadersSent === \"function\") {\n    return res.getHeadersSent();\n  }\n  return res.headersSent;\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @param {import(\"fs\").ReadStream} bufferOrStream\n */\nfunction pipe(res, bufferOrStream) {\n  // Pseudo API and Koa API\n  if (typeof res.stream === \"function\") {\n    // Writable stream into Readable stream\n    res.stream(bufferOrStream);\n    return;\n  }\n\n  // Node.js API and Express API and Hapi API\n  bufferOrStream.pipe(res);\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @param {string | Buffer} bufferOrString\n */\nfunction send(res, bufferOrString) {\n  // Pseudo API and Express API and Koa API\n  if (typeof res.send === \"function\") {\n    res.send(bufferOrString);\n    return;\n  }\n  res.end(bufferOrString);\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @param {string | Buffer} [data]\n */\nfunction finish(res, data) {\n  // Pseudo API and Express API and Koa API\n  if (typeof res.finish === \"function\") {\n    res.finish(data);\n    return;\n  }\n\n  // Pseudo API and Express API and Koa API\n  res.end(data);\n}\n\n/**\n * @param {string} filename\n * @param {OutputFileSystem} outputFileSystem\n * @param {number} start\n * @param {number} end\n * @returns {{ bufferOrStream: (Buffer | import(\"fs\").ReadStream), byteLength: number }}\n */\nfunction createReadStreamOrReadFileSync(filename, outputFileSystem, start, end) {\n  /** @type {string | Buffer | import(\"fs\").ReadStream} */\n  let bufferOrStream;\n  /** @type {number} */\n  let byteLength;\n\n  // Stream logic\n  const isFsSupportsStream = typeof outputFileSystem.createReadStream === \"function\";\n  if (isFsSupportsStream) {\n    bufferOrStream = /** @type {import(\"fs\").createReadStream} */\n    outputFileSystem.createReadStream(filename, {\n      start,\n      end\n    });\n\n    // Handle files with zero bytes\n    byteLength = end === 0 ? 0 : end - start + 1;\n  } else {\n    bufferOrStream = outputFileSystem.readFileSync(filename);\n    ({\n      byteLength\n    } = bufferOrStream);\n  }\n  return {\n    bufferOrStream,\n    byteLength\n  };\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @returns {Response} res\n */\nfunction getOutgoing(res) {\n  // Pseudo API and Express API and Koa API\n  if (typeof res.getOutgoing === \"function\") {\n    return res.getOutgoing();\n  }\n  return res;\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n */\nfunction initState(res) {\n  if (typeof res.setState === \"function\") {\n    return;\n  }\n\n  // fixes #282. credit @cexoso. in certain edge situations res.locals is undefined.\n  // eslint-disable-next-line no-param-reassign\n  res.locals = res.locals || {};\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @param {string} name\n * @param {any} value\n */\nfunction setState(res, name, value) {\n  if (typeof res.setState === \"function\") {\n    res.setState(name, value);\n    return;\n  }\n\n  /** @type {any} */\n  // eslint-disable-next-line no-param-reassign\n  res.locals[name] = value;\n}\n\n/**\n * @template {ServerResponse & ExpectedServerResponse} Response\n * @param {Response} res\n * @returns {\"ready\" | \"open\" | \"readable\"}\n */\nfunction getReadyReadableStreamState(res) {\n  // Pseudo API and Express API and Koa API\n  if (typeof res.getReadyReadableStreamState === \"function\") {\n    return res.getReadyReadableStreamState();\n  }\n  return \"ready\";\n}\nmodule.exports = {\n  setStatusCode,\n  getStatusCode,\n  getRequestHeader,\n  getRequestMethod,\n  getRequestURL,\n  getResponseHeader,\n  setResponseHeader,\n  removeResponseHeader,\n  getResponseHeaders,\n  getHeadersSent,\n  pipe,\n  send,\n  finish,\n  createReadStreamOrReadFileSync,\n  getOutgoing,\n  initState,\n  setState,\n  getReadyReadableStreamState\n};\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/compatibleAPI.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/escapeHtml.js":
/*!*****************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/escapeHtml.js ***!
  \*****************************************************************************************************************************************/
/***/ ((module) => {

eval("\n\nconst matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * @param {string} string raw HTML\n * @returns {string} escaped HTML\n */\nfunction escapeHtml(string) {\n  const str = `${string}`;\n  const match = matchHtmlRegExp.exec(str);\n  if (!match) {\n    return str;\n  }\n  let escape;\n  let html = \"\";\n  let index = 0;\n  let lastIndex = 0;\n  for (({\n    index\n  } = match); index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      // \"\n      case 34:\n        escape = \"&quot;\";\n        break;\n      // &\n      case 38:\n        escape = \"&amp;\";\n        break;\n      // '\n      case 39:\n        escape = \"&#39;\";\n        break;\n      // <\n      case 60:\n        escape = \"&lt;\";\n        break;\n      // >\n      case 62:\n        escape = \"&gt;\";\n        break;\n      default:\n        // eslint-disable-next-line no-continue\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escape;\n  }\n  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n}\nmodule.exports = escapeHtml;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/escapeHtml.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/etag.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/etag.js ***!
  \***********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\n/** @typedef {import(\"fs\").Stats} Stats */\n/** @typedef {import(\"fs\").ReadStream} ReadStream */\n\n/**\n * Generate a tag for a stat.\n *\n * @param {Stats} stat\n * @return {{ hash: string, buffer?: Buffer }}\n */\nfunction statTag(stat) {\n  const mtime = stat.mtime.getTime().toString(16);\n  const size = stat.size.toString(16);\n  return {\n    hash: `W/\"${size}-${mtime}\"`\n  };\n}\n\n/**\n * Generate an entity tag.\n *\n * @param {Buffer | ReadStream} entity\n * @return {Promise<{ hash: string, buffer?: Buffer }>}\n */\nasync function entityTag(entity) {\n  const sha1 = crypto.createHash(\"sha1\");\n  if (!Buffer.isBuffer(entity)) {\n    let byteLength = 0;\n\n    /** @type {Buffer[]} */\n    const buffers = [];\n    await new Promise((resolve, reject) => {\n      entity.on(\"data\", chunk => {\n        sha1.update(chunk);\n        buffers.push( /** @type {Buffer} */chunk);\n        byteLength += /** @type {Buffer} */chunk.byteLength;\n      }).on(\"end\", () => {\n        resolve(sha1);\n      }).on(\"error\", reject);\n    });\n    return {\n      buffer: Buffer.concat(buffers),\n      hash: `\"${byteLength.toString(16)}-${sha1.digest(\"base64\").substring(0, 27)}\"`\n    };\n  }\n  if (entity.byteLength === 0) {\n    // Fast-path empty\n    return {\n      hash: '\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"'\n    };\n  }\n\n  // Compute hash of entity\n  const hash = sha1.update(entity).digest(\"base64\").substring(0, 27);\n\n  // Compute length of entity\n  const {\n    byteLength\n  } = entity;\n  return {\n    hash: `\"${byteLength.toString(16)}-${hash}\"`\n  };\n}\n\n/**\n * Create a simple ETag.\n *\n * @param {Buffer | ReadStream | Stats} entity\n * @return {Promise<{ hash: string, buffer?: Buffer }>}\n */\nasync function etag(entity) {\n  const isStrong = Buffer.isBuffer(entity) || typeof ( /** @type {ReadStream} */entity.pipe) === \"function\";\n  return isStrong ? entityTag( /** @type {Buffer | ReadStream} */entity) : statTag( /** @type {import(\"fs\").Stats} */entity);\n}\nmodule.exports = etag;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/etag.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/getFilenameFromUrl.js":
/*!*************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/getFilenameFromUrl.js ***!
  \*************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst {\n  parse\n} = __webpack_require__(/*! url */ \"url\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst getPaths = __webpack_require__(/*! ./getPaths */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/getPaths.js\");\nconst memorize = __webpack_require__(/*! ./memorize */ \"../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/memorize.js\");\n\n/** @typedef {import(\"../index.js\").IncomingMessage} IncomingMessage */\n/** @typedef {import(\"../index.js\").ServerResponse} ServerResponse */\n\n// eslint-disable-next-line no-undefined\nconst memoizedParse = memorize(parse, undefined, value => {\n  if (value.pathname) {\n    // eslint-disable-next-line no-param-reassign\n    value.pathname = decode(value.pathname);\n  }\n  return value;\n});\nconst UP_PATH_REGEXP = /(?:^|[\\\\/])\\.\\.(?:[\\\\/]|$)/;\n\n/**\n * @typedef {Object} Extra\n * @property {import(\"fs\").Stats=} stats\n * @property {number=} errorCode\n * @property {boolean=} immutable\n */\n\n/**\n * decodeURIComponent.\n *\n * Allows V8 to only deoptimize this fn instead of all of send().\n *\n * @param {string} input\n * @returns {string}\n */\n\nfunction decode(input) {\n  return querystring.unescape(input);\n}\n\n// TODO refactor me in the next major release, this function should return `{ filename, stats, error }`\n// TODO fix redirect logic when `/` at the end, like https://github.com/pillarjs/send/blob/master/index.js#L586\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"../index.js\").FilledContext<Request, Response>} context\n * @param {string} url\n * @param {Extra=} extra\n * @returns {string | undefined}\n */\nfunction getFilenameFromUrl(context, url, extra = {}) {\n  const {\n    options\n  } = context;\n  const paths = getPaths(context);\n\n  /** @type {string | undefined} */\n  let foundFilename;\n  /** @type {URL} */\n  let urlObject;\n  try {\n    // The `url` property of the `request` is contains only  `pathname`, `search` and `hash`\n    urlObject = memoizedParse(url, false, true);\n  } catch (_ignoreError) {\n    return;\n  }\n  for (const {\n    publicPath,\n    outputPath,\n    assetsInfo\n  } of paths) {\n    /** @type {string | undefined} */\n    let filename;\n    /** @type {URL} */\n    let publicPathObject;\n    try {\n      publicPathObject = memoizedParse(publicPath !== \"auto\" && publicPath ? publicPath : \"/\", false, true);\n    } catch (_ignoreError) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    const {\n      pathname\n    } = urlObject;\n    const {\n      pathname: publicPathPathname\n    } = publicPathObject;\n    if (pathname && pathname.startsWith(publicPathPathname)) {\n      // Null byte(s)\n      if (pathname.includes(\"\\0\")) {\n        // eslint-disable-next-line no-param-reassign\n        extra.errorCode = 400;\n        return;\n      }\n\n      // \"..\" is malicious\n      if (UP_PATH_REGEXP.test(path.normalize(`./${pathname}`))) {\n        // eslint-disable-next-line no-param-reassign\n        extra.errorCode = 403;\n        return;\n      }\n\n      // Strip the `pathname` property from the `publicPath` option from the start of requested url\n      // `/complex/foo.js` => `foo.js`\n      // and add outputPath\n      // `foo.js` => `/home/user/my-project/dist/foo.js`\n      filename = path.join(outputPath, pathname.slice(publicPathPathname.length));\n      try {\n        // eslint-disable-next-line no-param-reassign\n        extra.stats = context.outputFileSystem.statSync(filename);\n      } catch (_ignoreError) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      if (extra.stats.isFile()) {\n        foundFilename = filename;\n\n        // Rspack does not yet support `assetsInfo`, so we need to check if `assetsInfo` exists here\n        if (assetsInfo) {\n          const assetInfo = assetsInfo.get(pathname.slice(publicPathObject.pathname.length));\n\n          // eslint-disable-next-line no-param-reassign\n          extra.immutable = assetInfo ? assetInfo.immutable : false;\n        }\n        break;\n      } else if (extra.stats.isDirectory() && (typeof options.index === \"undefined\" || options.index)) {\n        const indexValue = typeof options.index === \"undefined\" || typeof options.index === \"boolean\" ? \"index.html\" : options.index;\n        filename = path.join(filename, indexValue);\n        try {\n          // eslint-disable-next-line no-param-reassign\n          extra.stats = context.outputFileSystem.statSync(filename);\n        } catch (__ignoreError) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        if (extra.stats.isFile()) {\n          foundFilename = filename;\n          break;\n        }\n      }\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  return foundFilename;\n}\nmodule.exports = getFilenameFromUrl;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/getFilenameFromUrl.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/getPaths.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/getPaths.js ***!
  \***************************************************************************************************************************************/
/***/ ((module) => {

eval("\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n/** @typedef {import(\"webpack\").Stats} Stats */\n/** @typedef {import(\"webpack\").MultiStats} MultiStats */\n/** @typedef {import(\"../index.js\").IncomingMessage} IncomingMessage */\n/** @typedef {import(\"../index.js\").ServerResponse} ServerResponse */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"../index.js\").FilledContext<Request, Response>} context\n */\nfunction getPaths(context) {\n  const {\n    stats,\n    options\n  } = context;\n  /** @type {Stats[]} */\n  const childStats = /** @type {MultiStats} */\n  stats.stats ? /** @type {MultiStats} */stats.stats : [( /** @type {Stats} */stats)];\n  const publicPaths = [];\n  for (const {\n    compilation\n  } of childStats) {\n    if (compilation.options.devServer === false) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    // The `output.path` is always present and always absolute\n    const outputPath = compilation.getPath(compilation.outputOptions.path || \"\");\n    const publicPath = options.publicPath ? compilation.getPath(options.publicPath) : compilation.outputOptions.publicPath ? compilation.getPath(compilation.outputOptions.publicPath) : \"\";\n    publicPaths.push({\n      outputPath,\n      publicPath,\n      assetsInfo: compilation.assetsInfo\n    });\n  }\n  return publicPaths;\n}\nmodule.exports = getPaths;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/getPaths.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/memorize.js":
/*!***************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/memorize.js ***!
  \***************************************************************************************************************************************/
/***/ ((module) => {

eval("\n\nconst cacheStore = new WeakMap();\n\n/**\n * @template T\n * @param {Function} fn\n * @param {{ cache?: Map<string, { data: T }> } | undefined} cache\n * @param {((value: T) => T)=} callback\n * @returns {any}\n */\nfunction memorize(fn, {\n  cache = new Map()\n} = {}, callback) {\n  /**\n   * @param {any} arguments_\n   * @return {any}\n   */\n  const memoized = (...arguments_) => {\n    const [key] = arguments_;\n    const cacheItem = cache.get(key);\n    if (cacheItem) {\n      return cacheItem.data;\n    }\n\n    // @ts-ignore\n    let result = fn.apply(this, arguments_);\n    if (callback) {\n      result = callback(result);\n    }\n    cache.set(key, {\n      data: result\n    });\n    return result;\n  };\n  cacheStore.set(memoized, cache);\n  return memoized;\n}\nmodule.exports = memorize;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/memorize.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/parseTokenList.js":
/*!*********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/parseTokenList.js ***!
  \*********************************************************************************************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Parse a HTTP token list.\n *\n * @param {string} str\n * @returns {string[]} tokens\n */\nfunction parseTokenList(str) {\n  let end = 0;\n  let start = 0;\n  const list = [];\n\n  // gather tokens\n  for (let i = 0, len = str.length; i < len; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x20 /*   */:\n        if (start === end) {\n          end = i + 1;\n          start = end;\n        }\n        break;\n      case 0x2c /* , */:\n        if (start !== end) {\n          list.push(str.substring(start, end));\n        }\n        end = i + 1;\n        start = end;\n        break;\n      default:\n        end = i + 1;\n        break;\n    }\n  }\n\n  // final token\n  if (start !== end) {\n    list.push(str.substring(start, end));\n  }\n  return list;\n}\nmodule.exports = parseTokenList;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/parseTokenList.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/ready.js":
/*!************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/ready.js ***!
  \************************************************************************************************************************************/
/***/ ((module) => {

eval("\n\n/** @typedef {import(\"../index.js\").IncomingMessage} IncomingMessage */\n/** @typedef {import(\"../index.js\").ServerResponse} ServerResponse */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"../index.js\").FilledContext<Request, Response>} context\n * @param {(...args: any[]) => any} callback\n * @param {Request} [req]\n * @returns {void}\n */\nfunction ready(context, callback, req) {\n  if (context.state) {\n    callback(context.stats);\n    return;\n  }\n  const name = req && req.url || callback.name;\n  context.logger.info(`wait until bundle finished${name ? `: ${name}` : \"\"}`);\n  context.callbacks.push(callback);\n}\nmodule.exports = ready;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/ready.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/setupHooks.js":
/*!*****************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/setupHooks.js ***!
  \*****************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/** @typedef {import(\"webpack\").Configuration} Configuration */\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n/** @typedef {import(\"webpack\").MultiCompiler} MultiCompiler */\n/** @typedef {import(\"webpack\").Stats} Stats */\n/** @typedef {import(\"webpack\").MultiStats} MultiStats */\n/** @typedef {import(\"../index.js\").IncomingMessage} IncomingMessage */\n/** @typedef {import(\"../index.js\").ServerResponse} ServerResponse */\n\n/** @typedef {Configuration[\"stats\"]} StatsOptions */\n/** @typedef {{ children: Configuration[\"stats\"][] }} MultiStatsOptions */\n/** @typedef {Exclude<Configuration[\"stats\"], boolean | string | undefined>} StatsObjectOptions */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"../index.js\").WithOptional<import(\"../index.js\").Context<Request, Response>, \"watching\" | \"outputFileSystem\">} context\n */\nfunction setupHooks(context) {\n  function invalid() {\n    if (context.state) {\n      context.logger.log(\"Compilation starting...\");\n    }\n\n    // We are now in invalid state\n    // eslint-disable-next-line no-param-reassign\n    context.state = false;\n    // eslint-disable-next-line no-param-reassign, no-undefined\n    context.stats = undefined;\n  }\n\n  /**\n   * @param {StatsOptions} statsOptions\n   * @returns {StatsObjectOptions}\n   */\n  function normalizeStatsOptions(statsOptions) {\n    if (typeof statsOptions === \"undefined\") {\n      // eslint-disable-next-line no-param-reassign\n      statsOptions = {\n        preset: \"normal\"\n      };\n    } else if (typeof statsOptions === \"boolean\") {\n      // eslint-disable-next-line no-param-reassign\n      statsOptions = statsOptions ? {\n        preset: \"normal\"\n      } : {\n        preset: \"none\"\n      };\n    } else if (typeof statsOptions === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      statsOptions = {\n        preset: statsOptions\n      };\n    }\n    return statsOptions;\n  }\n\n  /**\n   * @param {Stats | MultiStats} stats\n   */\n  function done(stats) {\n    // We are now on valid state\n    // eslint-disable-next-line no-param-reassign\n    context.state = true;\n    // eslint-disable-next-line no-param-reassign\n    context.stats = stats;\n\n    // Do the stuff in nextTick, because bundle may be invalidated if a change happened while compiling\n    process.nextTick(() => {\n      const {\n        compiler,\n        logger,\n        options,\n        state,\n        callbacks\n      } = context;\n\n      // Check if still in valid state\n      if (!state) {\n        return;\n      }\n      logger.log(\"Compilation finished\");\n      const isMultiCompilerMode = Boolean( /** @type {MultiCompiler} */\n      compiler.compilers);\n\n      /**\n       * @type {StatsOptions | MultiStatsOptions | undefined}\n       */\n      let statsOptions;\n      if (typeof options.stats !== \"undefined\") {\n        statsOptions = isMultiCompilerMode ? {\n          children: /** @type {MultiCompiler} */\n          compiler.compilers.map(() => options.stats)\n        } : options.stats;\n      } else {\n        statsOptions = isMultiCompilerMode ? {\n          children: /** @type {MultiCompiler} */\n          compiler.compilers.map(child => child.options.stats)\n        } : /** @type {Compiler} */compiler.options.stats;\n      }\n      if (isMultiCompilerMode) {\n        /** @type {MultiStatsOptions} */\n        statsOptions.children = /** @type {MultiStatsOptions} */\n        statsOptions.children.map(\n        /**\n         * @param {StatsOptions} childStatsOptions\n         * @return {StatsObjectOptions}\n         */\n        childStatsOptions => {\n          // eslint-disable-next-line no-param-reassign\n          childStatsOptions = normalizeStatsOptions(childStatsOptions);\n          if (typeof childStatsOptions.colors === \"undefined\") {\n            // eslint-disable-next-line no-param-reassign\n            childStatsOptions.colors =\n            // eslint-disable-next-line global-require\n            (__webpack_require__(/*! colorette */ \"../../node_modules/.pnpm/colorette@2.0.20/node_modules/colorette/index.cjs\").isColorSupported);\n          }\n          return childStatsOptions;\n        });\n      } else {\n        statsOptions = normalizeStatsOptions( /** @type {StatsOptions} */statsOptions);\n        if (typeof statsOptions.colors === \"undefined\") {\n          // eslint-disable-next-line global-require\n          statsOptions.colors = (__webpack_require__(/*! colorette */ \"../../node_modules/.pnpm/colorette@2.0.20/node_modules/colorette/index.cjs\").isColorSupported);\n        }\n      }\n      const printedStats = stats.toString( /** @type {StatsObjectOptions} */statsOptions);\n\n      // Avoid extra empty line when `stats: 'none'`\n      if (printedStats) {\n        // eslint-disable-next-line no-console\n        console.log(printedStats);\n      }\n\n      // eslint-disable-next-line no-param-reassign\n      context.callbacks = [];\n\n      // Execute callback that are delayed\n      for (const callback of callbacks) {\n        callback(stats);\n      }\n    });\n  }\n\n  // eslint-disable-next-line prefer-destructuring\n  const compiler = /** @type {import(\"../index.js\").Context<Request, Response>} */\n  context.compiler;\n  compiler.hooks.watchRun.tap(\"webpack-dev-middleware\", invalid);\n  compiler.hooks.invalid.tap(\"webpack-dev-middleware\", invalid);\n  compiler.hooks.done.tap(\"webpack-dev-middleware\", done);\n}\nmodule.exports = setupHooks;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/setupHooks.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/setupOutputFileSystem.js":
/*!****************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/setupOutputFileSystem.js ***!
  \****************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst memfs = __webpack_require__(/*! memfs */ \"../../node_modules/.pnpm/memfs@4.14.0/node_modules/memfs/lib/index.js\");\n\n/** @typedef {import(\"webpack\").MultiCompiler} MultiCompiler */\n/** @typedef {import(\"../index.js\").IncomingMessage} IncomingMessage */\n/** @typedef {import(\"../index.js\").ServerResponse} ServerResponse */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"../index.js\").WithOptional<import(\"../index.js\").Context<Request, Response>, \"watching\" | \"outputFileSystem\">} context\n */\nfunction setupOutputFileSystem(context) {\n  let outputFileSystem;\n  if (context.options.outputFileSystem) {\n    const {\n      outputFileSystem: outputFileSystemFromOptions\n    } = context.options;\n    outputFileSystem = outputFileSystemFromOptions;\n  }\n  // Don't use `memfs` when developer wants to write everything to a disk, because it doesn't make sense.\n  else if (context.options.writeToDisk !== true) {\n    outputFileSystem = memfs.createFsFromVolume(new memfs.Volume());\n  } else {\n    const isMultiCompiler = /** @type {MultiCompiler} */\n    context.compiler.compilers;\n    if (isMultiCompiler) {\n      // Prefer compiler with `devServer` option or fallback on the first\n      // TODO we need to support webpack-dev-server as a plugin or revisit it\n      const compiler = /** @type {MultiCompiler} */\n      context.compiler.compilers.filter(item => Object.prototype.hasOwnProperty.call(item.options, \"devServer\") && item.options.devServer !== false);\n      ({\n        outputFileSystem\n      } = compiler[0] || /** @type {MultiCompiler} */\n      context.compiler.compilers[0]);\n    } else {\n      ({\n        outputFileSystem\n      } = context.compiler);\n    }\n  }\n  const compilers = /** @type {MultiCompiler} */\n  context.compiler.compilers || [context.compiler];\n  for (const compiler of compilers) {\n    if (compiler.options.devServer === false) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    // @ts-ignore\n    compiler.outputFileSystem = outputFileSystem;\n  }\n\n  // @ts-ignore\n  // eslint-disable-next-line no-param-reassign\n  context.outputFileSystem = outputFileSystem;\n}\nmodule.exports = setupOutputFileSystem;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/setupOutputFileSystem.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/setupWriteToDisk.js":
/*!***********************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/setupWriteToDisk.js ***!
  \***********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\n\n/** @typedef {import(\"webpack\").Compiler} Compiler */\n/** @typedef {import(\"webpack\").MultiCompiler} MultiCompiler */\n/** @typedef {import(\"webpack\").Compilation} Compilation */\n/** @typedef {import(\"../index.js\").IncomingMessage} IncomingMessage */\n/** @typedef {import(\"../index.js\").ServerResponse} ServerResponse */\n\n/**\n * @template {IncomingMessage} Request\n * @template {ServerResponse} Response\n * @param {import(\"../index.js\").WithOptional<import(\"../index.js\").Context<Request, Response>, \"watching\" | \"outputFileSystem\">} context\n */\nfunction setupWriteToDisk(context) {\n  /**\n   * @type {Compiler[]}\n   */\n  const compilers = /** @type {MultiCompiler} */\n  context.compiler.compilers || [context.compiler];\n  for (const compiler of compilers) {\n    if (compiler.options.devServer === false) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    compiler.hooks.emit.tap(\"DevMiddleware\", () => {\n      // @ts-ignore\n      if (compiler.hasWebpackDevMiddlewareAssetEmittedCallback) {\n        return;\n      }\n      compiler.hooks.assetEmitted.tapAsync(\"DevMiddleware\", (file, info, callback) => {\n        const {\n          targetPath,\n          content\n        } = info;\n        const {\n          writeToDisk: filter\n        } = context.options;\n        const allowWrite = filter && typeof filter === \"function\" ? filter(targetPath) : true;\n        if (!allowWrite) {\n          return callback();\n        }\n        const dir = path.dirname(targetPath);\n        const name = compiler.options.name ? `Child \"${compiler.options.name}\": ` : \"\";\n        return fs.mkdir(dir, {\n          recursive: true\n        }, mkdirError => {\n          if (mkdirError) {\n            context.logger.error(`${name}Unable to write \"${dir}\" directory to disk:\\n${mkdirError}`);\n            return callback(mkdirError);\n          }\n          return fs.writeFile(targetPath, content, writeFileError => {\n            if (writeFileError) {\n              context.logger.error(`${name}Unable to write \"${targetPath}\" asset to disk:\\n${writeFileError}`);\n              return callback(writeFileError);\n            }\n            context.logger.log(`${name}Asset written to disk: \"${targetPath}\"`);\n            return callback();\n          });\n        });\n      });\n\n      // @ts-ignore\n      compiler.hasWebpackDevMiddlewareAssetEmittedCallback = true;\n    });\n  }\n}\nmodule.exports = setupWriteToDisk;\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/utils/setupWriteToDisk.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/colorette@2.0.20/node_modules/colorette/index.cjs":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/colorette@2.0.20/node_modules/colorette/index.cjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar tty = __webpack_require__(/*! tty */ \"tty\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar tty__namespace = /*#__PURE__*/_interopNamespace(tty);\n\nconst {\n  env = {},\n  argv = [],\n  platform = \"\",\n} = typeof process === \"undefined\" ? {} : process;\n\nconst isDisabled = \"NO_COLOR\" in env || argv.includes(\"--no-color\");\nconst isForced = \"FORCE_COLOR\" in env || argv.includes(\"--color\");\nconst isWindows = platform === \"win32\";\nconst isDumbTerminal = env.TERM === \"dumb\";\n\nconst isCompatibleTerminal =\n  tty__namespace && tty__namespace.isatty && tty__namespace.isatty(1) && env.TERM && !isDumbTerminal;\n\nconst isCI =\n  \"CI\" in env &&\n  (\"GITHUB_ACTIONS\" in env || \"GITLAB_CI\" in env || \"CIRCLECI\" in env);\n\nconst isColorSupported =\n  !isDisabled &&\n  (isForced || (isWindows && !isDumbTerminal) || isCompatibleTerminal || isCI);\n\nconst replaceClose = (\n  index,\n  string,\n  close,\n  replace,\n  head = string.substring(0, index) + replace,\n  tail = string.substring(index + close.length),\n  next = tail.indexOf(close)\n) => head + (next < 0 ? tail : replaceClose(next, tail, close, replace));\n\nconst clearBleed = (index, string, open, close, replace) =>\n  index < 0\n    ? open + string + close\n    : open + replaceClose(index, string, close, replace) + close;\n\nconst filterEmpty =\n  (open, close, replace = open, at = open.length + 1) =>\n  (string) =>\n    string || !(string === \"\" || string === undefined)\n      ? clearBleed(\n          (\"\" + string).indexOf(close, at),\n          string,\n          open,\n          close,\n          replace\n        )\n      : \"\";\n\nconst init = (open, close, replace) =>\n  filterEmpty(`\\x1b[${open}m`, `\\x1b[${close}m`, replace);\n\nconst colors = {\n  reset: init(0, 0),\n  bold: init(1, 22, \"\\x1b[22m\\x1b[1m\"),\n  dim: init(2, 22, \"\\x1b[22m\\x1b[2m\"),\n  italic: init(3, 23),\n  underline: init(4, 24),\n  inverse: init(7, 27),\n  hidden: init(8, 28),\n  strikethrough: init(9, 29),\n  black: init(30, 39),\n  red: init(31, 39),\n  green: init(32, 39),\n  yellow: init(33, 39),\n  blue: init(34, 39),\n  magenta: init(35, 39),\n  cyan: init(36, 39),\n  white: init(37, 39),\n  gray: init(90, 39),\n  bgBlack: init(40, 49),\n  bgRed: init(41, 49),\n  bgGreen: init(42, 49),\n  bgYellow: init(43, 49),\n  bgBlue: init(44, 49),\n  bgMagenta: init(45, 49),\n  bgCyan: init(46, 49),\n  bgWhite: init(47, 49),\n  blackBright: init(90, 39),\n  redBright: init(91, 39),\n  greenBright: init(92, 39),\n  yellowBright: init(93, 39),\n  blueBright: init(94, 39),\n  magentaBright: init(95, 39),\n  cyanBright: init(96, 39),\n  whiteBright: init(97, 39),\n  bgBlackBright: init(100, 49),\n  bgRedBright: init(101, 49),\n  bgGreenBright: init(102, 49),\n  bgYellowBright: init(103, 49),\n  bgBlueBright: init(104, 49),\n  bgMagentaBright: init(105, 49),\n  bgCyanBright: init(106, 49),\n  bgWhiteBright: init(107, 49),\n};\n\nconst createColors = ({ useColor = isColorSupported } = {}) =>\n  useColor\n    ? colors\n    : Object.keys(colors).reduce(\n        (colors, key) => ({ ...colors, [key]: String }),\n        {}\n      );\n\nconst {\n  reset,\n  bold,\n  dim,\n  italic,\n  underline,\n  inverse,\n  hidden,\n  strikethrough,\n  black,\n  red,\n  green,\n  yellow,\n  blue,\n  magenta,\n  cyan,\n  white,\n  gray,\n  bgBlack,\n  bgRed,\n  bgGreen,\n  bgYellow,\n  bgBlue,\n  bgMagenta,\n  bgCyan,\n  bgWhite,\n  blackBright,\n  redBright,\n  greenBright,\n  yellowBright,\n  blueBright,\n  magentaBright,\n  cyanBright,\n  whiteBright,\n  bgBlackBright,\n  bgRedBright,\n  bgGreenBright,\n  bgYellowBright,\n  bgBlueBright,\n  bgMagentaBright,\n  bgCyanBright,\n  bgWhiteBright,\n} = createColors();\n\nexports.bgBlack = bgBlack;\nexports.bgBlackBright = bgBlackBright;\nexports.bgBlue = bgBlue;\nexports.bgBlueBright = bgBlueBright;\nexports.bgCyan = bgCyan;\nexports.bgCyanBright = bgCyanBright;\nexports.bgGreen = bgGreen;\nexports.bgGreenBright = bgGreenBright;\nexports.bgMagenta = bgMagenta;\nexports.bgMagentaBright = bgMagentaBright;\nexports.bgRed = bgRed;\nexports.bgRedBright = bgRedBright;\nexports.bgWhite = bgWhite;\nexports.bgWhiteBright = bgWhiteBright;\nexports.bgYellow = bgYellow;\nexports.bgYellowBright = bgYellowBright;\nexports.black = black;\nexports.blackBright = blackBright;\nexports.blue = blue;\nexports.blueBright = blueBright;\nexports.bold = bold;\nexports.createColors = createColors;\nexports.cyan = cyan;\nexports.cyanBright = cyanBright;\nexports.dim = dim;\nexports.gray = gray;\nexports.green = green;\nexports.greenBright = greenBright;\nexports.hidden = hidden;\nexports.inverse = inverse;\nexports.isColorSupported = isColorSupported;\nexports.italic = italic;\nexports.magenta = magenta;\nexports.magentaBright = magentaBright;\nexports.red = red;\nexports.redBright = redBright;\nexports.reset = reset;\nexports.strikethrough = strikethrough;\nexports.underline = underline;\nexports.white = white;\nexports.whiteBright = whiteBright;\nexports.yellow = yellow;\nexports.yellowBright = yellowBright;\n\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/colorette@2.0.20/node_modules/colorette/index.cjs?");

/***/ }),

/***/ "../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = __webpack_require__(/*! ./lib/utils */ \"../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js\")\nconst SCHEMES = __webpack_require__(/*! ./lib/schemes */ \"../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js\")\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(components, options)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?', components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#', components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false })\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && !parsed.path && parsed.query === undefined) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path !== undefined && parsed.path.length) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment !== undefined && parsed.fragment.length) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports[\"default\"] = fastUri\nmodule.exports.fastUri = fastUri\n\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/index.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("\n\nconst UUID_REG = /^[\\da-f]{8}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/schemes.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js ***!
  \****************************************************************************************/
/***/ ((module) => {

eval("\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { HEX } = __webpack_require__(/*! ./scopedChars */ \"../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/scopedChars.js\")\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host, opts = {}) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components, options) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false })\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/fast-uri@3.0.3/node_modules/fast-uri/lib/utils.js?");

/***/ }),

/***/ "../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs":
/*!*****************************************************************************!*\
  !*** ../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),\n/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __propKey: () => (/* binding */ __propKey),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __rewriteRelativeImportExtension: () => (/* binding */ __rewriteRelativeImportExtension),\n/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),\n/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nfunction __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nfunction __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nfunction __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nfunction __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nfunction __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nfunction __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nfunction __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nfunction __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nfunction __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n});\n\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json":
/*!********************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json ***!
  \********************************************************************************/
/***/ ((module) => {

eval("module.exports = /*#__PURE__*/JSON.parse('{\"$id\":\"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\"description\":\"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\"type\":\"object\",\"required\":[\"$data\"],\"properties\":{\"$data\":{\"type\":\"string\",\"anyOf\":[{\"format\":\"relative-json-pointer\"},{\"format\":\"json-pointer\"}]}},\"additionalProperties\":false}');\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json?");

/***/ }),

/***/ "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json ***!
  \************************************************************************************************/
/***/ ((module) => {

eval("module.exports = /*#__PURE__*/JSON.parse('{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$comment\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":true,\"readOnly\":{\"type\":\"boolean\",\"default\":false},\"examples\":{\"type\":\"array\",\"items\":true},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":true},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"propertyNames\":{\"format\":\"regex\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":true,\"enum\":{\"type\":\"array\",\"items\":true,\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"contentMediaType\":{\"type\":\"string\"},\"contentEncoding\":{\"type\":\"string\"},\"if\":{\"$ref\":\"#\"},\"then\":{\"$ref\":\"#\"},\"else\":{\"$ref\":\"#\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":true}');\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json?");

/***/ }),

/***/ "../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/options.json":
/*!**********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/options.json ***!
  \**********************************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = /*#__PURE__*/JSON.parse('{\"type\":\"object\",\"properties\":{\"mimeTypes\":{\"description\":\"Allows a user to register custom mime types or extension mappings.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#mimetypes\",\"type\":\"object\"},\"mimeTypeDefault\":{\"description\":\"Allows a user to register a default mime type when we can\\'t determine the content type.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#mimetypedefault\",\"type\":\"string\"},\"writeToDisk\":{\"description\":\"Allows to write generated files on disk.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#writetodisk\",\"anyOf\":[{\"type\":\"boolean\"},{\"instanceof\":\"Function\"}]},\"methods\":{\"description\":\"Allows to pass the list of HTTP request methods accepted by the middleware.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#methods\",\"type\":\"array\",\"items\":{\"type\":\"string\",\"minLength\":1}},\"headers\":{\"anyOf\":[{\"type\":\"array\",\"items\":{\"type\":\"object\",\"additionalProperties\":false,\"properties\":{\"key\":{\"description\":\"key of header.\",\"type\":\"string\"},\"value\":{\"description\":\"value of header.\",\"type\":\"string\"}}},\"minItems\":1},{\"type\":\"object\"},{\"instanceof\":\"Function\"}],\"description\":\"Allows to pass custom HTTP headers on each request\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#headers\"},\"publicPath\":{\"description\":\"The `publicPath` specifies the public URL address of the output files when referenced in a browser.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#publicpath\",\"anyOf\":[{\"enum\":[\"auto\"]},{\"type\":\"string\"},{\"instanceof\":\"Function\"}]},\"stats\":{\"description\":\"Stats options object or preset name.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#stats\",\"anyOf\":[{\"enum\":[\"none\",\"summary\",\"errors-only\",\"errors-warnings\",\"minimal\",\"normal\",\"detailed\",\"verbose\"]},{\"type\":\"boolean\"},{\"type\":\"object\",\"additionalProperties\":true}]},\"serverSideRender\":{\"description\":\"Instructs the module to enable or disable the server-side rendering mode.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#serversiderender\",\"type\":\"boolean\"},\"outputFileSystem\":{\"description\":\"Set the default file system which will be used by webpack as primary destination of generated files.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#outputfilesystem\",\"type\":\"object\"},\"index\":{\"description\":\"Allows to serve an index of the directory.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#index\",\"anyOf\":[{\"type\":\"boolean\"},{\"type\":\"string\",\"minLength\":1}]},\"modifyResponseData\":{\"description\":\"Allows to set up a callback to change the response data.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#modifyresponsedata\",\"instanceof\":\"Function\"},\"etag\":{\"description\":\"Enable or disable etag generation.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#etag\",\"enum\":[\"weak\",\"strong\"]},\"lastModified\":{\"description\":\"Enable or disable `Last-Modified` header. Uses the file system\\'s last modified value.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#lastmodified\",\"type\":\"boolean\"},\"cacheControl\":{\"description\":\"Enable or disable setting `Cache-Control` response header.\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#cachecontrol\",\"anyOf\":[{\"type\":\"boolean\"},{\"type\":\"number\"},{\"type\":\"string\",\"minLength\":1},{\"type\":\"object\",\"properties\":{\"maxAge\":{\"type\":\"number\"},\"immutable\":{\"type\":\"boolean\"}},\"additionalProperties\":false}]},\"cacheImmutable\":{\"description\":\"Enable or disable setting `Cache-Control: public, max-age=31536000, immutable` response header for immutable assets (i.e. asset with a hash in file name like `image.a4c12bde.jpg`).\",\"link\":\"https://github.com/webpack/webpack-dev-middleware#cacheimmutable\",\"type\":\"boolean\"}},\"additionalProperties\":false}');\n\n//# sourceURL=webpack://playground/../../node_modules/.pnpm/webpack-dev-middleware@7.4.2_webpack@5.96.1/node_modules/webpack-dev-middleware/dist/options.json?");

/***/ })

};
;